<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thorine</title>
  
  <subtitle>凡是过往，皆为序章</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://icewind-r.github.io/"/>
  <updated>2021-06-22T07:36:32.021Z</updated>
  <id>http://icewind-r.github.io/</id>
  
  <author>
    <name>大雪初晴丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What？？要放假了！</title>
    <link href="http://icewind-r.github.io/2021/06/22/What%EF%BC%9F%EF%BC%9F%E8%A6%81%E6%94%BE%E5%81%87%E4%BA%86%EF%BC%81/"/>
    <id>http://icewind-r.github.io/2021/06/22/What%EF%BC%9F%EF%BC%9F%E8%A6%81%E6%94%BE%E5%81%87%E4%BA%86%EF%BC%81/</id>
    <published>2021-06-22T07:35:37.000Z</published>
    <updated>2021-06-22T07:36:32.021Z</updated>
    
    <content type="html"><![CDATA[<p>这波啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这波啊&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>机器学习_06</title>
    <link href="http://icewind-r.github.io/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/"/>
    <id>http://icewind-r.github.io/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/</id>
    <published>2021-01-22T00:29:04.000Z</published>
    <updated>2021-01-23T04:57:37.857Z</updated>
    
    <content type="html"><![CDATA[<p>本节总结分类算法中的 <strong>决策树</strong> 和 <strong>随机森林</strong> 算法。 </p><a id="more"></a><hr><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树思想的来源非常朴素，程序设计中的条件分支结构就是if-then结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法</p><p><strong>决策树：是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果，本质是一颗由多个判断节点组成的树</strong>。</p><img src="/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/1.png" class><p>决策树涉及概念较多，不好理解，这里就先给出 API ，学会基本的调用即可。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)</p><ul><li>criterion<ul><li>特征选择标准</li><li>“gini”或者”entropy”，前者代表基尼系数，后者代表信息增益。一默认”gini”，即CART算法。</li></ul></li><li>min_samples_split<ul><li>内部节点再划分所需最小样本数</li><li>这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。我之前的一个项目例子，有大概10万样本，建立决策树时，我选择了min_samples_split=10。可以作为参考。</li></ul></li><li>min_samples_leaf<ul><li>叶子节点最少样本数</li><li>这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。之前的10万样本项目使用min_samples_leaf的值为5，仅供参考。</li></ul></li><li>max_depth<ul><li>决策树最大深度</li><li>决策树的最大深度，默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间</li></ul></li><li>random_state<ul><li>随机数种子</li></ul></li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>我们可以将训练好后的模型保存到本地，进行直观的可视化。</p><p>使用的API如下：</p><p>sklearn.tree.export_graphviz() 该函数能够导出DOT格式</p><ul><li>tree.export_graphviz(estimator,out_file=’tree.dot’,feature_names=[‘’,’’])</li></ul><p>但保存的 dot 文件是一堆数据，我们可以将数据放到网站上直观显示。</p><ul><li><a href="http://webgraphviz.com/" target="_blank" rel="noopener">http://webgraphviz.com/</a> </li></ul><img src="/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/2.png" class><p>将dot文件内容复制到该网站当中显示</p><img src="/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/3.png" class><h2 id="决策树API使用"><a href="#决策树API使用" class="headerlink" title="决策树API使用"></a>决策树API使用</h2><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>这里先给出一个小的鸢尾花实例，了解决策树的基本使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_iris</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用决策树给鸢尾花数据集进行分类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决策树预估器, 决策树不用对数据进行标准化</span></span><br><span class="line">    estimator = DecisionTreeClassifier(criterion=<span class="string">"entropy"</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    y_pre = estimator.predict(x_test)</span><br><span class="line">    print(<span class="string">"预测值y_predict: "</span>, y_pre)</span><br><span class="line">    print(<span class="string">"直接对比真实值和预测值:\n"</span>, y_test == y_pre)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(<span class="string">"准确率为: "</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化决策树, 指定feature_names, 使得树的结构更加清晰</span></span><br><span class="line">    export_graphviz(estimator, out_file=<span class="string">"./iris_tree.dot"</span>, feature_names=iris.feature_names)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="案例：泰坦尼克号生存预测"><a href="#案例：泰坦尼克号生存预测" class="headerlink" title="案例：泰坦尼克号生存预测"></a>案例：泰坦尼克号生存预测</h3><img src="/2021/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-06/4.png" class><p>经过观察数据得到:</p><ul><li><strong>1 乘坐班是指乘客班（1，2，3），是社会经济阶层的代表。</strong></li><li><strong>2 其中age数据存在缺失。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier,export_graphviz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">titanic = pd.read_csv(<span class="string">"./titanic/titanic.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、筛选数据，得到特征值 和 目标值</span></span><br><span class="line">x = titanic[[<span class="string">'pclass'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>]]  <span class="comment"># 将地位等级, 年龄 和 性别 作为特征值</span></span><br><span class="line">y = titanic[<span class="string">'survived'</span>]  <span class="comment"># 将 是否活下来 作为目标值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、数据处理，缺失值处理</span></span><br><span class="line">x[<span class="string">'age'</span>].fillna(x[<span class="string">'age'</span>].mean(), inplace=<span class="literal">True</span>)  <span class="comment"># 使用 age 的平均值 填充 age列的缺失位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成字典，抽取字典格式更方便</span></span><br><span class="line">x = x.to_dict(orient=<span class="string">"records"</span>)  <span class="comment"># [&#123;'': ''&#125;,&#123;'': ''&#125;...] 最外层一个为列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、数据集划分</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典特征抽取</span></span><br><span class="line">transfer = DictVectorizer()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策树预估器</span></span><br><span class="line">estimator = DecisionTreeClassifier(criterion=<span class="string">"entropy"</span>, max_depth=<span class="number">6</span>)</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"y_predict:"</span>, y_predict)</span><br><span class="line">print(<span class="string">"直接对比真实值和预估值:"</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2:计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line">print(<span class="string">"准确率为: "</span>, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将树形结果导出</span></span><br><span class="line">export_graphviz(estimator, out_file=<span class="string">"./titanic.dot"</span>,feature_names=transfer.get_feature_names())</span><br></pre></td></tr></table></figure><h2 id="决策树总结"><a href="#决策树总结" class="headerlink" title="决策树总结"></a>决策树总结</h2><ul><li>优点：<ul><li>简单的理解和解释，树木可视化。</li></ul></li><li>缺点：<ul><li><strong>决策树学习者可以创建不能很好地推广数据的过于复杂的树，这被称为过拟合。</strong></li></ul></li><li>改进：<ul><li>减枝cart算法(决策树API当中已经实现，随机森林参数调优有相关介绍)</li><li><strong>随机森林</strong></li></ul></li></ul><p><strong>注：企业重要决策，由于决策树很好的分析能力，在决策过程应用较多， 可以选择特征</strong></p><h1 id="集成学习方法之随机森林"><a href="#集成学习方法之随机森林" class="headerlink" title="集成学习方法之随机森林"></a>集成学习方法之随机森林</h1><h2 id="什么是集成学习方法"><a href="#什么是集成学习方法" class="headerlink" title="什么是集成学习方法"></a>什么是集成学习方法</h2><p>集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是<strong>生成多个分类器/模型</strong>，各自独立地学习和作出预测。<strong>这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。</strong></p><h2 id="什么是随机森林"><a href="#什么是随机森林" class="headerlink" title="什么是随机森林"></a>什么是随机森林</h2><p>在机器学习中，<strong>随机森林是一个包含多个决策树的分类器</strong>，并且其输出的类别是由个别树输出的类别的众数而定。</p><p>例如, 如果你训练了5个树, 其中有4个树的结果是True, 1个数的结果是False, 那么最终投票结果就是True</p><h2 id="随机森林原理过程"><a href="#随机森林原理过程" class="headerlink" title="随机森林原理过程"></a>随机森林原理过程</h2><p>学习算法根据下列算法而建造每棵树：</p><ul><li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul><li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li><li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li></ul></li><li>采取bootstrap抽样 （随机有放回抽样）</li></ul><h3 id="为什么采用BootStrap抽样"><a href="#为什么采用BootStrap抽样" class="headerlink" title="为什么采用BootStrap抽样"></a>为什么采用BootStrap抽样</h3><ul><li>为什么要随机抽样训练集？　　<ul><li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li></ul></li><li>为什么要有放回地抽样？<ul><li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li></ul></li></ul><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><ul><li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</p><ul><li>随机森林分类器</li><li>n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200</li><li>criteria：string，可选（default =“gini”）分割特征的测量方法</li><li>max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</li><li>max_features=”auto”,每个决策树的最大特征数量<ul><li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li><li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li><li>If “log2”, then <code>max_features=log2(n_features)</code>.</li><li>If None, then <code>max_features=n_features</code>.</li></ul></li><li>bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</li><li>min_samples_split:节点划分最少样本数</li><li>min_samples_leaf:叶子节点的最小样本数</li></ul></li><li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>利用上面用决策树做过的泰坦尼克号案例来实现随机森林的算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">titanic = pd.read_csv(<span class="string">"./titanic/titanic.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、筛选数据，得到特征值 和 目标值</span></span><br><span class="line">x = titanic[[<span class="string">'pclass'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>]]  <span class="comment"># 将地位等级, 年龄 和 性别 作为特征值</span></span><br><span class="line">y = titanic[<span class="string">'survived'</span>]  <span class="comment"># 将 是否活下来 作为目标值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、数据处理，缺失值处理</span></span><br><span class="line">x[<span class="string">'age'</span>].fillna(x[<span class="string">'age'</span>].mean(), inplace=<span class="literal">True</span>)  <span class="comment"># 使用 age 的平均值 填充 age列的缺失位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成字典，抽取字典格式更方便</span></span><br><span class="line">x = x.to_dict(orient=<span class="string">"records"</span>)  <span class="comment"># [&#123;'': ''&#125;,&#123;'': ''&#125;...] 最外层一个为列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、数据集划分</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典特征抽取</span></span><br><span class="line">transfer = DictVectorizer()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机森林</span></span><br><span class="line">estimator = RandomForestClassifier()  <span class="comment"># 不指定参数，后面进行网格搜索</span></span><br><span class="line"></span><br><span class="line">param_dict = &#123;<span class="string">"n_estimators"</span>: [<span class="number">120</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">800</span>, <span class="number">1200</span>], <span class="string">"max_depth"</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)  <span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"y_predict:"</span>, y_predict)</span><br><span class="line">print(<span class="string">"直接对比真实值和预估值:"</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2:计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line">print(<span class="string">"准确率为: "</span>, score)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"在交叉验证中验证的最好结果：\n"</span>, estimator.best_score_)</span><br><span class="line">print(<span class="string">"最好的参数模型：\n"</span>, estimator.best_estimator_)</span><br><span class="line">print(<span class="string">"每次交叉验证后的准确率结果：\n"</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><h2 id="随机森林总结"><a href="#随机森林总结" class="headerlink" title="随机森林总结"></a>随机森林总结</h2><ul><li>在当前所有算法中，具有极好的准确率</li><li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li><li>能够评估各个特征在分类问题上的重要性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节总结分类算法中的 &lt;strong&gt;决策树&lt;/strong&gt; 和 &lt;strong&gt;随机森林&lt;/strong&gt; 算法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_05(线性回归 和 模型保存)</title>
    <link href="http://icewind-r.github.io/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/"/>
    <id>http://icewind-r.github.io/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/</id>
    <published>2021-01-20T01:31:31.000Z</published>
    <updated>2021-01-20T07:47:12.970Z</updated>
    
    <content type="html"><![CDATA[<p>线性回归的三种方法介绍，正规方程、梯度下降 和 岭回归。</p><a id="more"></a><hr><h1 id="线性回归的原理"><a href="#线性回归的原理" class="headerlink" title="线性回归的原理"></a>线性回归的原理</h1><h2 id="1、什么是线性回归"><a href="#1、什么是线性回归" class="headerlink" title="1、什么是线性回归"></a>1、什么是线性回归</h2><h3 id="定义与公式"><a href="#定义与公式" class="headerlink" title="定义与公式"></a>定义与公式</h3><p>线性回归(Linear regression)是利用<strong>回归方程(函数)</strong>对一个或<strong>多个自变量(特征值)和因变量(目标值)之间</strong>关系进行建模的一种分析方式。</p><ul><li>特点：只有一个自变量的情况称为单变量回归，大于一个自变量情况的叫做多元回归</li></ul><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/1.png" class><h3 id="线性回归的特征与目标的关系分析"><a href="#线性回归的特征与目标的关系分析" class="headerlink" title="线性回归的特征与目标的关系分析"></a>线性回归的特征与目标的关系分析</h3><p>线性回归当中的关系有两种，一种是线性关系，另一种是非线性关系。</p><p>即：如果在单特征与目标值的关系呈直线关系，或者两个特征与目标值呈现平面的关系，就是线性关系。</p><p>​        如果是曲线，则是非线性关系。</p><h2 id="2、线性回归的损失和优化原理"><a href="#2、线性回归的损失和优化原理" class="headerlink" title="2、线性回归的损失和优化原理"></a>2、线性回归的损失和优化原理</h2><p>例如这个例子，会存在误差</p><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/2.png" class><p>如何衡量出来呢？</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>总损失定义为：</p><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/3.png" class><ul><li>y_i为第i个训练样本的真实值</li><li>h(x_i)为第i个训练样本特征值组合预测函数</li><li>又称最小二乘法</li></ul><p><strong>如何去减少这个损失，使我们预测的更加准确些？既然存在了这个损失，我们一直说机器学习有自动学习的功能，在线性回归这里更是能够体现。这里可以通过一些优化方法去优化（其实是数学当中的求导功能）回归的总损失！！！</strong></p><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p><strong>如何去求模型当中的W，使得损失最小？（目的是找到最小损失对应的W值）</strong></p><p>线性回归经常使用的两种优化算法</p><ul><li><p>正规方程</p><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/4.png" class><blockquote><p>理解：X为特征值矩阵，y为目标值矩阵。直接求到最好的结果</p><p>缺点：当特征过多过复杂时，求解速度太慢并且得不到结果</p></blockquote><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/5.png" class></li><li><p><strong>梯度下降(Gradient Descent)</strong></p><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/6.png" class><blockquote><p>理解：α为学习速率，需要手动指定（超参数），α旁边的整体表示方向</p><p>沿着这个函数下降的方向找，最后就能找到山谷的最低点，然后更新W值</p><p>使用：面对训练数据规模十分庞大的任务 ，能够找到较好的结果</p></blockquote><p><strong>所以有了梯度下降这样一个优化算法，回归就有了”自动学习”的能力</strong></p></li></ul><h2 id="3、线性回归API"><a href="#3、线性回归API" class="headerlink" title="3、线性回归API"></a>3、线性回归API</h2><h3 id="（1）通过正规方程优化"><a href="#（1）通过正规方程优化" class="headerlink" title="（1）通过正规方程优化"></a>（1）通过正规方程优化</h3><ul><li><p>sklearn.linear_model.LinearRegression(fit_intercept=True)</p><ul><li>fit_intercept：是否计算偏置</li></ul><p>属性：</p><ul><li>LinearRegression.coef_：回归系数</li><li>LinearRegression.intercept_：偏置</li></ul></li></ul><h3 id="（2）梯度下降"><a href="#（2）梯度下降" class="headerlink" title="（2）梯度下降"></a>（2）梯度下降</h3><ul><li><p>sklearn.linear_model.SGDRegressor(loss=”squared_loss”, fit_intercept=True, learning_rate =’invscaling’, eta0=0.01)</p><ul><li>SGDRegressor类实现了随机梯度下降学习，它支持不同的<strong>loss函数和正则化惩罚项</strong>来拟合线性回归模型。</li><li>loss:损失类型<ul><li><strong>loss=”squared_loss”: 普通最小二乘法</strong></li></ul></li><li>fit_intercept：是否计算偏置</li><li>learning_rate : string, optional<ul><li>学习率填充</li><li><strong>‘constant’: eta = eta0</strong></li><li><strong>‘optimal’: eta = 1.0 / (alpha * (t + t0)) [default]</strong></li><li>‘invscaling’: eta = eta0 / pow(t, power_t)<ul><li><strong>power_t=0.25:存在父类当中</strong></li></ul></li><li><strong>对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。</strong></li></ul></li></ul><p>属性</p><ul><li>SGDRegressor.coef_：回归系数</li><li>SGDRegressor.intercept_：偏置</li></ul></li></ul><blockquote><p>sklearn提供给我们两种实现的API， 可以根据选择使用</p></blockquote><h2 id="4、波士顿房价案例"><a href="#4、波士顿房价案例" class="headerlink" title="4、波士顿房价案例"></a>4、波士顿房价案例</h2><p>首先我们需要知道如何评估。</p><h3 id="回归性能评估"><a href="#回归性能评估" class="headerlink" title="回归性能评估"></a>回归性能评估</h3><p>均方误差(Mean Squared Error)MSE)评价机制：</p><img src="/2021/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-05/7.png" class><blockquote><p>注：y^i为预测值，¯y为真实值</p></blockquote><ul><li>sklearn.metrics.mean_squared_error(y_true, y_pred)<ul><li>均方误差回归损失</li><li>y_true:真实值</li><li>y_pred:预测值</li><li>return:浮点数结果</li></ul></li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, SGDRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取 波士顿房价数据</span></span><br><span class="line">    boston = load_boston()</span><br><span class="line">    print(boston)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割数据</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(boston.data, boston.target, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标准化</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线性回归</span></span><br><span class="line">    <span class="comment"># 方法1：正规方程</span></span><br><span class="line">    <span class="comment"># estimator = LinearRegression()</span></span><br><span class="line">    <span class="comment"># 方法2：梯度下降法</span></span><br><span class="line">    estimator = SGDRegressor()</span><br><span class="line">    <span class="comment"># estimator = SGDRegressor(max_iter=100, learning_rate='constant', eta0=0.001)  # 最大迭代次数,学习率,eta0</span></span><br><span class="line"></span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"这个模型的偏置是："</span>, estimator.intercept_)</span><br><span class="line">    print(<span class="string">"这个模型的系数："</span>, estimator.coef_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型评估</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(<span class="string">"预测值是："</span>, y_predict)</span><br><span class="line"></span><br><span class="line">    ret = mean_squared_error(y_test, y_predict)</span><br><span class="line">    print(<span class="string">"均方误差是："</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在测试数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)</li><li>欠拟合：一个假设在训练数据上不能获得更好的拟合，并且在测试数据集上也不能很好地拟合数据，此时认为这个假设出现了欠拟合的现象。(模型过于简单)</li></ul><h2 id="原因以及解决办法"><a href="#原因以及解决办法" class="headerlink" title="原因以及解决办法"></a>原因以及解决办法</h2><ul><li>欠拟合原因以及解决办法<ul><li>原因：学习到数据的特征过少</li><li>解决办法：增加数据的特征数量</li></ul></li><li>过拟合原因以及解决办法<ul><li>原因：原始特征过多，存在一些嘈杂特征， 模型过于复杂是因为模型尝试去兼顾各个测试数据点</li><li>解决办法：<ul><li>正则化</li></ul></li></ul></li></ul><blockquote><p>在这里针对回归，我们选择了正则化。但是对于其他机器学习算法如分类算法来说也会出现这样的问题，除了一些算法本身作用之外（决策树、神经网络），我们更多的也是去自己做特征选择，包括之前说的删除、合并一些特征</p></blockquote><p>在学习的时候，数据提供的特征有些影响模型复杂度或者这个特征的数据点异常较多，所以算法在学习的时候尽量减少这个特征的影响（甚至删除某个特征的影响），这就是<strong>正则化</strong></p><blockquote><p>注：调整时候，算法并不知道某个特征影响，而是去调整参数得出优化的结果</p></blockquote><h2 id="正则化类别"><a href="#正则化类别" class="headerlink" title="正则化类别"></a>正则化类别</h2><ul><li>L2正则化<ul><li>作用：可以使得其中一些W的都很小，都接近于0，削弱某个特征的影响</li><li>优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象</li><li>Ridge 回归 （岭回归）</li></ul></li><li>L1正则化<ul><li>作用：可以使得其中一些W的值直接为0，删除这个特征的影响</li><li>LASSO回归</li></ul></li></ul><h1 id="线性回归的改进-岭回归"><a href="#线性回归的改进-岭回归" class="headerlink" title="线性回归的改进-岭回归"></a>线性回归的改进-岭回归</h1><p>岭回归，其实也是一种线性回归。只不过在算法建立回归方程时候，加上正则化的限制，从而达到解决过拟合的效果</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>1、sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver=”auto”, normalize=False)</p><ul><li>具有l2正则化的线性回归</li><li>alpha:正则化力度，也叫 λ<ul><li><strong>λ取值：0<del>1 1</del>10</strong></li></ul></li><li>solver:会根据数据自动选择优化方法<ul><li><strong>sag:如果数据集、特征都比较大，选择该随机梯度下降优化</strong></li></ul></li><li>normalize:数据是否进行标准化<ul><li>normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据</li></ul></li><li>Ridge.coef_:回归权重</li><li>Ridge.intercept_:回归偏置</li></ul><p><strong>Ridge方法相当于SGDRegressor(penalty=’l2’, loss=”squared_loss”),只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)</strong></p><p>2、sklearn.linear_model.RidgeCV(_BaseRidgeCV, RegressorMixin)</p><ul><li>具有l2正则化的线性回归，可以进行交叉验证</li><li>coef_:回归系数</li></ul><p>对之前的代码进行岭回归的优化更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge, RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_ridge_model</span><span class="params">()</span>:</span></span><br><span class="line">    boston = load_boston()</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(boston.data, boston.target, test_size=<span class="number">0.2</span>)</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 岭回归</span></span><br><span class="line">    <span class="comment"># estimator = Ridge(alpha=1.0)</span></span><br><span class="line">    estimator = RidgeCV(alphas=(<span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>))</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"这个模型的偏置是："</span>, estimator.intercept_)</span><br><span class="line">    print(<span class="string">"这个模型的系数："</span>, estimator.coef_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型评估</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(<span class="string">"预测值是："</span>, y_predict)</span><br><span class="line"></span><br><span class="line">    ret = mean_squared_error(y_test, y_predict)</span><br><span class="line">    print(<span class="string">"均方误差是："</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="模型保存和加载"><a href="#模型保存和加载" class="headerlink" title="模型保存和加载"></a>模型保存和加载</h1><p>当训练或者计算好一个模型之后，那么如果别人需要我们提供结果预测，就需要保存模型（主要是保存算法的参数）</p><h2 id="sklearn模型的保存和加载API"><a href="#sklearn模型的保存和加载API" class="headerlink" title="sklearn模型的保存和加载API"></a>sklearn模型的保存和加载API</h2><ul><li><p>from sklearn.externals import joblib</p><ul><li>保存：joblib.dump(rf, ‘test.pkl’)</li><li>加载：estimator = joblib.load(‘test.pkl’)</li></ul></li><li><p>保存</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用线性模型进行预测</span></span><br><span class="line"><span class="comment"># 使用正规方程求解</span></span><br><span class="line">lr = LinearRegression()</span><br><span class="line"><span class="comment"># 此时在干什么？</span></span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"><span class="comment"># 保存训练完结束的模型</span></span><br><span class="line">joblib.dump(lr, <span class="string">"test.pkl"</span>)</span><br></pre></td></tr></table></figure><ul><li>加载</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过已有的模型去预测房价</span></span><br><span class="line">model = joblib.load(<span class="string">"test.pkl"</span>)</span><br><span class="line">print(<span class="string">"从文件加载进来的模型预测房价的结果："</span>, std_y.inverse_transform(model.predict(x_test)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归的三种方法介绍，正规方程、梯度下降 和 岭回归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_04(分类算法knn与bayes)</title>
    <link href="http://icewind-r.github.io/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-04/"/>
    <id>http://icewind-r.github.io/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-04/</id>
    <published>2021-01-15T14:51:19.000Z</published>
    <updated>2021-01-29T03:36:38.475Z</updated>
    
    <content type="html"><![CDATA[<p>一些主要的分类算法介绍。</p><a id="more"></a><hr><h1 id="sklearn转换器和估计器"><a href="#sklearn转换器和估计器" class="headerlink" title="sklearn转换器和估计器"></a>sklearn转换器和估计器</h1><h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>我们把特征工程的接口称之为转换器，其中转换器调用有这么几种形式 </p><ul><li>fit_transform </li><li>fit —— 计算 </li><li>transform —— 进行最终的转换 </li></ul><h2 id="估计器"><a href="#估计器" class="headerlink" title="估计器"></a>估计器</h2><p>在sklearn中，估计器(estimator)是一个重要的角色，是一类实现了算法的API</p><ul><li>1、用于分类的估计器：<ul><li>sklearn.neighbors k-近邻算法</li><li>sklearn.naive_bayes 贝叶斯</li><li>sklearn.linear_model.LogisticRegression 逻辑回归</li><li>sklearn.tree 决策树与随机森林</li></ul></li><li>2、用于回归的估计器：<ul><li>sklearn.linear_model.LinearRegression 线性回归</li><li>sklearn.linear_model.Ridge 岭回归</li></ul></li><li>3、用于无监督学习的估计器<ul><li>sklearn.cluster.KMeans 聚类</li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、实例化一个estimator（转换器）</p><p>2、estimator.fit (x_train, y_train) 计算</p><p>——调用完毕，生成模型</p><p>3、模型评估：</p><p>​    （1）直接对比真实值和预估值</p><p>​                y_predict = estimator.predict(x_test)</p><p>​                y_test == y_predict</p><p>​    （2）计算准确率</p><p>​                accuracy = extimator.score(x_test, y_test)</p><img src="/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-04/1.png" class><h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</p><blockquote><p>来源：KNN算法最早是由Cover和Hart提出的一种分类算法</p></blockquote><h2 id="距离公式"><a href="#距离公式" class="headerlink" title="距离公式"></a>距离公式</h2><p>两个样本的距离可以通过如下公式计算，又叫欧式距离。</p><img src="/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-04/2.png" class><blockquote><p>还有其他的距离公式，如：曼哈顿距离，明可夫斯基距离等。</p></blockquote><h2 id="K-近邻算法API"><a href="#K-近邻算法API" class="headerlink" title="K-近邻算法API"></a>K-近邻算法API</h2><p>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)</p><ul><li>n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)</li></ul><h2 id="案例：基于鸢尾花数据集的KNN算法实现"><a href="#案例：基于鸢尾花数据集的KNN算法实现" class="headerlink" title="案例：基于鸢尾花数据集的KNN算法实现"></a>案例：基于鸢尾花数据集的KNN算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">fit：原义指的是安装、使适合的意思，其实有点train的含义但是和train不同的是，</span></span><br><span class="line"><span class="string">    它并不是一个训练的过程，而是一个适配的过程，过程都是定死的，最后只是得到了一个统一的转换的规则模型。</span></span><br><span class="line"><span class="string">transform：是将数据进行转换，比如数据的归一化和标准化，将测试数据按照训练数据同样的模型进行转换，得到特征向量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fit_transform：可以看做是fit和transform的结合，</span></span><br><span class="line"><span class="string">    如果训练阶段使用fit_transform，则在测试阶段只需要对测试样本进行transform就行了。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn_iris</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用 knn 算法对鸢尾花进行分类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1、获取数据</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、特征工程进行标准化</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train) <span class="comment"># 训练阶段用fit_transform</span></span><br><span class="line">    x_test = transfer.transform(x_test)  <span class="comment"># 测试阶段使用transform</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4、KNN算法预估器</span></span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5、模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预估值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(<span class="string">"y_predict:"</span>, y_predict)</span><br><span class="line">    print(<span class="string">"直接对比真实值和预估值:"</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2:计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(<span class="string">"准确率为: "</span>, score)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="交叉验证和网格搜索"><a href="#交叉验证和网格搜索" class="headerlink" title="交叉验证和网格搜索"></a>交叉验证和网格搜索</h1><h2 id="什么是交叉验证-cross-validation"><a href="#什么是交叉验证-cross-validation" class="headerlink" title="什么是交叉验证(cross validation)"></a>什么是交叉验证(cross validation)</h2><p>交叉验证，就是将拿到的训练数据，分为训练和验证集。</p><p>即 <strong>为了让从训练得到模型结果更加准确。</strong>做以下处理</p><ul><li>训练集：训练集+验证集</li><li>测试集：测试集</li></ul><p>以下图为例：将数据分成4份，其中一份作为验证集。然后经过4次(组)的测试，每次都更换不同的验证集。即得到4组模型的结果，取平均值作为最终结果。又称4折交叉验证。</p><img src="/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-04/3.png" class><p>交叉验证目的：<strong>为了让被评估的模型更加准确可信</strong></p><h2 id="什么是网格搜索-Grid-Search"><a href="#什么是网格搜索-Grid-Search" class="headerlink" title="什么是网格搜索(Grid Search)"></a>什么是网格搜索(Grid Search)</h2><p>通常情况下，<strong>有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数</strong>。但是手动过程繁杂，所以需要对模型预设几种超参数组合。<strong>每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。</strong></p><p>超参数是在机器开始学习之前设置，不是通过训练得到的。</p><h2 id="交叉验证，网格搜索（模型选择与调优）API"><a href="#交叉验证，网格搜索（模型选择与调优）API" class="headerlink" title="交叉验证，网格搜索（模型选择与调优）API"></a>交叉验证，网格搜索（模型选择与调优）API</h2><p>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)</p><ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析：<ul><li>bestscore__:在交叉验证中验证的最好结果</li><li>bestestimator：最好的参数模型</li><li>cvresults:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul><p>参考链接：<a href="https://blog.csdn.net/hohaizx/article/details/81013985" target="_blank" rel="noopener">https://blog.csdn.net/hohaizx/article/details/81013985</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">fit：原义指的是安装、使适合的意思，其实有点train的含义但是和train不同的是，</span></span><br><span class="line"><span class="string">    它并不是一个训练的过程，而是一个适配的过程，过程都是定死的，最后只是得到了一个统一的转换的规则模型。</span></span><br><span class="line"><span class="string">transform：是将数据进行转换，比如数据的归一化和标准化，将测试数据按照训练数据同样的模型进行转换，得到特征向量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fit_transform：可以看做是fit和transform的结合，</span></span><br><span class="line"><span class="string">    如果训练阶段使用fit_transform，则在测试阶段只需要对测试样本进行transform就行了。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn_iris</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1、获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="comment"># 2、数据基本处理 -- 划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="comment"># 3、特征工程：标准化</span></span><br><span class="line">    <span class="comment"># 实例化一个转换器类</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    <span class="comment"># 调用fit_transform</span></span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line">    <span class="comment"># 4、KNN预估器流程</span></span><br><span class="line">    <span class="comment">#  4.1 实例化预估器类</span></span><br><span class="line">    estimator = KNeighborsClassifier()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.2 模型选择与调优——网格搜索和交叉验证</span></span><br><span class="line">    <span class="comment"># 准备要调的超参数</span></span><br><span class="line">    param_dict = &#123;<span class="string">"n_neighbors"</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]&#125;</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 4.3 fit数据进行训练</span></span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line">    <span class="comment"># 5、评估模型效果</span></span><br><span class="line">    <span class="comment"># 方法a：比对预测结果和真实值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(<span class="string">"比对预测结果和真实值：\n"</span>, y_predict == y_test)</span><br><span class="line">    <span class="comment"># 方法b：直接计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(<span class="string">"直接计算准确率：\n"</span>, score)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"在交叉验证中验证的最好结果：\n"</span>, estimator.best_score_)</span><br><span class="line">    print(<span class="string">"最好的参数模型：\n"</span>, estimator.best_estimator_)</span><br><span class="line">    print(<span class="string">"每次交叉验证后的准确率结果：\n"</span>, estimator.cv_results_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    knn_iris()</span><br><span class="line">    <span class="comment"># plot_iris()</span></span><br></pre></td></tr></table></figure><h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><p>先初步给出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nb_news</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用 朴素贝叶斯 方法对新闻进行分类</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    news = fetch_20newsgroups(subset=<span class="string">'all'</span>)</span><br><span class="line">    </span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target)</span><br><span class="line">    </span><br><span class="line">    transfer = TfidfVectorizer()</span><br><span class="line">    </span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line">    </span><br><span class="line">    estimator = MultinomialNB()</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(y_predict)</span><br><span class="line">    print(y_predict == y_test)</span><br><span class="line"></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nb_news()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些主要的分类算法介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_03(特征预处理、特征降维、主成分分析)</title>
    <link href="http://icewind-r.github.io/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/"/>
    <id>http://icewind-r.github.io/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/</id>
    <published>2021-01-07T00:45:38.000Z</published>
    <updated>2021-01-17T08:07:41.644Z</updated>
    
    <content type="html"><![CDATA[<p>继续上节的特征工程，本篇讲解特征工程下的特征预处理</p><a id="more"></a><hr><h1 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h1><p>目标：</p><ul><li>了解数值型数据、类别型数据特点</li><li>应用MinMaxScaler实现对特征数据进行归一化</li><li>应用StandardScaler实现对特征数据进行标准化</li></ul><p>什么是特征处理</p><img src="/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/1.png" class><h2 id="什么是特征预处理？"><a href="#什么是特征预处理？" class="headerlink" title="什么是特征预处理？"></a>什么是特征预处理？</h2><p>sklearn官方给出的解释：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据的过程</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>数据无量纲化是机器学习中数据预处理的一个流程。</p><p>在机器学习算法实践中，我们往往有着将不同规格的数据转换到同一规格，或不同分布的数据转换到某个特定分布的需求，这种需求统称为将数据“无量纲化”。</p><p>数据的无量纲化可以是线性的，也可以是非线性的。线性的无量纲化包括中心化（Zero-centered 或者 Mean-subtraction）处理和缩放处理（Scale）。中心化的本质是让所有记录减去一个固定值，即让数据样本数据平移到某个位置（<strong>数据归一化</strong>）。缩放的本质是通过除以一个固定值，将数据固定在某个范围内之中，取对数也算是一种缩放处理（<strong>数据标准化</strong>）。</p><p>数值型数据的无量纲化：</p><ul><li>归一化</li><li>标准化</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing</span><br></pre></td></tr></table></figure><h3 id="为什么我们要进行归一化和标准化？"><a href="#为什么我们要进行归一化和标准化？" class="headerlink" title="为什么我们要进行归一化和标准化？"></a>为什么我们要进行归一化和标准化？</h3><p>特征的单位可能大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响目标结果。</p><p>我们需要用到一些方法进行无量纲化，使不同规格的数据转换到同一规格。</p><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>通过将原始数据进行变换，映射到一个区间之内（默认为 [0 , 1] ）</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><img src="/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/2.png" class><blockquote><p> 作用于每一列, max为一列的最大值, min为一列的最小值,那么X”为最终结果，mx,mi分别为指定区间值默认mx为1,mi为0</p></blockquote><p>通过下面这个例子更好理解：</p><img src="/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/3.png" class><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><p>sklearn.preprocessing.MinMaxScaler(feature_range=(0,1)…)</p><ul><li>MinMaxScaler.fit_transform(X)<ul><li>X ：numpy array 格式的数据 [n_samples , n_features]</li></ul></li><li>返回值：转换后的形状相同的array</li></ul><p><strong>案例</strong>：</p><p>在代码的当前目录放入测试数据dating.txt</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">milage,Liters,Consumtime,target</span><br><span class="line">12,343,45,667</span><br><span class="line">123,123,45,667</span><br><span class="line">82,323,15,37</span><br><span class="line">12,343,425,647</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minmax_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归一化</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    data = pd.read_csv(<span class="string">"dating.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个转换器类</span></span><br><span class="line">    transfer = MinMaxScaler()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用fit_transform转换</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="comment"># 若选取其中几列</span></span><br><span class="line">    <span class="comment"># data_new = transfer.fit_transform(data[['milage','Liters','Consumtime']]) </span></span><br><span class="line">    print(data_new)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[0.         1.         0.07317073 1.        ]</span><br><span class="line"> [1.         0.         0.07317073 1.        ]</span><br><span class="line"> [0.63063063 0.90909091 0.         0.        ]</span><br><span class="line"> [0.         1.         1.         0.96825397]]</span><br></pre></td></tr></table></figure><p>完成了归一化，默认为 0 ~ 1，可通过</p><p><strong>问题</strong>：我们利用归一化求值离不开最大最小值，如果存在异常，会影响整体结果，不适合多数情况。为此我们学习标准化。</p><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过对原始数据进行变换把数据变换到均值为0，标准差为1的范围内。</p><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><img src="/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/4.png" class><blockquote><p>作用于每一列，mean为平均值，std为标准差</p></blockquote><p>对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变<br>对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。</p><h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><p>sklearn.preprocessing.StandardScaler()</p><ul><li><p>处理之后，对每列来说，所有数据都聚集在均值为 0 ，标准差为 1 附近</p></li><li><p>StandardScaler.fit_transform(X)</p><ul><li>X ：numpy array 格式的数据 [n_samples , n_features]</li></ul></li><li><p>返回值：转换后的形状相同的array</p></li></ul><p>实例：用上题数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standard_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    标准化</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    data = pd.read_csv(<span class="string">"dating.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个转换器类</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用fit_transform转换</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    print(data_new)</span><br><span class="line">    print(<span class="string">"每一列特征的平均值:\n"</span>, transfer.mean_)</span><br><span class="line">    print(<span class="string">"每一列特征的方差:\n"</span>, transfer.var_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[-0.95232825  0.64699664 -0.51677759  0.60177447]</span><br><span class="line"> [ 1.38376978 -1.72532437 -0.51677759  0.60177447]</span><br><span class="line"> [ 0.52088672  0.43133109 -0.69395848 -1.73125885]</span><br><span class="line"> [-0.95232825  0.64699664  1.72751367  0.52770992]]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景</p><h1 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h1><p>目标：</p><ul><li>应用VarianceThreshold实现删除低方差特征</li><li>了解相关系数的特点和计算</li><li>应用相关系数实现特征选择</li></ul><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>降维是指在某些限定条件下 ，降低 <strong>随机变量（特征）</strong>的个数 ，得到一组 <strong>“不相关”主变量</strong>  的过程。</p><ul><li>降低随机变量的个数<ul><li>比如说二维数据转为一维数据</li></ul></li><li>相关特征<ul><li>相对湿度 和 降雨量 是相关的</li></ul></li></ul><blockquote><p>正是因为在进行训练的时候，我们都是使用特征进行学习。如果特征本身存在问题或者特征之间相关性较强，对于算法学习预测会影响会较大。</p></blockquote><h2 id="降维的两种方式"><a href="#降维的两种方式" class="headerlink" title="降维的两种方式"></a>降维的两种方式</h2><ul><li>特征选择</li><li>主成分分析（可以理解成一种特征提取的方式）</li></ul><p>下面依次介绍。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>数据中包含冗余或相关变量（或称特征、属性、指标等），旨在从原有特征中找出<strong>主要特征</strong>。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>Filter（过滤式）：主要探究特征本身特点、特征与特征和目标值之间关联<ul><li>方差选择法：低方差特征过滤</li><li>相关系数：特征与特征之间的相关程度</li></ul></li><li>Embedded（嵌入式）：算法自动选择特征（特征与目标值之间的关联）<ul><li>决策树：信息熵、信息增益</li><li>正则化：L1，L2</li><li>深度学习：卷积等</li></ul></li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.feature_selection</span><br></pre></td></tr></table></figure><h2 id="过滤式"><a href="#过滤式" class="headerlink" title="过滤式"></a>过滤式</h2><h3 id="1、低方差特征过滤"><a href="#1、低方差特征过滤" class="headerlink" title="1、低方差特征过滤"></a>1、低方差特征过滤</h3><p>这是通过特征本身的方差来筛选特征的类。比如一个特征本身的方差很小，就表示样本在这个特征上基本没有差异，可能特征中的大多数值都一样，甚至整个特征的取值都相同，那这个特征对于样本区分没有什么作用。<strong>所以无论接下来的特征工程要做什么，都要优先消除方差为0的特征</strong>。VarianceThreshold有重要参数threshold，表示方差的阈值，表示舍弃所有方差小于threshold的特征，不填默认为0，即删除所有的记录都相同的特征。</p><p>注意：删除的是特征，即列索引。</p><h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><p>sklearn.feature_selection.VarianceThreshold(threshold = 0.0)</p><ul><li>删除所有低方差特征</li><li>Variance.fit_transform(X)<ul><li>X:numpy array格式的数据[n_samples,n_features]</li><li>返回值：训练集差异低于threshold的特征将被删除。默认值是保留所有非零方差特征，即删除所有样本中具有相同值的特征。</li></ul></li></ul><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>1、初始化VarianceThreshold,指定阈值方差</p><p>2、调用fit_transform</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variance_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    过滤低方差特征</span></span><br><span class="line"><span class="string">    步骤</span></span><br><span class="line"><span class="string">    1、获取数据</span></span><br><span class="line"><span class="string">    2、实例化一个转换器类</span></span><br><span class="line"><span class="string">    3、调用fit_transform</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = pd.read_csv(<span class="string">"datingTestSet2.csv"</span>)</span><br><span class="line">    <span class="comment"># 对数据列进行筛选，然后进行低方差过滤</span></span><br><span class="line">    data = data.iloc[:, <span class="number">1</span>:<span class="number">-2</span>]  <span class="comment"># 第一个 : 取所有行 , 第二个 1:-2 取第1列 到 第倒数第二列</span></span><br><span class="line">    print(data.shape)</span><br><span class="line">    </span><br><span class="line">    transfer = VarianceThreshold(threshold=<span class="number">10</span>) <span class="comment"># 指定方差大小, 不指定默认为0</span></span><br><span class="line"></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    print(data_new.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2、相关系数"><a href="#2、相关系数" class="headerlink" title="2、相关系数"></a>2、相关系数</h3><p>有很多相关系数，这里选择的是　皮尔逊相关系数(Pearson Correlation Coefficient)</p><ul><li>反映变量之间相关关系密切程度的统计指标</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>相关系数的值介于–1与+1之间，即–1≤ r ≤+1</strong>。其性质如下：</p><ul><li><strong>当r&gt;0时，表示两变量正相关，r&lt;0时，两变量为负相关</strong></li><li>当|r|=1时，表示两变量为完全相关，当r=0时，表示两变量间无相关关系</li><li><strong>当0&lt;|r|&lt;1时，表示两变量存在一定程度的相关。且|r|越接近1，两变量间线性关系越密切；|r|越接近于0，表示两变量的线性相关越弱</strong></li><li><strong>一般可按三级划分：|r|&lt;0.4为低度相关；0.4≤|r|&lt;0.7为显著性相关；0.7≤|r|&lt;1为高度线性相关</strong></li></ul><h4 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h4><ul><li>from scipy.stats import pearsonr(x, y)<ul><li>计算x, y 的相关系数，返回一个二元元组，第一个元素是相关性</li></ul></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>利用上面得到数据计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关系数计算</span></span><br><span class="line">r = pearsonr(data[<span class="string">'revenue'</span>], data[<span class="string">'total_expense'</span>])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>可得这两个指标相关性很高，可以做后续处理，比如合成这两个指标。</p><h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p><strong>高维数据转化为低维数据的过程</strong>，在此过程中<strong>可能会舍弃原有数据、创造新的变量</strong></p><p>作用：<strong>是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。</strong></p><p>应用：回归分析或者聚类分析当中</p><blockquote><p>对于信息一词，在决策树中会进行介绍</p></blockquote><p>那么更好的理解这个过程呢？我们来看一张图，如何用二维的照片最多的展示一个三维物体。</p><img src="/2021/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-03/5.png" class><h2 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h2><ul><li>sklearn.decomposition.PCA(n_components=None)<ul><li>将数据分解为较低维数空间</li><li>n_components对不同的传入参数有不同的功能：<ul><li><strong>小数：表示保留百分之多少的信息</strong></li><li><strong>整数：减少到多少特征</strong></li></ul></li><li>PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]</li><li>返回值：转换后指定维度的array</li></ul></li></ul><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca_demo</span><span class="params">()</span>:</span></span><br><span class="line">    data = [[<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>],[<span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>]]</span><br><span class="line">    <span class="comment"># transfer = PCA(n_components=2)  # 表示由 4个特征降维到 2个特征</span></span><br><span class="line">    transfer = PCA(n_components=<span class="number">0.9</span>)  <span class="comment"># 表示保留 90% 的信息</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    print(data_new)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续上节的特征工程，本篇讲解特征工程下的特征预处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Anaconda的入门使用</title>
    <link href="http://icewind-r.github.io/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://icewind-r.github.io/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-25T07:58:23.000Z</published>
    <updated>2020-12-25T11:57:48.891Z</updated>
    
    <content type="html"><![CDATA[<p>z这东西还是得会，作此总结。</p><a id="more"></a><hr><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>首先Anaconda这款软件是在国外的，不论是软件的下载速度，还是使用软件下载包的速度都是很慢的，我们需要配置中国的镜像源进行加速。</p><h1 id="一、Anaconda的安装"><a href="#一、Anaconda的安装" class="headerlink" title="一、Anaconda的安装"></a>一、Anaconda的安装</h1><p>我们使用的是清华镜像源下载Anaconda的安装包，网址：</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>选择 anaconda ，进入到 archive 目录下 ，然后选择64位的安装包进行下载（我选的是最新的安装包，测试没有问题）。</p><img src="/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/1.png" class><blockquote><p> 可能偶尔某个镜像无法下载anaconda，所以下面其他中国的镜像站点：</p><ol><li>中科大镜像：<a href="https://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/</a></li><li></li></ol></blockquote><p>下载完安装包后启动安装即可。</p><h1 id="二、Anaconda的入门使用"><a href="#二、Anaconda的入门使用" class="headerlink" title="二、Anaconda的入门使用"></a>二、Anaconda的入门使用</h1><p>安装成功后得到的文件目录。</p><img src="/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/2.png" class><p>入门阶段我们先学习使用anaconda navigator。</p><h2 id="1、虚拟环境的创建"><a href="#1、虚拟环境的创建" class="headerlink" title="1、虚拟环境的创建"></a>1、虚拟环境的创建</h2><p>主要是这个Environment界面，我们可以在anaconda里安装自己的python虚拟环境。</p><p>默认是root（或 base），我们可以 create 自己的。</p><img src="/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/3.png" class><h2 id="2、安装需要的依赖包"><a href="#2、安装需要的依赖包" class="headerlink" title="2、安装需要的依赖包"></a>2、安装需要的依赖包</h2><p>我们使用python安装依赖包在该 navigator 中也十分方便。如下：</p><img src="/2020/12/25/Anaconda%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/4.png" class><p>anaconda的一大优点就是下载目标包时，各种与该包依赖的包都会被自动监测与下载，这对小白实在是太友好了！</p><h2 id="3、进入该环境的命令行界面"><a href="#3、进入该环境的命令行界面" class="headerlink" title="3、进入该环境的命令行界面"></a>3、进入该环境的命令行界面</h2><p>只需要点击每个环境名称旁边的小三角箭头即可进入 Open Terminal。</p><p>进入后若想进入python交互环境，需要使用命令 <code>python</code>，而不是<code>py</code>，后者不可用。</p><p>这就是基本的操作了，相信对于入门的小白一定是非常友好的。</p><h1 id="附（Anaconda命令简介）"><a href="#附（Anaconda命令简介）" class="headerlink" title="附（Anaconda命令简介）"></a>附（Anaconda命令简介）</h1><p>首先说一点：Windows下 Anaconda Prompt 这个东西就是用来管理Anaconda的，使用的是conda这样的一种命令。</p><p>在Linux中，可以直接在终端中输入conda 命令</p><p>可以使用conda命令创建新的python环境（python版本，包），新的环境与原来的环境不相关。这样，方便不同的应用中使用不同的python版本。<br>创建新环境的步骤如下：</p><p>1、首先在所在系统中安装Anaconda。可以打开命令行输入<code>conda -V</code> 检验是否安装以及当前conda的版本。</p><p>2、conda常用的命令。</p><p>  1） <code>conda list</code> 查看安装了哪些包。</p><p>  2） <code>conda env list</code> 或  <code>conda info -e</code> 查看当前存在哪些虚拟环境</p><p>  3） <code>conda update conda</code> 检查更新当前conda</p><p>  4） <code>conda --version</code> 查询conda版本</p><p>  5） <code>conda -h</code> 查询conda的命令使用</p><p>3、创建python虚拟环境。</p><p>   使用  <code>conda create -n your_env_name python=X.X （2.7、3.6等)</code>命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。</p><p>   注意：默认的情况下只安装了一些必须的包，并不会像我们安装anaconda时自动安装很多常用的包。要实现上面的功能，则须在末尾加上‘anaconda’，完整命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n your_env_name python&#x3D;X.X anaconda</span><br></pre></td></tr></table></figure><p>4、使用激活(或切换不同python版本)的虚拟环境。</p><p>  打开命令行输入<code>python --version</code>可以检查当前python的版本。</p><p>  使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。</p><p>  Linux:  <code>source activate your_env_name (虚拟环境名称)</code></p><p>  Windows:  <code>activate your_env_name (虚拟环境名称)</code></p><p>  这是再使用 <code>python --version</code> 可以检查当前python版本是否为想要的。</p><p>5、对虚拟环境中安装额外的包。</p><p>  使用命令 <code>conda install -n your_env_name [package]</code>即可安装package到your_env_name中</p><p>6、关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。</p><p>  使用如下命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux: source deactivate</span><br><span class="line"></span><br><span class="line">Windows: deactivate</span><br></pre></td></tr></table></figure><p>7、删除虚拟环境。</p><p>  使用命令 <code>conda remove -n your_env_name(虚拟环境名称) --all</code>， 即可删除。</p><p>8、删除环境中的某个包。</p><p>  使用命令 <code>conda remove --name your_env_name package_name</code>即可。</p><h2 id="Anaconda问题解决"><a href="#Anaconda问题解决" class="headerlink" title="Anaconda问题解决"></a>Anaconda问题解决</h2><p>1、<strong>LOCKERROR: It looks like conda is already doing something</strong> 。。。 重启也不好使、、醉了</p><p>使用命令：<code>conda clean --lock</code>解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;z这东西还是得会，作此总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://iceWind-R.github.io/categories/Python/"/>
    
    
      <category term="Anaconda" scheme="http://iceWind-R.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>机器学习_02(特征工程)</title>
    <link href="http://icewind-r.github.io/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/"/>
    <id>http://icewind-r.github.io/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/</id>
    <published>2020-12-19T03:16:46.000Z</published>
    <updated>2021-01-17T01:45:36.954Z</updated>
    
    <content type="html"><![CDATA[<p>特征工程学习，本篇主要介绍特征工程的<strong>数据集</strong>和<strong>特征抽取</strong></p><a id="more"></a><hr><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p>目标</p><ul><li>知道数据集分为训练集和测试集</li><li>会使用sklearn的数据集</li></ul><h2 id="可用数据集"><a href="#可用数据集" class="headerlink" title="可用数据集"></a>可用数据集</h2><p>可用数据集很多，网上一查便可搜索到。学习阶段，可能用到的数据集：</p><ul><li>sklearn</li><li>kaggle</li><li>UCI</li></ul><h2 id="sklearn工具介绍"><a href="#sklearn工具介绍" class="headerlink" title="sklearn工具介绍"></a>sklearn工具介绍</h2><ul><li><p>Python语言的机器学习工具</p></li><li><p>Scikit-learn包括许多知名的机器学习算法的实现</p></li><li><p>Scikit-learn文档完善，容易上手，丰富的API</p></li></ul><p>官网地址：<a href="https://scikit-learn.org/stable/" target="_blank" rel="noopener">https://scikit-learn.org/stable/</a></p><h3 id="安装sklearn"><a href="#安装sklearn" class="headerlink" title="安装sklearn"></a>安装sklearn</h3><p>anaconda里面安装十分容易，搜索scikits-learn，下载该包即可。</p><h2 id="sklearn数据集"><a href="#sklearn数据集" class="headerlink" title="sklearn数据集"></a>sklearn数据集</h2><h3 id="1、scikits-learn数据集API介绍"><a href="#1、scikits-learn数据集API介绍" class="headerlink" title="1、scikits-learn数据集API介绍"></a>1、scikits-learn数据集API介绍</h3><p>sklearn.datasets</p><ul><li><p>加载获取流行数据集</p></li><li><p>datasets.load_*()</p><ul><li>获取小规模数据集，数据包含在datasets里</li></ul></li><li><p>datasets.fetch_*(data_home=None)</p><ul><li>获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录，默认是~/scikit_learn_datal</li></ul></li></ul><h3 id="2、sklearn小数据集"><a href="#2、sklearn小数据集" class="headerlink" title="2、sklearn小数据集"></a>2、sklearn小数据集</h3><ul><li><p>sklearn.datasets.load_iris()</p><p>加载并返回鸢尾花数据集</p></li><li><p>sklearn.datasets.load_boston()</p><p>加载并返回波士顿房价数据集</p></li></ul><h3 id="3、sklearn大数据集"><a href="#3、sklearn大数据集" class="headerlink" title="3、sklearn大数据集"></a>3、sklearn大数据集</h3><ul><li>sklearn.datasets.fetch_20newsgroups(data_home=None,subset=’train’)<ul><li>subset：可选参数 ‘train’，’test’，’all’，训练集的“训练”，测试集的“测试”，两者的全部 </li></ul></li></ul><h3 id="4、sklearn数据集的使用"><a href="#4、sklearn数据集的使用" class="headerlink" title="4、sklearn数据集的使用"></a>4、sklearn数据集的使用</h3><p>以鸢尾花数据集为例。</p><ul><li>特征值-4个：花瓣、花萼的长度、宽度</li><li>目标值-3个：setosa，vericolor，virginica</li></ul><p><strong>sklearn数据集返回值介绍</strong></p><p>load和fetch返回的数据类型datasets.base.Bunch(字典格式，继承自字典)</p><blockquote><p>两种取值方式，value = dict[“key”]  或  value = dict.key</p></blockquote><ul><li>data:特征数据数组，是[n_samples * n_features]的二维 numpy.ndarray 数组</li><li>target:标签数组，是n_samples的一维numpy.ndarray 数组</li><li>DESCR:数据描述</li><li>feature_names:特征名。新闻数据、手写数字、回归数据集没有</li><li>target_names:标签名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datasets_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    sklearn 数据集的使用</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="comment"># print("鸢尾花数据集：\n", iris)</span></span><br><span class="line">    print(<span class="string">"查看数据集描述\n"</span>, iris.DESCR)</span><br><span class="line">    print(<span class="string">"查看特征值名字：\n"</span>, iris.feature_names)</span><br><span class="line">    print(<span class="string">"查看特征值：\n"</span>, iris.data, iris.data.shape)</span><br><span class="line">    print(<span class="string">"查看标签数组：\n"</span>, iris.target)</span><br><span class="line">    print(<span class="string">"查看标签名：\n"</span>, iris.target_names)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    datasets_demo()</span><br></pre></td></tr></table></figure><p><strong>思考</strong>：拿到的数据是否全部用来训练一个模型？</p><h2 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h2><p>机器学习一般的数据集会划分为两个部分：</p><ul><li><p>训练数据：用于训练，构建<strong>模型</strong></p></li><li><p>测试数据：在模型检验时使用，用于<strong>评估模型是否有效</strong></p></li></ul><p>划分比例：</p><ul><li><p>训练集：70% 75% 80%</p></li><li><p>测试集：30% 25% 20%</p></li></ul><h3 id="数据集划分API"><a href="#数据集划分API" class="headerlink" title="数据集划分API"></a>数据集划分API</h3><p>sklearn.model_selection.train_test_split(array, *options)</p><p>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=1)</p><ul><li>x数据集的特征值</li><li>y数据集的标签值</li><li>test_size 测试集的大小，一般为float</li><li>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。</li><li>return结果：训练集特征值（x_train），测试集特征值（x_test），训练集目标值（y_train），测试集目标值（y_test）</li></ul><p>x_train,y_train 是原始数据集划分出来作为训练模型的，fit模型的时候用。</p><p>x_test,y_test 这部分的数据不参与模型的训练，而是用于评价训练出来的模型好坏，score评分的时候用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="comment"># 数据集的划分 前两个参数为目标值和特征值</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="number">0.2</span>, random_state=<span class="number">22</span>)</span><br><span class="line">print(<span class="string">"训练集的特征值：\n"</span>, x_train, x_train.shape)</span><br></pre></td></tr></table></figure><h1 id="特征工程介绍"><a href="#特征工程介绍" class="headerlink" title="特征工程介绍"></a>特征工程介绍</h1><p>特征工程是使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。</p><blockquote><p>业界广泛流产：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p></blockquote><h2 id="特征工程的位置和数据处理的比较"><a href="#特征工程的位置和数据处理的比较" class="headerlink" title="特征工程的位置和数据处理的比较"></a>特征工程的位置和数据处理的比较</h2><ul><li>pandas：用于数据处理和数据清洗</li><li>sklearn：用于特征工程</li></ul><p>特征工程包括三部分</p><ul><li>特征抽取</li><li>特征预处理</li><li>特征降维</li></ul><h1 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h1><p>目标：</p><ul><li>应用DictVectorizer实现对类别特征进行数值化、离散化</li><li>应用CountVectorizer实现对文本特征进行数值化</li><li>应用TfidVectorizer实现对文本特征进行数值化</li><li>说出两种文本特征提取的方式区别</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1、将任意数据（文本或图像）转换为可用于机器学习的数字特征"><a href="#1、将任意数据（文本或图像）转换为可用于机器学习的数字特征" class="headerlink" title="1、将任意数据（文本或图像）转换为可用于机器学习的数字特征"></a>1、将任意数据（文本或图像）转换为可用于机器学习的数字特征</h3><blockquote><p>注意：特征值化 是为了计算机更好的去理解数据</p></blockquote><ul><li>字典特征提取（特征离散化）</li><li>文本特征提取</li><li>图像特征提取（深度学习将介绍）</li></ul><h3 id="2、特征提取API"><a href="#2、特征提取API" class="headerlink" title="2、特征提取API"></a>2、特征提取API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.feature_extraction</span><br></pre></td></tr></table></figure><h2 id="字典特征提取"><a href="#字典特征提取" class="headerlink" title="字典特征提取"></a>字典特征提取</h2><p>作用：对字典数据进行特征值化</p><p>应用场景：</p><ul><li>数据集当中类别特征比较多<ul><li>将数据集的特征  – &gt; 字典类型</li><li>DictVectorizer转换</li></ul></li><li>本身拿到的数据就是字典类型</li></ul><p><strong>API</strong></p><p>sklearn.feature_extraction.DictVectorizer(sparse=True,…)  sparse ： 是否采用稀疏矩阵</p><ul><li><p>DictVectorizer.fit_transform(X)     X：字典或者包含字典的迭代器。返回值：返回sparse矩阵</p></li><li><p>DictVectorizer.inverse_transform(X)    X：array数组或sparse（稀疏）矩阵。返回值：转换之间的数据格式</p></li><li><p>DictVectorizer.get_feature_names()  返回类别名称</p></li></ul><blockquote><p>字典特征提取 –&gt; 类别 –&gt; one-hot编码，当类别非常多时，矩阵会有非常多的 0，使用稀疏矩阵可以减少内存开销。</p></blockquote><p><strong>案例</strong>：</p><p>我们对以下数据进行特征提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">'city'</span>:<span class="string">'北京'</span>, <span class="string">'temperature'</span>: <span class="number">10</span>&#125;, </span><br><span class="line"> &#123;<span class="string">'city'</span>:<span class="string">'上海'</span>, <span class="string">'temperature'</span>: <span class="number">20</span>&#125;, </span><br><span class="line"> &#123;<span class="string">'city'</span>:<span class="string">'深圳'</span>, <span class="string">'temperature'</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure><p>代码实现：</p><ul><li>实例化DictVectorizer</li><li>调用fit_transform输入数据并转换（注意返回格式）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    字典特征抽取</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = [&#123;<span class="string">'city'</span>:<span class="string">'北京'</span>, <span class="string">'temperature'</span>: <span class="number">10</span>&#125;, &#123;<span class="string">'city'</span>:<span class="string">'上海'</span>, <span class="string">'temperature'</span>: <span class="number">20</span>&#125;, &#123;<span class="string">'city'</span>:<span class="string">'深圳'</span>, <span class="string">'temperature'</span>: <span class="number">30</span>&#125;]</span><br><span class="line">    <span class="comment"># 1. 实例化一个转换器类</span></span><br><span class="line">    transfer = DictVectorizer(sparse=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 调用fit_transform()</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    print(data_new)</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p>稀疏矩阵：</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/1.png" class><p>非稀疏矩阵：</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/2.png" class><p><strong>总结</strong></p><p>对于特征当中存在类别信息的我们都会做one-hot编码处理</p><h2 id="文本特征提取"><a href="#文本特征提取" class="headerlink" title="文本特征提取"></a>文本特征提取</h2><p>作用：对文本数据进行特征值化</p><p>对于一段文字，我们一般用<strong>单词</strong>作为特征，进行提取。</p><ul><li>sklearn.feature_extraction.text.CountVectorizer(stop_words=[])  <ul><li>返回词频矩阵</li><li>stop_words：停用词，使用后便不显示</li></ul></li><li>CountVectorizer.inverse_transform(X)   X：array数组或者sparse矩阵    返回值：转换之前的数据格式</li><li>CountVectorizer.get_feature_names()    返回值：单词列表</li><li>sklearn.feature_extraction.text.TfidfVectorizer</li></ul><h3 id="英文分词实例"><a href="#英文分词实例" class="headerlink" title="英文分词实例"></a>英文分词实例</h3><p>对以下数据进行特征提取</p><p>data = [“Life is short, I like python.”, “Life is too long, I don’t like python python.”]</p><p><strong>流程分析</strong></p><ul><li>实例化类CountVectorizer类</li><li>调用fit_transform方法输出数据并转换（注意返回格式，利用 toarray() 进行 sparse 矩阵转换为 array 数组）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文本特征抽取</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = [<span class="string">"Life is short, I like python."</span>, <span class="string">"Life is too long, I don't like python python."</span>]</span><br><span class="line">    <span class="comment"># 1. 实例化一个转换器类</span></span><br><span class="line">    transfer = CountVectorizer() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 调用fit_transform</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    print(<span class="string">"data_new:\n"</span>, data_new)</span><br><span class="line">    print(<span class="string">"data_new(数组形式):\n"</span>, data_new.toarray())</span><br><span class="line">    print(<span class="string">"特征名字:\n"</span>, transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data_new:</span><br><span class="line">  (0, 2)1</span><br><span class="line">  (0, 1)1</span><br><span class="line">  (0, 6)1</span><br><span class="line">  (0, 3)1</span><br><span class="line">  (0, 5)1</span><br><span class="line">  (1, 2)1</span><br><span class="line">  (1, 1)1</span><br><span class="line">  (1, 3)1</span><br><span class="line">  (1, 5)2</span><br><span class="line">  (1, 7)1</span><br><span class="line">  (1, 4)1</span><br><span class="line">  (1, 0)1</span><br><span class="line">data_new(数组形式):</span><br><span class="line"> [[0 1 1 1 0 1 1 0]</span><br><span class="line"> [1 1 1 1 1 2 0 1]]</span><br><span class="line">特征名字:</span><br><span class="line"> ['don', 'is', 'life', 'like', 'long', 'python', 'short', 'too']</span><br></pre></td></tr></table></figure><p><strong>拓展</strong>：</p><p>若对中文进行特征提取，需要分词，可用结巴分词等等…</p><h3 id="中文分词实例"><a href="#中文分词实例" class="headerlink" title="中文分词实例"></a>中文分词实例</h3><p>需要使用pip命令下载jieba包，在anaconda的navigator中搜索不到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure><p>实现：</p><ul><li>利用jieba包 ，定义分词方法cut_word()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_word</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    进行中文分词：“我爱北京天安门” 转换为 “我 爱 北京 天安门”</span></span><br><span class="line"><span class="string">    :param text:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a = jieba.cut(text)  <span class="comment"># 返回一个生成器对象</span></span><br><span class="line">    <span class="comment"># print(a)  # &lt;generator object Tokenizer.cut at 0x0000028FFE894C80&gt;</span></span><br><span class="line">    b = list(a)  <span class="comment"># 强转为列表类型</span></span><br><span class="line">    <span class="comment"># print(b)  # ['我', '爱', '北京', '天安门']</span></span><br><span class="line">    c = <span class="string">" "</span>.join(b)  <span class="comment"># 继续转换</span></span><br><span class="line">    <span class="comment"># print(c)  # 我 爱 北京 天安门</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_chinese</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    中文文本特征抽取，自动分词</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1. 将中文文本进行分词</span></span><br><span class="line">    data = [<span class="string">"在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。"</span>,</span><br><span class="line">            <span class="string">"过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。"</span>,</span><br><span class="line">            <span class="string">"如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。"</span>,</span><br><span class="line">            <span class="string">"那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。"</span>]</span><br><span class="line"></span><br><span class="line">    data_new = []</span><br><span class="line">    <span class="keyword">for</span> sentence <span class="keyword">in</span> data:</span><br><span class="line">        data_new.append(cut_word(sentence))</span><br><span class="line">    <span class="comment"># print(data_new)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 实例化转换器类</span></span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 调用fit_transform</span></span><br><span class="line">    data_final = transfer.fit_transform(data_new)</span><br><span class="line">    print(<span class="string">"data_final:\n"</span>, data_final.toarray())</span><br><span class="line">    print(<span class="string">"特征名字:\n"</span>, transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>思考</strong></p><p>关键词：在某一个类别的文章中，出现的次数很多，但是在其他类别的文章中出现次数很少</p><p>所以，我们该如何处理某个词或短语在多篇文章中出现的次数高这一情况？</p><h3 id="Tf-idf文本特征提取"><a href="#Tf-idf文本特征提取" class="headerlink" title="Tf-idf文本特征提取"></a>Tf-idf文本特征提取</h3><ul><li>TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</li><li>TF-IDF作用：用以评估一个字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</li><li>字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</li></ul><p><strong>总结就是, 一个词语在一篇文章中出现次数越多, 同时在所有文档中出现次数越少, 越能够代表该文章。</strong></p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul><li><p>词频(term frequency，tf) 指的是某一个给定的词语在该文件中出现的频率</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/3.png" class></li><li><p>逆向文档频率(inverse document frequency,  idf) 是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再<strong>将得到的商取以10为底的对数</strong>得到。</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/4.png" class></li></ul><p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TF−IDF &#x3D; TF*IDF</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-02/5.png" class><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.feature_extraction.text.TfidfVectorizer(stop_words=None,…)<ul><li>返回词的权重矩阵</li><li>TfidfVectorizer.fit_transform(X)<ul><li>X : 文本或者文本字符串的可迭代对象</li><li>返回值：返回sparse矩阵</li></ul></li><li>TfidfVectorizer.inverse_transform(X)<ul><li>X：array数组或者sparse矩阵</li><li>返回值：转换之前的数据格式</li></ul></li><li>TfidfVectorizer.get_feature_names()<ul><li>返回值：单词列表</li></ul></li></ul></li></ul><p><strong>实例</strong></p><p>根据上个中文分词实例，使用TF-IDF进行特征提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer  <span class="comment"># Tfidf的引入</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_word</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    进行中文分词：“我爱北京天安门” 转换为 “我 爱 北京 天安门”</span></span><br><span class="line"><span class="string">    :param text:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a = jieba.cut(text)  <span class="comment"># 返回一个生成器对象</span></span><br><span class="line">    <span class="comment"># print(a)  # &lt;generator object Tokenizer.cut at 0x0000028FFE894C80&gt;</span></span><br><span class="line">    b = list(a)  <span class="comment"># 强转为列表类型</span></span><br><span class="line">    <span class="comment"># print(b)  # ['我', '爱', '北京', '天安门']</span></span><br><span class="line">    c = <span class="string">" "</span>.join(b)  <span class="comment"># 继续转换</span></span><br><span class="line">    <span class="comment"># print(c)  # 我 爱 北京 天安门</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_chinese</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用tfidf的方法进行文本特征抽取</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1. 将中文文本进行分词</span></span><br><span class="line">    data = [<span class="string">"在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。"</span>,</span><br><span class="line">            <span class="string">"过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。"</span>,</span><br><span class="line">            <span class="string">"如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。"</span>,</span><br><span class="line">            <span class="string">"那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。"</span>]</span><br><span class="line"></span><br><span class="line">    data_new = []</span><br><span class="line">    <span class="keyword">for</span> sentence <span class="keyword">in</span> data:</span><br><span class="line">        data_new.append(cut_word(sentence))</span><br><span class="line">    <span class="comment"># print(data_new)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 实例化转换器类</span></span><br><span class="line">    transfer = TfidfVectorizer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 调用fit_transform</span></span><br><span class="line">    data_final = transfer.fit_transform(data_new)</span><br><span class="line">    print(<span class="string">"data_final:\n"</span>, data_final.toarray())</span><br><span class="line">    print(<span class="string">"特征名字:\n"</span>, transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data_final:</span><br><span class="line"> [[0.25452286 0.25452286 0.         0.         0.25452286 0.</span><br><span class="line">  0.50904573 0.25452286 0.         0.16245865 0.         0.</span><br><span class="line">  0.25452286 0.         0.         0.25452286 0.         0.</span><br><span class="line">  0.25452286 0.         0.         0.         0.25452286 0.16245865</span><br><span class="line">  0.         0.         0.25452286 0.25452286 0.20066875 0.</span><br><span class="line">  0.         0.         0.         0.         0.         0.        ]</span><br><span class="line"> [0.         0.         0.         0.38006651 0.         0.38006651</span><br><span class="line">  0.         0.         0.         0.24259153 0.         0.29964881</span><br><span class="line">  0.         0.         0.         0.         0.         0.29964881</span><br><span class="line">  0.         0.29964881 0.         0.29964881 0.         0.24259153</span><br><span class="line">  0.         0.         0.         0.         0.29964881 0.</span><br><span class="line">  0.38006651 0.         0.         0.         0.         0.        ]</span><br><span class="line"> [0.         0.         0.30838102 0.         0.         0.</span><br><span class="line">  0.         0.         0.30838102 0.19683561 0.30838102 0.24313114</span><br><span class="line">  0.         0.24313114 0.         0.         0.30838102 0.24313114</span><br><span class="line">  0.         0.24313114 0.         0.         0.         0.</span><br><span class="line">  0.30838102 0.         0.         0.         0.         0.30838102</span><br><span class="line">  0.         0.24313114 0.30838102 0.         0.         0.        ]</span><br><span class="line"> [0.         0.         0.         0.         0.         0.</span><br><span class="line">  0.         0.         0.         0.         0.         0.</span><br><span class="line">  0.         0.27412127 0.34768807 0.         0.         0.</span><br><span class="line">  0.         0.         0.34768807 0.27412127 0.         0.22192479</span><br><span class="line">  0.         0.34768807 0.         0.         0.         0.</span><br><span class="line">  0.         0.27412127 0.         0.34768807 0.34768807 0.34768807]]</span><br></pre></td></tr></table></figure><h4 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h4><p>机器学习算法进行文章分类中 前期的数据处理方式</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>特征抽取</p><ul><li>字典特征抽取<ul><li>sklearn.feature_extraction.DictVectorizer</li></ul></li><li>文本特征抽取<ul><li>sklearn.feature_extraction.text.CountVectorizer</li><li>sklearn.feature_extraction.text.TfidfVectorizer</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特征工程学习，本篇主要介绍特征工程的&lt;strong&gt;数据集&lt;/strong&gt;和&lt;strong&gt;特征抽取&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_01(机器学习概述)</title>
    <link href="http://icewind-r.github.io/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-01/"/>
    <id>http://icewind-r.github.io/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-01/</id>
    <published>2020-12-19T01:21:14.000Z</published>
    <updated>2020-12-19T03:16:58.689Z</updated>
    
    <content type="html"><![CDATA[<p>啊今天又开始进行<strong>机器学习</strong>的学习，东西越来越多了！</p><a id="more"></a><hr><h1 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h1><p>机器学习的核心是“使用算法解析数据，从中学习，然后对世界上的某件事情做出决定或预测”。这意味着，与其显式地编写程序来执行某些任务，不如教计算机如何开发一个算法来完成任务。</p><p>即 <strong>数据</strong>、<strong>模型</strong> 和 <strong>预测</strong>。</p><p>从历史数据中获得规律，那么这些数据是什么格式的呢？</p><p><strong>数据集构成</strong>：特征值 + 目标值</p><h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><p>有三种主要类型的机器学习：监督学习、非监督学习和强化学习，所有这些都有其特定的优点和缺点。</p><h2 id="1、监督学习"><a href="#1、监督学习" class="headerlink" title="1、监督学习"></a>1、监督学习</h2><p>监督学习涉及一组标记数据。计算机可以使用特定的模式来识别每种标记类型的新样本。监督学习的两种主要类型是分类和回归。</p><p>即 ： 目标值是<strong>类别</strong>的，属于分类问题；目标值是<strong>连续型的数据</strong>的，属于回归问题。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在分类中，机器被训练成将一个组划分为特定的类。分类的一个简单例子是电子邮件帐户上的垃圾邮件过滤器。过滤器分析你以前标记为垃圾邮件的电子邮件，并将它们与新邮件进行比较。如果它们匹配一定的百分比，这些新邮件将被标记为垃圾邮件并发送到适当的文件夹。那些比较不相似的电子邮件被归类为正常邮件并发送到你的邮箱。</p><p><strong>算法举例：</strong>K-临近算法、贝叶斯分类、决策树与随机森林、逻辑回归</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>在回归中，机器使用先前的(标记的)数据来预测未来。天气应用是回归的好例子。使用气象事件的历史数据(即平均气温、湿度和降水量)，你的手机天气应用程序可以查看当前天气，并在未来的时间内对天气进行预测。</p><p><strong>算法举例：</strong>线性回归、岭回归</p><h2 id="2、非监督学习"><a href="#2、非监督学习" class="headerlink" title="2、非监督学习"></a>2、非监督学习</h2><p>在无监督学习中，数据是无标签的。由于大多数真实世界的数据都没有标签，这些算法特别有用。无监督学习分为聚类和降维。聚类用于根据属性和行为对象进行分组。这与分类不同，因为这些组不是你提供的。聚类的一个例子是将一个组划分成不同的子组(例如，基于年龄和婚姻状况)，然后应用到有针对性的营销方案中。降维通过找到共同点来减少数据集的变量。大多数大数据可视化使用降维来识别趋势和规则。</p><p><strong>算法举例：</strong>聚类、k-means</p><h2 id="3、强化学习"><a href="#3、强化学习" class="headerlink" title="3、强化学习"></a>3、强化学习</h2><p>强化学习使用机器的个人历史和经验来做出决定。强化学习的经典应用是玩游戏。与监督和非监督学习不同，强化学习不涉及提供“正确的”答案或输出。相反，它只关注性能。这反映了人类是如何根据积极和消极的结果学习的。很快就学会了不要重复这一动作。同样的道理，一台下棋的电脑可以学会不把它的国王移到对手的棋子可以进入的空间。然后，国际象棋的这一基本教训就可以被扩展和推断出来，直到机器能够打(并最终击败)人类顶级玩家为止。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>主要分为六个阶段：</p><ol><li>获取数据</li><li>数据处理</li><li>特征工程</li><li>机器学习算法训练 - 模型</li><li>模型评估（是否符合要求，不符合则转到 2 步骤继续循环，直到符合要求）</li><li>应用</li></ol><h1 id="常用算法简介"><a href="#常用算法简介" class="headerlink" title="常用算法简介"></a>常用算法简介</h1><h2 id="回归算法"><a href="#回归算法" class="headerlink" title="回归算法"></a>回归算法</h2><p>这可能是最流行的机器学习算法，线性回归算法是基于连续变量预测特定结果的监督学习算法。另一方面，Logistic回归专门用来预测离散值。这两种（以及所有其他回归算法）都以它们的速度而闻名，它们一直是最快速的机器学习算法之一。</p><h2 id="基于实例的算法"><a href="#基于实例的算法" class="headerlink" title="基于实例的算法"></a>基于实例的算法</h2><p>基于实例的分析使用提供数据的特定实例来预测结果。最著名的基于实例的算法是k-最近邻算法，也称为KNN。KNN用于分类，比较数据点的距离，并将每个点分配给它最接近的组。</p><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><p>决策树算法将一组“弱”学习器集合在一起，形成一种强算法，这些学习器组织在树状结构中，相互分支。一种流行的决策树算法是<strong>随机森林</strong>算法。在该算法中，弱学习器是随机选择的，这往往可以获得一个强预测器。在下面的例子中，我们可以发现许多共同的特征(就像眼睛是蓝的或者不是蓝色的)，它们都不足以单独识别动物。然而，当我们把所有这些观察结合在一起时，我们就能形成一个更完整的画面，并做出更准确的预测。</p><img src="/2020/12/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-01/1.png" class><h2 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h2><p>丝毫不奇怪，这些算法都是基于Bayes理论的，最流行的算法是朴素Bayes，它经常用于文本分析。例如，大多数垃圾邮件过滤器使用贝叶斯算法，它们使用用户输入的类标记数据来比较新数据并对其进行适当分类。</p><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p>聚类算法的重点是发现元素之间的共性并对它们进行相应的分组，常用的聚类算法是k-means聚类算法。在k-means中，分析人员选择簇数(以变量k表示)，并根据物理距离将元素分组为适当的聚类。</p><h1 id="机器学习建议"><a href="#机器学习建议" class="headerlink" title="机器学习建议"></a>机器学习建议</h1><p>首先需要明确两点问题：</p><ul><li>算法是核心，数据与科学是基础</li><li>找准定位 </li><li>书籍推荐<ul><li>机器学习（西瓜书）– 周志华</li><li>统计学习方法 – 李航</li><li>深度学习（花书）</li></ul></li></ul><h2 id="数学基础建议"><a href="#数学基础建议" class="headerlink" title="数学基础建议"></a>数学基础建议</h2><p>注意所有对数学恐惧的读者：我很遗憾地告诉你，要完全理解大多数机器学习算法，就需要对一些关键的数学概念有一个基本的理解。但不要害怕！所需的概念很简单，并且借鉴了你可能已经上过的课程。机器学习使用线性代数、微积分、概率和统计。</p><h3 id="Top-3线性代数概念："><a href="#Top-3线性代数概念：" class="headerlink" title="Top 3线性代数概念："></a>Top 3线性代数概念：</h3><p>1.矩阵运算；</p><p>2.特征值/特征向量；</p><p>3.向量空间和范数</p><h3 id="Top-3微积分概念："><a href="#Top-3微积分概念：" class="headerlink" title="Top 3微积分概念："></a>Top 3微积分概念：</h3><p>1.偏导数；</p><p>2.向量-值函数；</p><p>3.方向梯度</p><h3 id="Top-3统计概念："><a href="#Top-3统计概念：" class="headerlink" title="Top 3统计概念："></a>Top 3统计概念：</h3><p>1.Bayes定理；</p><p>2.组合学；</p><p>3.抽样方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊今天又开始进行&lt;strong&gt;机器学习&lt;/strong&gt;的学习，东西越来越多了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>VSCode奇淫巧计</title>
    <link href="http://icewind-r.github.io/2020/11/30/VSCode%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/"/>
    <id>http://icewind-r.github.io/2020/11/30/VSCode%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/</id>
    <published>2020-11-30T08:54:03.000Z</published>
    <updated>2020-12-03T07:32:35.529Z</updated>
    
    <content type="html"><![CDATA[<p>VSCode太强大了，但平常使用又较少，一定要总结一篇，方便日后查阅使用。</p><a id="more"></a><hr><h1 id="VSCode-之-HTML"><a href="#VSCode-之-HTML" class="headerlink" title="VSCode 之 HTML"></a>VSCode 之 HTML</h1><p>1、新建 html 文件时，html的骨架代码可以通过 先输入一个 <code>!</code> ，然后TAB键一键生成。</p><p>2、为使调试时使用浏览器查看html界面效果，可以通过下载插件， <strong>open in browser</strong>，然后按快捷键 ALT + B，就可以在默认浏览器下打开你写的页面了。</p><img src="/2020/11/30/VSCode%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1/1.webp" class><p>3、很多快捷生成代码方式：</p><ul><li><p><code>div.box</code> 生成 <code>&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code>    <code>div#main</code> 生成 <code>&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;</code></p></li><li><p>h300，自动生成 height: 300px;  输入 bgc 自动生成 background-color: #fff;等</p></li></ul><p>4、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VSCode太强大了，但平常使用又较少，一定要总结一篇，方便日后查阅使用。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>寒假学习计划详情</title>
    <link href="http://icewind-r.github.io/2020/11/30/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E6%96%AD%E5%88%97%E8%A1%A8/"/>
    <id>http://icewind-r.github.io/2020/11/30/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E6%96%AD%E5%88%97%E8%A1%A8/</id>
    <published>2020-11-30T04:49:54.000Z</published>
    <updated>2020-12-27T13:45:22.616Z</updated>
    
    <content type="html"><![CDATA[<p>一些知识学习中断的记录，供日后学习。</p><a id="more"></a><hr><h1 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h1><p>1、Docker学习中断，视频教程地址：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=20" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1og4y1q7M4?p=20</a> </p><p>2、Spring学习中断，<a href="https://www.bilibili.com/video/BV1nz4y1d7uy?p=50" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1nz4y1d7uy?p=50</a></p><p>3、SpringBoot学习开始：<a href="https://www.bilibili.com/video/BV1Et411Y7tQ" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Et411Y7tQ</a></p><p>4、机器学习：</p><p>5、spark：</p><p>6、python爬虫：</p><p>7、数据可视化：</p><p>8、大数据分析：</p><h1 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h1><p>安装多系统</p><p>hexo博客更多一点理解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些知识学习中断的记录，供日后学习。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker_05</title>
    <link href="http://icewind-r.github.io/2020/11/24/Docker-05/"/>
    <id>http://icewind-r.github.io/2020/11/24/Docker-05/</id>
    <published>2020-11-24T08:26:49.000Z</published>
    <updated>2020-11-30T04:50:25.697Z</updated>
    
    <content type="html"><![CDATA[<p>Docker学习中断，视频教程地址：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=20" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1og4y1q7M4?p=20</a> 还有上一篇文章的内容理解很浅，再次学习前需要加强巩固。</p><a id="more"></a> <hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker学习中断，视频教程地址：&lt;a href=&quot;https://www.bilibili.com/video/BV1og4y1q7M4?p=20&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV1og4y1q7M4?p=20&lt;/a&gt; 还有上一篇文章的内容理解很浅，再次学习前需要加强巩固。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://iceWind-R.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Docker" scheme="http://iceWind-R.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker_04</title>
    <link href="http://icewind-r.github.io/2020/11/24/Docker-04/"/>
    <id>http://icewind-r.github.io/2020/11/24/Docker-04/</id>
    <published>2020-11-24T02:08:25.000Z</published>
    <updated>2020-11-24T08:25:09.118Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 的 镜像讲解。</p><a id="more"></a> <hr><h1 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包<strong>软件运行环境</strong>和<strong>基于运行环境开发的软件</strong>，它包含运行某个软件的所有内容，包括代码、运行时的库、环境变量 和 配置文件。</p><p>所有的应用，直接打包成docker镜像，就可以直接部署！</p><h2 id="如何得到镜像？"><a href="#如何得到镜像？" class="headerlink" title="如何得到镜像？"></a>如何得到镜像？</h2><ul><li>从远程镜像下载</li><li>从朋友拷贝</li><li>自己制作一个 DockerFile</li></ul><h1 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h1><h2 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h2><p>UnionFS (联合文件系统)：Union文件系统( UnionFS )是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtualfilesystem)。</p><p>Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h2 id="Docker镜像加载原理-1"><a href="#Docker镜像加载原理-1" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p><strong>bootfs(boot file system)</strong>主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的LinuxlUnix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><blockquote><p>系统启动需要引导加载，bootfs所负责的，这一层是几乎不变的，所有发行版的Linux系统可以共用的。</p></blockquote><p><strong>rootfs (root file system)</strong>，在bootfs之上。包含的就是典型Linux系统中的/dev, /proc,/bin, /letc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu ,Centos等等。</p><p>使用docker pull centos下载最新版本的Centos镜像也就200M左右，而我们平时下载一个原生的centos镜像都是4G，为什么差别这么大呢？对于 Docker 初学者都会有这个疑问。</p><p>下面来了解下Linux 操作系统由内核空间和用户空间组成，如下图所示：</p><img src="/2020/11/24/Docker-04/1.png" class><blockquote><p>可以看到 最底层是 bootfs，这层是linux 的内核，在这层之上的是rootfs，即提供linux 的标准目录文件等。</p></blockquote><h2 id="不同-Linux-发行版的区别主要就是-rootfs。"><a href="#不同-Linux-发行版的区别主要就是-rootfs。" class="headerlink" title="不同 Linux 发行版的区别主要就是 rootfs。"></a>不同 Linux 发行版的区别主要就是 rootfs。</h2><p>比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大，即底层都是相同的bootfs。</p><p>所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境。</p><img src="/2020/11/24/Docker-04/2.png" class><p>上图 Debian 和 BusyBox上层提供各自的 rootfs，底层共用 Docker <strong>Host 的 kernel</strong>。</p><blockquote><p>对于一个精简的OS , rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel。</p><p> 自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs。</p></blockquote><h1 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h1><h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>我们 docker pull 的时候，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。</p><img src="/2020/11/24/Docker-04/3.png" class><p><strong>思考</strong>：为什么Docker镜像要采用这种分层的结构呢?</p><p>最大的好处，就是资源共享了！</p><p>比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><blockquote><p>什么是base镜像？</p><ol><li>不依赖其他镜像，从 scratch 构建。</li><li>其他镜像可以使之作为基础进行扩展。</li></ol><p>base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</p></blockquote><p>查看镜像分层的方式可以通过docker image inspect命令!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker image inspect redis</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">"RootFS": &#123;</span><br><span class="line">            "Type": "layers",</span><br><span class="line">            "Layers": [</span><br><span class="line">                "sha256:f5600c6330da7bb112776ba067a32a9c20842d6ecc8ee3289f1a713b644092f8",</span><br><span class="line">                "sha256:c492b4fe510f674e04af29c5a8be4d0104a53e82e68ae98a3f9a0dd385263b7c",</span><br><span class="line">                "sha256:60f4b166131fd0c3b925a04e4976fbc43525e289e5edab72ffc4b7196085905f",</span><br><span class="line">                "sha256:4bc5e04ae88961aa002128a1873888ad4adf5ce11712d601fec6ad5f280c547d",</span><br><span class="line">                "sha256:06d5c35d63a8e4066ca996005b118a6051d2323c4af64c0fc2be014b4da7740e",</span><br><span class="line">                "sha256:d3fc9f08141a1377e718b8a29fd94a8c46793b88efdbed4ad02cbe3a3d91de10"   // 分层信息</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>理解：</strong></p><p>所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层;如果在该镜像中添加Python包,就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁，就会创建第三个镜像层。</p><p>该镜像当前已经包含3个镜像层，如下图所示(这只是一个用于演示的很简单的例子)。</p><img src="/2020/11/24/Docker-04/4.png" class><h2 id="为什么docker镜像要采用这种分层结构呢？"><a href="#为什么docker镜像要采用这种分层结构呢？" class="headerlink" title="为什么docker镜像要采用这种分层结构呢？"></a>为什么docker镜像要采用这种分层结构呢？</h2><p>最大的一个好处就是<strong>共享资源</strong>。</p><p>比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><img src="/2020/11/24/Docker-04/5.png" class><h1 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h1><p>Docker镜像都是只读的。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p><p>这一层通常被称作为”容器层”，“容器层”之下的都叫”镜像层”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 的 镜像讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://iceWind-R.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Docker" scheme="http://iceWind-R.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-03</title>
    <link href="http://icewind-r.github.io/2020/11/23/Docker-03/"/>
    <id>http://icewind-r.github.io/2020/11/23/Docker-03/</id>
    <published>2020-11-23T11:14:26.000Z</published>
    <updated>2020-11-24T07:27:23.073Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 的 实操练习。</p><a id="more"></a> <hr><h1 id="Docker-安装-Nginx"><a href="#Docker-安装-Nginx" class="headerlink" title="Docker 安装 Nginx"></a>Docker 安装 Nginx</h1><p>步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、搜索镜像 建议到docker hub上下载</span></span><br><span class="line">docker search nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、下载最新镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、启动镜像</span></span><br><span class="line">docker run -d --name nginx01 -p:3344:80 nginx </span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台方式启动 --name 不写默认nginx，若有多个，指定名字，例如nginx01 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p:宿主机端口:docker容器端口 : 指定宿主机和nginx容器的端口对应关系</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后一个是镜像名字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动成功后，可通过下面命令验证，得到nginx的欢迎界面即为成功</span></span><br><span class="line">curl localhost:3344</span><br></pre></td></tr></table></figure><p>然后可以通过 ip:3344 访问，即可看到 nginx 欢迎界面。</p><p>关于 -p3344:80 端口暴露的概念</p><img src="/2020/11/23/Docker-03/1.png" class><p><strong>思考问题：</strong>我们每次改动 nginx 配置文件，都需要进入容器内部？十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改?</p><p>这里需要用到后期学习的<strong>数据卷</strong>的技术！</p><h1 id="Docker-安装-Tomcat"><a href="#Docker-安装-Tomcat" class="headerlink" title="Docker 安装 Tomcat"></a>Docker 安装 Tomcat</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方的使用,会自动启动tomcat服务</span></span><br><span class="line">docker run -it --rm tomcat # --rm 代表用完即删，一般用于测试</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们学习初期不使用以上方式，正常下载即可</span></span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像</span></span><br><span class="line">docker run -d -p:3355:8080 --name tomcat01 tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以上便可根据ip:3355访问，可以分为tomcat 但是404 not found</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器的目录结构</span></span><br><span class="line">root@e4cdba7e5c42:/usr/local/tomcat# ls -al</span><br><span class="line">total 128</span><br><span class="line">drwxr-xr-x. 1 root root    30 Nov 19 06:16 .</span><br><span class="line">drwxr-xr-x. 1 root root    20 Nov 19 06:12 ..</span><br><span class="line">-rw-r--r--. 1 root root 18982 Nov 12 15:41 BUILDING.txt</span><br><span class="line">-rw-r--r--. 1 root root  5409 Nov 12 15:41 CONTRIBUTING.md</span><br><span class="line">-rw-r--r--. 1 root root 57092 Nov 12 15:41 LICENSE</span><br><span class="line">-rw-r--r--. 1 root root  2333 Nov 12 15:41 NOTICE</span><br><span class="line">-rw-r--r--. 1 root root  3257 Nov 12 15:41 README.md</span><br><span class="line">-rw-r--r--. 1 root root  6898 Nov 12 15:41 RELEASE-NOTES</span><br><span class="line">-rw-r--r--. 1 root root 16507 Nov 12 15:41 RUNNING.txt</span><br><span class="line">drwxr-xr-x. 2 root root  4096 Nov 19 06:16 bin</span><br><span class="line">drwxr-xr-x. 1 root root    22 Nov 23 11:43 conf</span><br><span class="line">drwxr-xr-x. 2 root root  4096 Nov 19 06:16 lib</span><br><span class="line">drwxrwxrwx. 1 root root   177 Nov 23 11:43 logs</span><br><span class="line">drwxr-xr-x. 2 root root   134 Nov 19 06:16 native-jni-lib</span><br><span class="line">drwxrwxrwx. 2 root root    30 Nov 19 06:16 temp</span><br><span class="line">drwxr-xr-x. 2 root root     6 Nov 19 06:16 webapps</span><br><span class="line">drwxr-xr-x. 7 root root    81 Nov 12 15:38 webapps.dist</span><br><span class="line">drwxrwxrwx. 2 root root     6 Nov 12 15:35 work</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it tomcat01 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现问题，命令少了，webapps目录下没有内容，所以 404</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决:可以发现webapps.dist下有ROOT等文件，所以把webapps.dist里的内容复制进webapps下即可。</span></span><br><span class="line"></span><br><span class="line">cp -r webapps.dist/* webapps</span><br><span class="line"></span><br><span class="line">再次访问网页，成功。</span><br></pre></td></tr></table></figure><p><strong>思考问题：</strong>我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供一个映射路径，webapps ,我们在外部放置项目，就自动同步到内部就好了!</p><h1 id="Docker安装MySQL"><a href="#Docker安装MySQL" class="headerlink" title="Docker安装MySQL"></a>Docker安装MySQL</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line">docker run -p 3306:3306 --name mysql01 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure><p>此时，docker容器里的mysql服务启动，并且映射到宿主机的3306端口，可通过宿主机的ip:3306访问mysql服务。</p><h1 id="Docker安装SQL-server（失败！！）"><a href="#Docker安装SQL-server（失败！！）" class="headerlink" title="Docker安装SQL server（失败！！）"></a>Docker安装SQL server（失败！！）</h1><p>使用命令下载镜像：docker pull mcr.microsoft.com/mssql/server:2017-latest</p><p>使用命令创建并运行SQL server容器，密码root，容器名字sqlserver1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=root"  -p 1433:1433 --name sqlserver1  -d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure><h1 id="Docker安装Oracle（失败）"><a href="#Docker安装Oracle（失败）" class="headerlink" title="Docker安装Oracle（失败）"></a>Docker安装Oracle（失败）</h1><p>使用命令下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</p><p><strong>没有足够空间下载</strong></p><h1 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h1><p>使用命令docker pull redis 下载镜像</p><p>运行redis容器：docker run -itd –name redis01 -p 6379:6379 redis</p><p>使用命令行交互模式进入容器：docker exec -it redis01 /bin/bash </p><p>然后用redis-cli连接容器的redis进行测试</p><p>set test 1</p><h1 id="Docker安装MongoDB"><a href="#Docker安装MongoDB" class="headerlink" title="Docker安装MongoDB"></a>Docker安装MongoDB</h1><h1 id="Docker-部署-ES-Kibana"><a href="#Docker-部署-ES-Kibana" class="headerlink" title="Docker 部署 ES + Kibana"></a>Docker 部署 ES + Kibana</h1><p>es是elasticsearch6搜索引擎，kibana是它的可视化操作界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ES 暴露的端口很多！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ES 十分的耗内存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ES 的数据一般需要放置到安全目录！挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --net somenetwork ? 网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 es</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.9.3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看CPU状态： docker stats </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非常耗内存，占了大部分内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试es是否启动成功</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p>1、portainer（先用这个）： Docker图形化管理工具！提供一个后台面板供我们操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用命令</span></span><br><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true --name portainer01 portainer/portainer</span><br></pre></td></tr></table></figure><p>访问测试：ip:8088</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 的 实操练习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://iceWind-R.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Docker" scheme="http://iceWind-R.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker_02</title>
    <link href="http://icewind-r.github.io/2020/11/22/Docker-02/"/>
    <id>http://icewind-r.github.io/2020/11/22/Docker-02/</id>
    <published>2020-11-22T10:09:06.000Z</published>
    <updated>2020-11-23T11:14:42.307Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 的常用命令合集。</p><a id="more"></a> <hr><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><p>官方给出的概览图，很生动形象，学完下面命令后再看此图很有帮助。</p><img src="/2020/11/22/Docker-02/1.png" class><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version # 显示docker的版本信息</span><br><span class="line">docker info# 显示docker的系统信息，包括镜像容器的数量</span><br><span class="line">docker 命令 -help # 帮助命令</span><br></pre></td></tr></table></figure><p>还可以查看官方的命令 <a href="https://docs.docker.com/reference/" target="_blank" rel="noopener">帮助文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong>：查看所有本地主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen /]# docker imagesREPOSITORY</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        10 months ago       13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解释</span></span><br><span class="line">    REPOSITORY镜像的仓库源</span><br><span class="line">    TAG镜像的标签</span><br><span class="line">    IMAGE ID镜像的id</span><br><span class="line">    CREATED镜像的创建时间</span><br><span class="line">    SIZE镜像的大小</span><br><span class="line"><span class="meta">#</span><span class="bash">可选项</span></span><br><span class="line">    -a, --a71#列出所有镜像</span><br><span class="line">    -q, --quiet#只显示镜像的id</span><br></pre></td></tr></table></figure><p><strong>docker search (镜像名字)</strong>：搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               </span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10196               [OK]   </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3753                [OK]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项 通过过滤来搜索</span></span><br><span class="line">--filter=STARS=3000 # 搜索镜像的STARS数大于3000的</span><br></pre></td></tr></table></figure><p><strong>docker pull</strong>：下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">[root@localhost ~] # docker pull mysql</span><br><span class="line">Using default tag: latest # 如果不写 tag，默认是 latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">852e50cd189d: Pull complete  # 分层下载，docker image的核心 联合文件下载</span><br><span class="line">29969ddb0ffb: Pull complete </span><br><span class="line">a43f41a44c48: Pull complete </span><br><span class="line">5cdd802543a3: Pull complete </span><br><span class="line">b79b040de953: Pull complete </span><br><span class="line">938c64119969: Pull complete </span><br><span class="line">7689ec51a0d9: Pull complete </span><br><span class="line">a880ba7c411f: Pull complete </span><br><span class="line">984f656ec6ca: Pull complete</span><br><span class="line">9f497bce458a: Pull complete</span><br><span class="line">b9940f97694b: Pull complete</span><br><span class="line">2f069358dc96: Pull complete</span><br><span class="line">Digest: sha256:4bb2e81a40e9d0d59bd8e3dc2ba5e1f2197696f6de39a91e90798dd27299b093 # 唯一签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latestdocker.io/library/mysql:latest# 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下两个命令相互等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载，可在docker hub上查阅版本信息</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>docker rmi</strong>：删除镜像（rm image） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像id # 删除指定id的镜像</span><br><span class="line">docker rmi -f 镜像id 镜像id ... # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：我们有了镜像才可以创建容器，linux，下载一个 centos 镜像来测试学习</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image(镜像名字)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name="Name" # 容器名字 tomcat1 tomcat2,用来区分容器</span><br><span class="line">-d   # 后台方式运行</span><br><span class="line">-it  # 使用交互方式运行，进入容器查看内容</span><br><span class="line">-p  # 指定容器的端口</span><br><span class="line">-p 主机端口:容器端口（常用）</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P  # 随机指定端口</span><br></pre></td></tr></table></figure><p><strong>退出当前容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit# 停止容器并退出</span><br><span class="line"></span><br><span class="line">快捷键:Ctrl + P + Q  # 容器不停止并退出</span><br></pre></td></tr></table></figure><p>测试：启动并进入容器centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@1a52b837b77a /]# ls # 查看容器内的centos，基础版本，很多命令不完善</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出当前容器</span></span><br><span class="line">[root@1a52b837b77a /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p><strong>列出所有运行容器</strong></p><p>docker ps 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 列出当前正在运行的容器 （exit退出容器，容器不再运行）</span><br><span class="line">  参数:</span><br><span class="line">-a # 列出 当前正在运行的容器 + 历史运行过的容器</span><br><span class="line">-n=? # 显示最近创建的容器个数 </span><br><span class="line">-q # 只显示容器的编号</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id# 删除指定id的容器，不能删除正在运行的容器</span><br><span class="line">docker rm -f $(docker ps -aq) # 删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  # 删除所有容器</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id# 重启容器</span><br><span class="line">docker stop 容器id# 停止当前正在运行的容器</span><br><span class="line">docker ki11 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure><h2 id="常用其他重要命令"><a href="#常用其他重要命令" class="headerlink" title="常用其他重要命令"></a>常用其他重要命令</h2><p>以上命令是玩 docker 的基本命令，但这还远远不够。</p><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><p>命令 : <code>docker run -d 镜像名</code></p><p><strong>问题</strong>：启动后，docker ps 发现该容器被自动停掉。</p><p>原因：docker容器使用后台运行，就必须要有要一个<strong>前台进程</strong>，docker发现没有应用，就会自动停止</p><p>​            安装nginx镜像，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>命令：<code>docker logs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 自己编写一段shell脚本</span></span><br><span class="line">docker run -d centos /bin/bash -c "while true;do echo dongao;sleep 1;done"</span><br><span class="line"></span><br><span class="line">docker ps  # 查看创建的正在运行的容器</span><br><span class="line">CONTAINER ID        IMAGE </span><br><span class="line">6e703303ac9a        centos</span><br><span class="line"></span><br><span class="line">docker logs -tf --tail 10 6e703303ac9a # 查看该id的前10条日志</span><br></pre></td></tr></table></figure><h3 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h3><p>命令 <code>docker top 容器id</code></p><h3 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h3><p>命令 <code>docker inspect 容器id</code></p><p>包含非常多的容器的基本信息，很多信息值得探讨，在以后学习中会提及到。</p><h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><p>我们通常容器都是使用后台方式运行，我们需要进入容器，修改一些配置</p><p><strong>方式一</strong>：命令 <code>docker exec -it</code> 容器id bashShell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6e703303ac9a        centos              "/bin/bash -c 'while…"   17 minutes ago      Up 17 minutes                           condescending_vaughan</span><br><span class="line">[root@localhost ~]# docker exec -it 6e703303ac9a /bin/bash</span><br><span class="line">[root@6e703303ac9a /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 07:11 ?        00:00:00 /bin/bash -c while true;do echo dongao;sleep 1;done</span><br><span class="line">root       1086      0  0 07:29 pts/0    00:00:00 /bin/bash</span><br><span class="line">root       1110      1  0 07:29 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root       1111   1086  0 07:29 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：<code>docker attach 容器id</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker attach 6e703303ac9a</span><br><span class="line">正在执行当前的代码...</span><br></pre></td></tr></table></figure><p><strong><code>docker exec</code> 和 <code>docker attach</code> 的 区别</strong></p><p>docker exec：进入容器并开启一个新的终端，可以在里面操作（常用）</p><p>docker attach：进入容器正在执行的终端，不会启动新的进程。</p><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><p>命令 ：<code>docker cp 容器id:容器内路径 主机的目的路径</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker cp d737d4129453:/home/dongao.java /home</span><br></pre></td></tr></table></figure><h1 id="所有命令（查阅）"><a href="#所有命令（查阅）" class="headerlink" title="所有命令（查阅）"></a>所有命令（查阅）</h1><img src="/2020/11/22/Docker-02/2.png" class><img src="/2020/11/22/Docker-02/3.png" class>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 的常用命令合集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://iceWind-R.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Docker" scheme="http://iceWind-R.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring_04(AOP&amp;AspectJ)</title>
    <link href="http://icewind-r.github.io/2020/11/16/Spring-04/"/>
    <id>http://icewind-r.github.io/2020/11/16/Spring-04/</id>
    <published>2020-11-16T12:26:07.000Z</published>
    <updated>2020-12-28T05:56:26.930Z</updated>
    
    <content type="html"><![CDATA[<p>本节介绍spring 的AOP——面向切片编程。</p><a id="more"></a><hr><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理是指，程序在整个运行过程中根本就不存在目标类的代理类，目标对象的代理对象只是由代理生成工具(不是真实定义的类）在程序运行时由VM根据反射等机制动态生成的。代理对象与目标对象的代理关系在程序运行时才确立。</p><p>简单来说，就是给原来的类增加一些功能，即<strong>功能增强</strong>。</p><h2 id="JDK的动态代理"><a href="#JDK的动态代理" class="headerlink" title="JDK的动态代理"></a>JDK的动态代理</h2><p>动态代理的实现方式常用的有两种:使用JDK的 Proxy，与通过CGLIB生成代理。</p><p>Jdk的动态要求<strong>目标对象必须实现接口</strong>，这是java设计上的要求。</p><p>从jdk1.3以来，java语言通过java.lang.reflect包提供三个类支持代理模式 Proxy，Method 和 InovcationHandler 。</p><p>动态代理的作用:</p><p>1) 在目标类源代码不改变的情况下，增加功能。</p><p>2) 减少代码的重复</p><p>3) 专注业务逻辑代码</p><p>4) 解耦合，让你的业务功能和日志，事务和非业务的功能分离。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>现有 SomeService 接口和它的实现类 SomeServiceImpl，要求使用动态代理，不改变SomeServiceImpl的源码，给类中的doSome 和 doOther() 类添加 时间 和 事务完成代码。具体代码如下</p><p>SomeService 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doOther</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SomeServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thorine.service.SomeService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ServiceTools.doLog(); // 动态代理就是实现注释里的代码的</span></span><br><span class="line">        System.out.println(<span class="string">"执行doSome()..."</span>);</span><br><span class="line">        <span class="comment">//ServiceTools.doTrans();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ServiceTools.doLog();</span></span><br><span class="line">        System.out.println(<span class="string">"执行doOther()..."</span>);</span><br><span class="line">        <span class="comment">//ServiceTools.doTrans();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyInvocationHandler（代理类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thorine.util.ServiceTools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// SomeServiceImpl类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了MyInvocationHandler的invoke方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Method方法名："</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ServiceTools.doLog(); <span class="comment">// 方法增强</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标类的方法，通过Method类实现，通过代理对象执行方法时，会调用这个invoke()</span></span><br><span class="line">        result = method.invoke(target, args); <span class="comment">// SomeServiceImpl.doOther,doSome()</span></span><br><span class="line"></span><br><span class="line">        ServiceTools.doTrans(); <span class="comment">// 方法增强</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标方法执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thorine.handler.MyInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> com.thorine.service.impl.SomeServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用JDK 的proxy创建代理对象</span></span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        SomeService target = <span class="keyword">new</span> SomeServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建InvocationHandler对象</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用proxy创建代理</span></span><br><span class="line">        SomeService proxy = (SomeService) Proxy.newProxyInstance</span><br><span class="line">                (target.getClass().getClassLoader(), target.getClass().getInterfaces(),handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过代理执行方法，会调用handler中的invoke()</span></span><br><span class="line">        proxy.doSome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h1><p>AOP (Aspect Orient Programming)，面向切面编程。面向切面编程是从动态角度考虑程序运行过程。</p><p>AOP底层，就是采用<strong>动态代理模式</strong>实现的。采用了两种代理 : JDK的动态代理，与CGLIB的动态代理。</p><blockquote><p>AOP为Aspect Oriented Programming的缩写，意为 : 面向切面编程，可通过运行期动态代理实现程序功能的统一维护的一种技术。AOP是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></blockquote><p>因为动态代理很灵活，实现方法复杂多样，为了统一规则，而出现的AOP。</p><p>总之，AOP就是动态代理的规范化。</p><h2 id="Aspect：切面"><a href="#Aspect：切面" class="headerlink" title="Aspect：切面"></a>Aspect：切面</h2><p>给目标类增加的功能，就是切面。像上面用的增加日志、事务功能 等都是切面。</p><p><strong>特点：</strong>一般都是非业务方法，可以独立使用。</p><blockquote><p>业务方法：功能性的方法代码等。例如：数据库增删改查，逻辑运算（10+20）等。</p></blockquote><h2 id="怎么理解面向切面编程？"><a href="#怎么理解面向切面编程？" class="headerlink" title="怎么理解面向切面编程？"></a>怎么理解面向切面编程？</h2><p>1、在分析项目功能时，找出切面。（最重要）</p><p>2、合理的安排切面的执行时间（在目标方法前，还是目标方法后）</p><p>3、合理的安全切面执行的位置，在哪个类，哪个方法增加增强方法。</p><h2 id="AOP编程术语"><a href="#AOP编程术语" class="headerlink" title="AOP编程术语"></a>AOP编程术语</h2><p>1）Aspect（切面）：表示增强的非业务性功能，例如：日志，统计信息，参数检查，权限验证。</p><p>2）JoinPoint（连接点）：连接业务方法和切面的位置，就是某类中的业务方法。（只有一个）</p><p>3）PointCut（切入点）：指多个连接点的集合。（多个方法）</p><p>4）目标对象：给哪个类的方法增加功能，该类便是目标对象。</p><p>5）Active（通知）：表示切面功能执行的时间（在目标方法前，还是目标方法后）</p><h2 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h2><p>aop是一个规范，是动态的一个规范化，一个标准。</p><p>aop的技术实现框架：</p><ol><li><p><strong>spring</strong>: spring在内部实现了aop规范，能做aop的工作。spring主要在事务处理时使用aop。</p><p>我们项目开发中很少使用spring的aop实现。因为spring的aop比较笨重。</p></li><li><p><strong>aspectJ</strong>（重点掌握） :一个开源的专门做aop的框架。</p></li></ol><h1 id="AspectJ对AOP的实现（掌握）"><a href="#AspectJ对AOP的实现（掌握）" class="headerlink" title="AspectJ对AOP的实现（掌握）"></a>AspectJ对AOP的实现（掌握）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AspectJ是一个优秀面向切面的框架，它扩展了Java语言，提供了强大的切面实现。</p><p>AspectJ实现了AOP的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以，Spring将AspectJ的对于AOP的实现引入到了自己的框架中。</p><p>官网地址：<a href="https://www.eclipse.org/aspectj/" target="_blank" rel="noopener">https://www.eclipse.org/aspectj/</a></p><p>AspectJ框架实现aop有两种方式：</p><ul><li>使用xml配置文件：配置全局事务</li><li>使用注解（常用），有5个注解</li></ul><h2 id="学习AspectJ框架的使用"><a href="#学习AspectJ框架的使用" class="headerlink" title="学习AspectJ框架的使用"></a>学习AspectJ框架的使用</h2><p>1、切面的执行时间，这个执行时间在规范中叫做Advice（通知）</p><p>​        在AspectJ 框架中使用注解表示的。也可以使用xml配置文件中的标签</p><p>​        1）@Before    </p><p>​        2）@AfterReturning</p><p>​        3）@Around</p><p>​        4）@AfterThrowing</p><p>​        5）@After</p><h2 id="AspectJ的切入点表达式-掌握"><a href="#AspectJ的切入点表达式-掌握" class="headerlink" title="AspectJ的切入点表达式(掌握)"></a>AspectJ的切入点表达式(掌握)</h2><p>AspectJ定义了专门的表达式用于指定切入点。表达式的原型是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern</span><br><span class="line">  declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">  <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>:</p><p>​    modifiers-pattern：访问权限类型（公有、私有）</p><p>​    <font color="red">ret-type-pattern</font>：返回值类型</p><p>​    declaring-type-pattern：包名类名</p><p>​    <font color="red">name-pattern(param-pattern)</font>：方法名(参数类型和参数个数)</p><p>​    throws-pattern：抛出异常类型</p><p>​    <strong>?表示可选的部分</strong></p><p>以上表达式共4个部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(访问权限 方法返回值 方法声明(参数) 异常类型) <span class="comment">// 方法返回值 和 方法声明是必须的</span></span><br></pre></td></tr></table></figure><p>切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名。</p><p>注意，表达式中第一项和第四项是可省略的部分，各部分间用空格分开。在其中可以使用以下符号:</p><table><thead><tr><th>符合</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>0至多个任意字符</td></tr><tr><td>..</td><td>用在方法参数中，表示任意多个参数<br>用在包名后，表示当前包及其子包路径</td></tr><tr><td>+</td><td>用在类名后，表示当前类及其子类<br>用在接口后，表示当前接口及其实现类</td></tr></tbody></table><p><strong>举例（理解掌握）</strong>：</p><ol><li>execution(public * <em>(..)) ：指定切入点为所有的公有方法，括号里共有三个部分，第二个 * 表示方法返回值，第三个</em>表示表示方法声明，因为后紧跟括号。</li><li>execution(* set*(..)) ：指定切入点为任意一个以“set”开始的方法。只有两个部分，所以一点是两个必须部分，返回值和方法声明。</li><li>execution(* com.xyz.service.*.*(..))：指定切入点为：定义在service包里的任意类的任意方法。</li><li>execution(* com.xyz.service..*.*(..))：指定切入点为：定义在 service包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟 “* ”，表示包、子包下的所有类。</li><li>execution(* *..service.*.*(..))：指定所有包下的serivce子包下所有类（接口）中所有方法为切入点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节介绍spring 的AOP——面向切片编程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://iceWind-R.github.io/categories/Web/"/>
    
    
      <category term="spring" scheme="http://iceWind-R.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow_01(安装及入门)</title>
    <link href="http://icewind-r.github.io/2020/11/15/Tensorflow-01/"/>
    <id>http://icewind-r.github.io/2020/11/15/Tensorflow-01/</id>
    <published>2020-11-15T08:11:21.000Z</published>
    <updated>2021-01-06T03:56:32.990Z</updated>
    
    <content type="html"><![CDATA[<p>tensorflow 的安装及入门。</p><a id="more"></a><hr><h1 id="Tensorflow安装"><a href="#Tensorflow安装" class="headerlink" title="Tensorflow安装"></a>Tensorflow安装</h1><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>1、安装tensorflow是基于Python的，并且需要从Anaconda仓库中下载。</p><p>2、所以我们的步骤是：先下载Anaconda，再在Anaconda中安装一个Python，(你的电脑里可能本来已经装了一个Python环境，但是Anaconda中的Python是必须再装的)，然后再下载安装tensorflow。</p><p>3、使用命令行安装时用清华的镜像一直没能成功，直到使用豆瓣镜像才顺利完成。</p><h2 id="一、命令行安装"><a href="#一、命令行安装" class="headerlink" title="一、命令行安装"></a>一、命令行安装</h2><p>打开Anaconda Promote。</p><img src="/2020/11/15/Tensorflow-01/2.png" class><p>输入命令 ： <code>conda create --name tensorflow python=3.5</code></p><p>即代表创建在Anaconda中创建一个名为tensorflow的虚拟环境，并指定pyhton版本为 3.5.x</p><img src="/2020/11/15/Tensorflow-01/1.png" class><p> 完成后根据提示 <code>activate tensorflow</code>，进入 tensorflow 的虚拟环境即可。</p><p>然后可以使用命令 <code>python -m pip install --upgrade pip</code>  ，更新一下pip命令</p><p>在上述激活的tensorflow的虚拟环境中，输入命令如下：</p><p><code>pip install tensorflow==2.0.0 -i https://pypi.doubanio.com/simple</code></p><p>等待没有报红，然后下载成功。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>输入python进入python交互模式，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure><p>得到结果如下</p><img src="/2020/11/15/Tensorflow-01/3.png" class><p>完成！</p><h2 id="二、navigator安装"><a href="#二、navigator安装" class="headerlink" title="二、navigator安装"></a>二、navigator安装</h2><p>这个就非常容易了，只需在 All 包中搜索tensorflow，下载安装即可。</p><h1 id="Tensorflow简介"><a href="#Tensorflow简介" class="headerlink" title="Tensorflow简介"></a>Tensorflow简介</h1><p>主要从三部分入手：</p><p>1、tf.keras：这是构建和训练模型的<strong>核心高级</strong>API</p><ul><li>单输入单输出Sequential顺序模型</li><li>函数式API</li></ul><p>2、Eager模式与自定义训练：直接迭代和直观调试，Eager模式下求解梯度与自定义训练</p><ul><li>Eager模式：直接迭代和直观调试</li><li>tf.GradientTape：求解梯度，自定义训练逻辑</li></ul><p>3、tf.data：加载图片数据与结构化数据</p><p>4、介绍tf.function：自动图运算</p><p>5、卷积神经网络</p><p>6、多输出卷积神经网络综合实例</p><p>7、迁移学习</p><p>8、模型保存与可视化</p><p>9、TensorBoard可视化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tensorflow 的安装及入门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://iceWind-R.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorflow" scheme="http://iceWind-R.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Spring_03(基于注解的DI)</title>
    <link href="http://icewind-r.github.io/2020/11/14/Spring-03/"/>
    <id>http://icewind-r.github.io/2020/11/14/Spring-03/</id>
    <published>2020-11-14T09:38:35.000Z</published>
    <updated>2020-12-28T05:56:49.078Z</updated>
    
    <content type="html"><![CDATA[<p>基于上篇总结的第一种基于XML的DI，本篇总结DI的第二种，也是更为常见和应用更为广泛的基于<strong>注解</strong>的DI。</p><hr><a id="more"></a><h1 id="基于注解的DI"><a href="#基于注解的DI" class="headerlink" title="基于注解的DI"></a>基于注解的DI</h1><p>对于使用注解的 DI 操作，将不再需要在 spring 配置文件中声明bean实例。spring中使用注解，需要在原有spring运行环境基础上再做一些改变。</p><p>需要在spring配置文件中配置组件扫描器，用于在指定的基本包中扫描注解。</p><p>使用注解的<strong>步骤</strong>:<br>1.加入maven的依赖spring-context ，在你加入spring-context的同时，间接加入spring-aop的依赖。使用注解必须使用spring-aop依赖</p><p>2.在类中加入spring的注解（多个不同功能的注解）</p><p>3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置</p><p><strong>学习的注解</strong>:</p><ol><li><p>@Component</p></li><li><p>@Repository</p></li><li><p>@Service</p></li><li><p>@Controller</p></li><li><p>@Value</p></li><li><p>@Autowired</p></li><li><p>@Resource</p></li></ol><h2 id="定义Bean的注解-Component"><a href="#定义Bean的注解-Component" class="headerlink" title="定义Bean的注解 @Component"></a>定义Bean的注解 @Component</h2><p>需要在类上使用注解 @Component，该注解的value属性用于指定该bean 的id值。</p><p>Student类文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.ba01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @component:创建对象,等同于&lt;bean&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">*   属性: value 就是对象的名称，也就是bean的id值，值是唯一的，创建的对象整个spring容器只有一个</span></span><br><span class="line"><span class="comment">*   位置：在类的上面</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*       spring中和@component功能一致，创建对象的注解还有:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1.@Repository (用在持久层类的上面):放在dao的实现类上面，</span></span><br><span class="line"><span class="comment">        表示创建dao对象，dao对象是能访问数据库的。</span></span><br><span class="line"><span class="comment">        2.@Service(用在业务层类的上面):放在service的实现类上面，</span></span><br><span class="line"><span class="comment">        创建service对象,service对象是做业务处理，可以有事务等功能的。</span></span><br><span class="line"><span class="comment">        3.@Controller(用在控制器的上面):放在控制器（处理器）类的上面，创建控制器对象的</span></span><br><span class="line"><span class="comment">        控制器对象,能够接受用户提交的参数，显示请求的处理结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        以上三个注解的使用语法和@Component一样的。都能创建对象，但是这三个注解还有额外的功能。</span></span><br><span class="line"><span class="comment">        @Repository , @Service , @controller是给项目的对象分层的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        只要不创建属于以上三个的种类的类对象，就使用 @Component</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component(value = "myStudent") 正规用法</span></span><br><span class="line"><span class="comment">// @Component("myStudent") 省略 value 用法</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 则会创建由 spring 默认指定名称的对象，即 student</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 无参构造方法执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明组件扫描器(component-scan),组件就是java对象</span></span><br><span class="line"><span class="comment">        base-package:指定注解在你的项目中的包名</span></span><br><span class="line"><span class="comment">        component-scan工作方式: spring会扫描逼历base-package指定的包，</span></span><br><span class="line"><span class="comment">        把 包中和子包中 的所有类,找到类中的注解,按照注解的功能创建对象，或给属性赋值。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.thorine.ba01"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定多个包的三种方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一种：使用多次组件扫描器，每个指定一个包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.thorine.ba01"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.thorine.ba02"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二种: 使用分隔符(; 或 ,) 分隔多个包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.thorine.ba01;com.thorine.ba02"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第三种:指定父包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.thorine"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2020/11/14/Spring-03/1.png" class><h2 id="简单类型属性注入-Value"><a href="#简单类型属性注入-Value" class="headerlink" title="简单类型属性注入@Value"></a>简单类型属性注入@Value</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.ba02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myStudent"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @Value:简单类型的属性赋值</span></span><br><span class="line"><span class="comment">    * 属性：value 是 String 类型的，表示简单类型的属性值</span></span><br><span class="line"><span class="comment">    * 位置：</span></span><br><span class="line"><span class="comment">    *       1、在属性定义的上面，无需set方法，推荐使用。</span></span><br><span class="line"><span class="comment">    *       2、在set方法上</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张飞"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"29"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 无参构造..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动注入-Autowired"><a href="#自动注入-Autowired" class="headerlink" title="自动注入@Autowired"></a>自动注入@Autowired</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.ba03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myStudent"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @Value:简单类型的属性赋值</span></span><br><span class="line"><span class="comment">    * 属性：value 是 String 类型的，表示简单类型的属性值</span></span><br><span class="line"><span class="comment">    * 位置：</span></span><br><span class="line"><span class="comment">    *       1、在属性定义的上面，无需set方法，推荐使用。</span></span><br><span class="line"><span class="comment">    *       2、在set方法上</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张飞"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"29"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Autowired</span>: 实现引用类型的赋值，是自动注入的原理，支持byName,byType</span></span><br><span class="line"><span class="comment">     * 默认使用byType自动注入</span></span><br><span class="line"><span class="comment">     * 位置：属性定义的上面，无需使用set方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 属性：required，是一个Boolean类型，默认为 true，表示若引用类型赋值失败，则报错并中止程序运行</span></span><br><span class="line"><span class="comment">     * 若是false，则程序正常执行，引用类型赋值为 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果要使用byName方式，则在属性上面加 <span class="doctag">@Autowired</span> 和 <span class="doctag">@Qualified</span>(value="bean的id"): 表示使用指定名称的bean赋值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>) <span class="comment">// required属性推荐使用默认，即 true</span></span><br><span class="line">    <span class="comment">// @Qualifier("mySchool") 打开注释则代表byName</span></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 无参构造..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", school="</span> + school +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK注解-Resource-自动注入"><a href="#JDK注解-Resource-自动注入" class="headerlink" title="JDK注解@Resource 自动注入"></a>JDK注解@Resource 自动注入</h2><p>spring提供了对jdk中@Resource注解的支持。@Resource注解既可以按名称匹配Bean，也可以按类型匹配Bean，<strong>默认是按名称注入</strong>。@Resource可在属性上，可在set方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Resource</span>: 来自jdk的注解，spring对其提供了支持，也是自动注入的原理，默认byName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@Resource  默认byName,如果byName找不到,byType</span></span><br><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"school"</span>) <span class="comment">// 只使用byName</span></span><br><span class="line"><span class="keyword">private</span> School school;</span><br></pre></td></tr></table></figure><h2 id="注解与XML的对比"><a href="#注解与XML的对比" class="headerlink" title="注解与XML的对比"></a>注解与XML的对比</h2><p>需要经常改变值用xml，不需要或不经常改变值的用注解。</p><p>注解更直观方便，查看类代码就能知道该类对象的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于上篇总结的第一种基于XML的DI，本篇总结DI的第二种，也是更为常见和应用更为广泛的基于&lt;strong&gt;注解&lt;/strong&gt;的DI。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://iceWind-R.github.io/categories/Web/"/>
    
    
      <category term="spring" scheme="http://iceWind-R.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring_02(基于XML的DI)</title>
    <link href="http://icewind-r.github.io/2020/11/10/Spring-02/"/>
    <id>http://icewind-r.github.io/2020/11/10/Spring-02/</id>
    <published>2020-11-10T09:07:52.000Z</published>
    <updated>2020-12-28T05:57:07.688Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇spring入门案例，本篇文章讲解如何给对象赋值，即DI操作。本篇总结第一种基于XML的DI。</p><a id="more"></a><hr><p>给对象赋值有两种方式，基于XML的DI和基于注解的DI。</p><p>di的实现有两种:</p><ol><li>在spring的配置文件中，使用标签和属性完成，叫做基于XML的di实现</li><li>使用spring中的注解，完成属性赋值，叫做基于注解的di实现</li></ol><p>di的语法分类:</p><ol><li><strong>set注入</strong>（设置注入） : spring调用类的set方法，在set方法可以实现属性的赋值。80%左右都是使用的set注入。（常用）</li><li><strong>构造注入</strong>：spring调用类的有参数构造方法，创建对象。在构造方法中完成赋值。</li></ol><p>我们需要重点掌握后者。</p><h1 id="基于XML的DI"><a href="#基于XML的DI" class="headerlink" title="基于XML的DI"></a>基于XML的DI</h1><h2 id="1、注入分类"><a href="#1、注入分类" class="headerlink" title="1、注入分类"></a>1、注入分类</h2><h3 id="set注入（掌握）"><a href="#set注入（掌握）" class="headerlink" title="set注入（掌握）"></a>set注入（掌握）</h3><h4 id="A、简单类型"><a href="#A、简单类型" class="headerlink" title="A、简单类型"></a>A、简单类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"setName():"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"setAge():"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        简单类型：spring中规定java的基本数据类型和string都是简单类型</span></span><br><span class="line"><span class="comment">        DI，注入：就是赋值的意思</span></span><br><span class="line"><span class="comment">        di：给属性赋值</span></span><br><span class="line"><span class="comment">            1、set注入（设置注入）：spring调用类的set方法，你可以在set方法中完成属性赋值</span></span><br><span class="line"><span class="comment">                1) 简单类型注入</span></span><br><span class="line"><span class="comment">                    &lt;bean id="xx" class="yy"&gt;</span></span><br><span class="line"><span class="comment">                        &lt;property name="属性名字" value="此属性的值" /&gt;</span></span><br><span class="line"><span class="comment">                        一个property只能给一个属性赋值，若赋值多个语句，多个property</span></span><br><span class="line"><span class="comment">                    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myStudent"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba01.Student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span> /&gt;</span> <span class="comment">&lt;!--调用了setName("zhangsan")--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span> /&gt;</span> <span class="comment">&lt;!--调用了setAge("zhangsan")--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意：使用上述set注入，Student类中必须有set方法，没有则会报错--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置之后，应用上篇文章的创建对象方法，创建的Student对象便会带有配置文件中指定的属性。</p><h4 id="B、引用类型"><a href="#B、引用类型" class="headerlink" title="B、引用类型"></a>B、引用类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            2、引用类型的set注入：spring调用类的set方法</span></span><br><span class="line"><span class="comment">            &lt;bean&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="属性名字" ref="bean的id(对象的名称)" /&gt;</span></span><br><span class="line"><span class="comment">            &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myStudent"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba02.Student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"22"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"school"</span> <span class="attr">ref</span>=<span class="string">"mySchool"</span> /&gt;</span> <span class="comment">&lt;!--调用setSchool()--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明School对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySchool"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba02.School"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"北京大学"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"北京"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在Student的类中有一个属性 private School school；School是自定义的一个类，有name 和 address属性。</p></blockquote><h3 id="构造注入（理解）"><a href="#构造注入（理解）" class="headerlink" title="构造注入（理解）"></a>构造注入（理解）</h3><p>构造注入是指，在构造调用者实例的同时，完成被调用者的实例化。即，使用构造器设置依赖关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        构造注入：spring 调用类有参数构造方法，在创建对象的同时，在构造方法中给属性赋值</span></span><br><span class="line"><span class="comment">        构造注入使用标签：&lt;constructor-arg&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">        一个 &lt;constructor-arg&gt; 标签表示构造方法的一个属性</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt; 标签属性：</span></span><br><span class="line"><span class="comment">            name:构造方法的形参名</span></span><br><span class="line"><span class="comment">            index:构造方法参数的位置, 0,1,2...</span></span><br><span class="line"><span class="comment">            value:形参类型是简单类型的</span></span><br><span class="line"><span class="comment">            ref:形参类型是引用类型的</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myStudent"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba03.Student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"school"</span> <span class="attr">ref</span>=<span class="string">"mySchool"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用index属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myStudent2"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba03.Student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"李四"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"25"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">ref</span>=<span class="string">"mySchool"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明School对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySchool"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba03.School"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"北京大学"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"北京"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>必须在被创建对象的Student类中添加有参构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, School school)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============Student类有参数构造方法============="</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.school = school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用构造注入时，所有的形参都要进行赋值，set注入则可以留空。</p></blockquote><h2 id="2、引用类型的自动注入"><a href="#2、引用类型的自动注入" class="headerlink" title="2、引用类型的自动注入"></a>2、引用类型的自动注入</h2><p>对于引用类型属性的注入，也可不在配置文件中显示的注入。可以通过为&lt;bean/&gt;标签设置autowire属性值，为引用类型属性进行隐式自动注入（默认是不自动注入引用类型属性）。根据注入判断标准不同，可以分为以下两种：</p><ul><li>byName：根据名称自动注入</li><li>byType：根据类型自动注入</li></ul><h3 id="（1）byName方式自动注入"><a href="#（1）byName方式自动注入" class="headerlink" title="（1）byName方式自动注入"></a>（1）byName方式自动注入</h3><img src="/2020/11/10/Spring-02/2.png" class><h3 id="（2）byType方式自动注入"><a href="#（2）byType方式自动注入" class="headerlink" title="（2）byType方式自动注入"></a>（2）byType方式自动注入</h3><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引用类型的自动注入：spring 框架根据某些规则可以给引用类型赋值。</span></span><br><span class="line"><span class="comment">        使用的规则常用的是byName, byType.</span></span><br><span class="line"><span class="comment">        1.byName(按名称注入): java 类中引用类型的属性名和spring容器中(配置文件)&lt;bean&gt; 的id名称一样，</span></span><br><span class="line"><span class="comment">                             且数据类型是一致的这样容器中的bean，spring能够赋值给引用类型。</span></span><br><span class="line"><span class="comment">        语法：</span></span><br><span class="line"><span class="comment">        &lt;bean id="xx" class="com.xx..."&gt;</span></span><br><span class="line"><span class="comment">            简单类型属性赋值</span></span><br><span class="line"><span class="comment">        &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.byType(按类型注入): java 类中引用类型的数据类型和spring容器中（配置文件）&lt;bean&gt; 的class属性</span></span><br><span class="line"><span class="comment">                             是同源关系的，这样的bean能够赋值给引用类型</span></span><br><span class="line"><span class="comment">                   同源就是一类的意思：</span></span><br><span class="line"><span class="comment">                   1、Java类中引用类型的数据类型和bean的class值是一样的</span></span><br><span class="line"><span class="comment">                   2、Java类中引用类型的数据类型和bean的class值是父子关系的</span></span><br><span class="line"><span class="comment">                   3、Java类中引用类型的数据类型和bean的class值是接口和实现类关系的</span></span><br><span class="line"><span class="comment">        语法：</span></span><br><span class="line"><span class="comment">        &lt;bean id="xx" class="com.xx..."&gt;</span></span><br><span class="line"><span class="comment">            简单类型属性赋值</span></span><br><span class="line"><span class="comment">        &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--byName or byType--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba04.Student"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"22"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySchool"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba04.School"</span>&gt;</span> <span class="comment">&lt;!-- 若为 byName, 则id为school --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"北京大学111111111"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"北京"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、为应用指定多个spring配置文件"><a href="#3、为应用指定多个spring配置文件" class="headerlink" title="3、为应用指定多个spring配置文件"></a>3、为应用指定多个spring配置文件</h2><img src="/2020/11/10/Spring-02/3.png" class><p><strong>多个配置优势</strong></p><ol><li><p>每个文件的大小比一个文件要小很多。效率高</p></li><li><p>避免多人竞争带来的冲突。如果你的项目有多个模块（相关的功能在一起)，一个模块一个配置文件。</p></li></ol><p>多文件的分配方式：</p><p>   1．按功能模块，一个模块一个配置文件</p><p>   2．按类的功能，数据库相关的配置一个文件配置文件，做事务的功能一个配置文件，做service功能的一个配置文件等</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>三个配置文件.</p><p>spring-school.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        school 模块的配置文件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"school"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba05.School"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"多配置文件"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"北京"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-student.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        student模块所有bean 的声明</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba05.Student"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"多配置文件"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"88"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三个是主配置文件 total.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        包含关系的配置文件：</span></span><br><span class="line"><span class="comment">        表示主配置文件：用来包含其他的配置文件，该配置文件不定义对象</span></span><br><span class="line"><span class="comment">        语法： &lt;import resource="其他配置文件的路径" /&gt;</span></span><br><span class="line"><span class="comment">        关键字："classpath": 表示类路径(class文件所在的目录，在target目录下的是classes目录下)，</span></span><br><span class="line"><span class="comment">        在spring的配置文件中要指定其他文件的位置，需要使用classpath，告诉spring到哪去加载读取文件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载的是文件列表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:ba05/spring-school.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:ba05/spring-student.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在包含关系的配置文件中，可以使用通配符(*: 表示任意字符)</span></span><br><span class="line"><span class="comment">        并且注意：不能包含主配置文件，将spring-total.xml 改名 total.xml</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:ba05/spring-*.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他代码基本一致，注意把调用的config改为 total.xml 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇spring入门案例，本篇文章讲解如何给对象赋值，即DI操作。本篇总结第一种基于XML的DI。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://iceWind-R.github.io/categories/Web/"/>
    
    
      <category term="spring" scheme="http://iceWind-R.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring_05(AspectJ具体实现)</title>
    <link href="http://icewind-r.github.io/2020/11/09/Spring-05/"/>
    <id>http://icewind-r.github.io/2020/11/09/Spring-05/</id>
    <published>2020-11-09T11:24:21.000Z</published>
    <updated>2020-12-30T08:22:48.636Z</updated>
    
    <content type="html"><![CDATA[<p>AspectJ的Spring实现。</p><a id="more"></a><hr><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>使用AspectJ框架实现Aop。</p><p>使用aop：目的是给已经存在的一些类和方法，增加额外的功能。前提是不改变原来的类的代码。</p><p>使用AspectJ实现Aop的基本步骤：</p><ol><li><p>新建Maven项目</p></li><li><p>加入依赖</p><ul><li><p>spring依赖</p></li><li><p>aspectJ依赖</p></li><li><p>junit单元测试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--  aspectj  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建目标类：接口和他的实现类。</p><p> 要做的是给类中的方法增加功能。</p></li><li><p>创建切面类：就是一个普通类，有如下几个要求：</p><ul><li><p>在类的上面加上注解 @AspectJ</p></li><li><p>在类中定义方法，方法就是切面要执行的功能代码。</p><p>在方法的上面加入AspectJ中的通知注解，例如@Before</p><p>还需要指定切入点的表达式execution()</p></li></ul></li><li><p>创建spring的配置文件：声明对象，把对象交给容器统一管理(声明对象可以使用注解或者xml配置文件<bean>)</bean></p><ul><li><p>声明目标对象</p></li><li><p>声明切面类对象</p></li><li><p>声明AspectJ框架中的自动代理生成器标签。</p><p>自动代理生成器：用来完成代理对象的自动创建功能的。</p></li></ul></li><li><p>创建测试类，从spring容器中获取目标对象（实际就是代理对象）</p><p> 通过代理执行方法，实现aop的功能增强</p></li></ol><h1 id="Before前置通知-方法有JoinPoint参数"><a href="#Before前置通知-方法有JoinPoint参数" class="headerlink" title="@Before前置通知-方法有JoinPoint参数"></a>@Before前置通知-方法有JoinPoint参数</h1><p>在目标方法执行之前执行。被注解为前置通知的方法，可以包含一个JoinPoint类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。</p><p>不光前置通知的方法，可以包含一个JoinPoint类型参数，所有的通知方法均可包含该参数。</p><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p>首先是目标类的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.ba01;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给doSome方法增加一个功能，在doSome()执行之前，输出方法的执行时间</span></span><br><span class="line">        System.out.println(<span class="string">"=====目标方法doSome()执行====="</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.ba01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 是AspectJ框架中的注解</span></span><br><span class="line"><span class="comment"> * 作用：表示当前类是切面类</span></span><br><span class="line"><span class="comment"> * 切面类：是用来给业务方法增加功能的类，在这个类中有切面的功能代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法，方法是实现切面功能的。</span></span><br><span class="line"><span class="comment">     * 方法的定义要求：</span></span><br><span class="line"><span class="comment">     *  1、共有方法 public</span></span><br><span class="line"><span class="comment">     *  2、方法无返回值</span></span><br><span class="line"><span class="comment">     *  3、方法名称自定义</span></span><br><span class="line"><span class="comment">     *  4、可以有参数，可以无参数。若有参数，不是自定义的，是有几个参数类型可以使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>:前置通知注解</span></span><br><span class="line"><span class="comment">     *  属性：value，是切入点表达式，表达切面的功能执行的位置。</span></span><br><span class="line"><span class="comment">     *  特点：</span></span><br><span class="line"><span class="comment">     *      1.在目标方法前先执行</span></span><br><span class="line"><span class="comment">     *      2.不会改变目标方法的执行结果</span></span><br><span class="line"><span class="comment">     *      3.不会影响目标方法的执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(public void com.thorine.ba01.SomeServiceImpl.doSome(String,Integer))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 就是切面要执行的功能代码</span></span><br><span class="line">        System.out.println(<span class="string">"前置通知，切面功能：在目标方法之前输出执行时间："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring配置文件 ApplicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  把对象交给spring容器，由spring容器统一创建，管理对象  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  声明目标对象  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someService"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba01.SomeServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明切面类对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.thorine.ba01.MyAspect"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明自动代理生成器：使用aspectJ框架内部的功能，创建目标对象的代理对象。</span></span><br><span class="line"><span class="comment">        创建代理对象是在内存中实现的，修改目标对象的内存中的结构。创建为代理对象</span></span><br><span class="line"><span class="comment">        所以目标对象就是被修改后的代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        aop:aspectj-autoproxy:会把spring容器中的所有的目标对象，一次性都生成代理对象</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在测试类中创建对象，测试目标方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String config = <span class="string">"applicationContext.xml"</span>;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);</span><br><span class="line">    <span class="comment">// 从容器中获取目标对象</span></span><br><span class="line">    SomeService proxy = (SomeService) ctx.getBean(<span class="string">"someService"</span>);</span><br><span class="line">    <span class="comment">// 通过代理的对象执行方法，实现目标方法执行时，增强了功能</span></span><br><span class="line">    proxy.doSome(<span class="string">"zs"</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，得到增强功能了的目标方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AspectJ的Spring实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://iceWind-R.github.io/categories/Web/"/>
    
    
      <category term="Spring" scheme="http://iceWind-R.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring_01(Spring入门)</title>
    <link href="http://icewind-r.github.io/2020/11/09/Spring-01/"/>
    <id>http://icewind-r.github.io/2020/11/09/Spring-01/</id>
    <published>2020-11-09T11:24:21.000Z</published>
    <updated>2020-12-28T05:57:18.696Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 入门。</p><a id="more"></a><hr><p>Spring 全家桶：spring，springMVC，Spring Boot，Spring Cloud，它们都是框架，负责Java开发的各个方面。先开始学习最基础的Spring。</p><h1 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h1><p>优点：减轻对项目模块的管理，类和类之间的管理，帮助开发人员创建对象，管理对象之间的关系。</p><p>Spring核心技术：IOC，AOP。能实现模块之间、类之间的解耦合。</p><p>spring是一个开源组织，有很多项目，在官网中可以看到有如下project，每一个project就是一个开源框架。</p><img src="/2020/11/09/Spring-01/1.png" class><p>我们学习的spring框架，就是其中的spring framework。</p><h2 id="Spring-优点"><a href="#Spring-优点" class="headerlink" title="Spring 优点"></a>Spring 优点</h2><ul><li><strong>轻量</strong>：核心功能依赖的jar包少，总共3M左右。且占用资源少。</li><li><strong>解耦合</strong>：针对接口编程，提供了IOC控制反转，由容器管理对象之间的依赖关系。原来在程序代码中的对象创建方式，现在由容器完成。</li><li><strong>AOP</strong>：进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</li><li>方便集成各种优秀的框架：Spring对一些优秀的框架提供了直接的支持。</li><li>声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无须手动编程。</li><li>方便程序的测试：Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。</li></ul><h1 id="二、Spring体系结构详解"><a href="#二、Spring体系结构详解" class="headerlink" title="二、Spring体系结构详解"></a>二、Spring体系结构详解</h1><p>Spring框架采用分层架构，根据不同的功能被划分成了多个模块，这些模块大体可分为 Data Access/Integration、Web、AOP、Aspects、Messaging、Instrumentation、Core Container 和 Test。</p><img src="/2020/11/09/Spring-01/1.gif" class><p>图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。</p><h2 id="1-Data-Access-Integration（数据访问／集成）"><a href="#1-Data-Access-Integration（数据访问／集成）" class="headerlink" title="1. Data Access/Integration（数据访问／集成）"></a>1. Data Access/Integration（数据访问／集成）</h2><p>数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p><ul><li>JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。</li><li>ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、<a href="http://c.biancheng.net/hibernate/" target="_blank" rel="noopener">Hibernate</a> 和 iBatis 提供了的集成层。</li><li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li><li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li><li>Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li></ul><h2 id="2-Web-模块"><a href="#2-Web-模块" class="headerlink" title="2. Web 模块"></a>2. Web 模块</h2><p>Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。</p><ul><li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li><li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li><li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li><li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li></ul><h2 id="3-Core-Container（核心容器）"><a href="#3-Core-Container（核心容器）" class="headerlink" title="3. Core Container（核心容器）"></a>3. Core Container（核心容器）</h2><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p><ul><li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li><li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li><li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li><li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li></ul><h2 id="4-其他模块"><a href="#4-其他模块" class="headerlink" title="4. 其他模块"></a>4. 其他模块</h2><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p><ul><li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li></ul><h1 id="三、Spring-IOC-控制反转"><a href="#三、Spring-IOC-控制反转" class="headerlink" title="三、Spring IOC 控制反转"></a>三、Spring IOC 控制反转</h1><p>控制反转（IoC，Inversion of Control），指将把对象的创建、赋值、管理工作都交给代码之外的容器实现。</p><p>控制：创建对象，对象的属性赋值，对象之间的关系管理。</p><p>正转：使用new关键字构造方法创建对象，开发人员主动管理对象。</p><p>反转：把原来的开发人员管理创建对象的权限转移给代码之外的容器实现，由容器代替开发人员管理对象。</p><p>容器：是一个服务器软件，一个框架，Spring就是这样一个框架。</p><p>为什么IoC：减少对代码的改动，实现解耦合。</p><h2 id="IoC体现"><a href="#IoC体现" class="headerlink" title="IoC体现"></a>IoC体现</h2><p>Tomcat作为容器，里面存放着Servlet，Listener，Filter等对象，不用手动创建对象。</p><h2 id="IoC技术实现"><a href="#IoC技术实现" class="headerlink" title="IoC技术实现"></a>IoC技术实现</h2><p>使用DI（Dependency Injection）实现IoC的功能。</p><p>DI：依赖注入，只需要在程序中提供所使用对象的名称就可以由 DI 自动创建，赋值和查找。使用的是反射机制。</p><h1 id="四、Spring-的第一个程序"><a href="#四、Spring-的第一个程序" class="headerlink" title="四、Spring 的第一个程序"></a>四、Spring 的第一个程序</h1><p>步骤：</p><p>1、创建Maven项目，导入spring 的相关依赖</p><p>2、创建类（接口类和其实现类），和没有使用框架一样，普通的类。</p><p>3、创建spring需要使用的配置文件：声明类的信息，这些类由spring创建和管理。</p><p>4、测试对象创建</p><h2 id="1、新建Maven工程"><a href="#1、新建Maven工程" class="headerlink" title="1、新建Maven工程"></a>1、新建Maven工程</h2><p>导入spring 的 maven依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、创建接口和实现类"><a href="#2、创建接口和实现类" class="headerlink" title="2、创建接口和实现类"></a>2、创建接口和实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SomeService 的构造方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了SomeServiceImpl的 doSome() 方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、创建配置文件"><a href="#3、创建配置文件" class="headerlink" title="3、创建配置文件"></a>3、创建配置文件</h2><p>给Maven项目创建resources资源目录，在该目录下创建spring的xml配置文件，依赖导入成功后，会出现spring xml提示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        告诉spring创建对象</span></span><br><span class="line"><span class="comment">        声明bean，就是告诉spring创建某个类的对象</span></span><br><span class="line"><span class="comment">        id：对象的自定义名称，符合Java的命名规则，是唯一的。</span></span><br><span class="line"><span class="comment">        class：类的全限定名称（必须是类，不是接口）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someService"</span> <span class="attr">class</span>=<span class="string">"com.thorine.service.impl.SomeServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        完成 ：SomeService service = new SomeServiceImpl();</span></span><br><span class="line"><span class="comment">        spring 是把创建好的对象放入map集合中，spring框架有一个map存放对象</span></span><br><span class="line"><span class="comment">        springMap.put(id的值, 对象);</span></span><br><span class="line"><span class="comment">        例如：springMap.put(someService, new SomeServiceImpl());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：一个bean标签声明一个对象，想声明多个对象，就用多个bean标签</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--表示创建已存在类的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDate"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、测试对象创建"><a href="#4、测试对象创建" class="headerlink" title="4、测试对象创建"></a>4、测试对象创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * spring创建对象的时间：在创建spring的容器时，会创建配置文件中的所有对象</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 使用spring容器创建对象</span></span><br><span class="line">       <span class="comment">// 指定spring配置文件的名称</span></span><br><span class="line">       String config = <span class="string">"beans.xml"</span>;</span><br><span class="line">       <span class="comment">// 创建表示spring容器的对象，ApplicationContext，就是表示Spring容器，通过容器获取对象</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//ClassPathXmlApplicationContext 表示从类路径中加载spring的配置文件</span></span><br><span class="line">       <span class="comment">// 执行该语句则创建目标对象，执行SomeService的构造函数</span></span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从容器中获取某个对象，你要调用对象的方法</span></span><br><span class="line">       <span class="comment">// getBean("配置文件中的bean的id值")</span></span><br><span class="line">       SomeService service = (SomeService) ac.getBean(<span class="string">"someService"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用spring创建好的对象</span></span><br><span class="line">       service.doSome();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 获取spring容器中 java 对象信息</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String config = <span class="string">"beans.xml"</span>;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用spring提供的方法，获取容器中定义的对象的数量</span></span><br><span class="line">       <span class="keyword">int</span> count = ac.getBeanDefinitionCount();</span><br><span class="line">       System.out.println(<span class="string">"容器中定义对象的数量："</span> + count);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 容器中每个对象的名称</span></span><br><span class="line">       String[] names = ac.getBeanDefinitionNames();</span><br><span class="line">       <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 获取一个非自定义类的对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String config = <span class="string">"beans.xml"</span>;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);</span><br><span class="line"></span><br><span class="line">       Date myDate = (Date) ac.getBean(<span class="string">"myDate"</span>);</span><br><span class="line">       System.out.println(<span class="string">"Date对象："</span>+myDate);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注：</p><p>1、什么样的对象放入spring 容器中？</p><p>​        （1）dao类，service类，controller类，工具类等（使用xml配置文件 或 注解方法 创建对象）</p><p>​        （2）spring中的对象默认都是单例的，在容器中叫这个名称的对象只有一个</p><p>2、不放入spring容器中的对象</p><p>​        （1）实体类对象，实体类对象来自于数据库</p><p>​        （2）servlet、listener、filter等由tomcat创建的对象</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 入门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://iceWind-R.github.io/categories/Web/"/>
    
    
      <category term="Spring" scheme="http://iceWind-R.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
