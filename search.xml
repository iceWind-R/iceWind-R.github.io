<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的考研必看</title>
    <url>/2020/09/13/%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E5%BF%85%E7%9C%8B/</url>
    <content><![CDATA[<p>为什么考研？自己适合考研吗？这两个问题，想要考研的你，真的思考过吗？</p>
<a id="more"></a>

<hr>
<p>给自己定的初步目标：<strong>中下游211本专业</strong></p>
<p>说到需求，当然就是你考研是想要达到什么目的。我举几个例子，假如说你打算将来考选调生，那么985院校就是目标，专业视具体要求而定；假如你想回老家考个公务员，那选择一个匹配岗位的学校和专业即可；假如你想进入某些知名企业，那么应该调研清楚它的目标院校是什么档次，然后作出选择。</p>
<p>先说竞争对手方面的因素，这一方面主要从目标院校历年的考生和录取情况来评估。</p>
<p>1.初试科目是什么</p>
<p>2.专业课参考书是什么</p>
<p>3.最近三年的分数线（这一定要看地区，不要盲目对比，二区的380和北京上海的380完全不是一回事）</p>
<p>4.最近三年的报录比</p>
<p>5.报考学生的生源大概水平</p>
<p>6.复试什么形式，在总分中占比多少</p>
<p>7.最后实际录取学生的总分及单科分数分布（和其他院校对比，要对比同地区的学校公共课的分数，专业课不具可比性）</p>
<p>8.最后录取学生的本科背景</p>
<p>9.录取学生中二战以以上的学生比例</p>
<p>10.录取的跨校跨专业学生的比例</p>
<p>以上信息都不是能百度的，需要自己去搜集，像5、8、9、10这些问题不需要多么精准，知道大概水平即可。至于怎么搜集，最直接的就是找上一届录取的前辈。<strong>（最近很多人私信我去哪里找已经录取的前辈，大家可以下载一个APP叫做经验超市，这个APP是由北大的几位考研学长开发的，可以去上面看看有没有学长学姐，上面的学长学姐都是经过身份认证的。）</strong></p>
<p>自身因素方面：</p>
<p>1.高中学习状态及高考成绩（高中是否尽力学习，高考是正常发挥还是失常或者超常发挥。这一点可以衡量潜在的学习能力，毕竟高考和考研都是类似的应试）</p>
<p>2.本科院校及专业（正常录取还是填志愿失误造成滑档）</p>
<p>3.本科成绩（结合自己学习努力程度来看）</p>
<p>4.个人学习习惯和自制力（十几年的读书经历，想必自己心中应该有数。在考研这种靠自己自律的环境下，能够发生重大改变的人少之又少，不要高估自己的决心和毅力）</p>
<p>5.考研时间（自己有多少时间准备，本科课程能不能应付，学校的琐事会不会消耗太多时间）</p>
<p>6.自身心态（自己心态建设做的怎么样，是不是过于焦虑和敏感，是不是能够承压）</p>
<p>7.公共课基础如何</p>
<p>8.是否跨专业，专业课是否零基础</p>
<p><strong>人生终究是回归均值的一个过程，不要以为自己能够轻易的突破。考研之前请认真思考，把握好自己的定位、需求、成本和风险承担能力。每个人的天赋，成长过程，家庭环境都是不同的，即便要向命运挑战，也要结合自己的实际情况。</strong></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase_02(HBase的安装使用)</title>
    <url>/2020/10/16/HBase-02/</url>
    <content><![CDATA[<p>HBase的安装和部署，和基本命令使用。</p>
<hr>
<h1 id="一、HBase的安装部署"><a href="#一、HBase的安装部署" class="headerlink" title="一、HBase的安装部署"></a>一、HBase的安装部署</h1><h2 id="Zookeeper的正常部署"><a href="#Zookeeper的正常部署" class="headerlink" title="Zookeeper的正常部署"></a>Zookeeper的正常部署</h2><p>首先保证zookeeper集群的正常部署，并启动：</p>
<p>在三台虚拟机的zookeeper安装目录的bin目录下，分别使用命令启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<h2 id="Hadoop正常部署"><a href="#Hadoop正常部署" class="headerlink" title="Hadoop正常部署"></a>Hadoop正常部署</h2><p>Hadoop集群的正常部署并启动。</p>
<h2 id="HBase的下载安装"><a href="#HBase的下载安装" class="headerlink" title="HBase的下载安装"></a>HBase的下载安装</h2><p>HBase使用的是1.3.1 版本，下载地址 <a href="http://archive.apache.org/dist/hbase/1.3.1/" target="_blank" rel="noopener">http://archive.apache.org/dist/hbase/1.3.1/</a> ，下载hbase-1.3.1-bin.tar.gz 压缩包，上传到bigdata1虚拟机，并解压到相应目录 ( /export/servers/ ) 。</p>
<h2 id="Hbase配置文件的修改"><a href="#Hbase配置文件的修改" class="headerlink" title="Hbase配置文件的修改"></a>Hbase配置文件的修改</h2><p>HBase的配置文件都在 conf 目录下，这里我们主要对以下几个文件进行修改。</p>
<h3 id="regionservers"><a href="#regionservers" class="headerlink" title="regionservers"></a>regionservers</h3><p>即RegionServer，region所在的集群，这里写上我们的三台虚拟机主机名，如下。</p>
<h3 id="hbase-env-sh"><a href="#hbase-env-sh" class="headerlink" title="hbase-env.sh"></a>hbase-env.sh</h3><p>改三个位置，第一个是 27行左右的 JAVA_HOME，去掉注释，改为本地配好的 JDK 地址。</p>
<p>然后是45行左右，去掉两个export，因为在jdk1.8时已经不再需要。</p>
<p>第三个地方：128行左右，取消使用HBase内置的zookeeper，很不方便，而且会与我们自己的zookeeper冲突，由true改为法false。</p>
<h3 id="hbase-site-xml"><a href="#hbase-site-xml" class="headerlink" title="hbase-site.xml"></a>hbase-site.xml</h3><p>增加configuration 内的引用，代码如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://bigdata1:8020/HBase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 默认端口号：16000，默认的web访问：16010 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>16000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata1,bigdata2,bigdata3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/export/servers/zookeeper-3.4.9/zkdatas<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="软连接Hadoop配置文件到HBase"><a href="#软连接Hadoop配置文件到HBase" class="headerlink" title="软连接Hadoop配置文件到HBase"></a>软连接Hadoop配置文件到HBase</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /export/servers/hadoop-2.7.7/etc/hadoop/core-site.xml /export/servers/hbase-1.3.1/conf/core-site.xml</span><br><span class="line"></span><br><span class="line">ln -s /export/servers/hadoop-2.7.7/etc/hadoop/hdfs-site.xml /export/servers/hbase-1.3.1/conf/hdfs-site.xml</span><br></pre></td></tr></table></figure>

<h2 id="HBase远程发送到集群其他主机"><a href="#HBase远程发送到集群其他主机" class="headerlink" title="HBase远程发送到集群其他主机"></a>HBase远程发送到集群其他主机</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r hbase-1.3.1 bigdata2:$PWD</span><br><span class="line">scp -r hbase-1.3.1 bigdata3:$PWD</span><br></pre></td></tr></table></figure>

<h2 id="HBase服务的启动"><a href="#HBase服务的启动" class="headerlink" title="HBase服务的启动"></a>HBase服务的启动</h2><p>首先对bin目录下的启动方式做个简单介绍：</p>
<img src="/2020/10/16/HBase-02/1.png" class>

<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p>在主机bigdata1的 HBase  bin目录下，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;hbase-daemon.sh start master</span><br></pre></td></tr></table></figure>

<p>启动后，即可访问16010端口查看Web版的HBase。</p>
<p>启动regionserver。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>

<p>可以看到，region为 启动的bigdata1。</p>
<img src="/2020/10/16/HBase-02/2.png" class>

<p>我们可以通过 <code>./stop-hbase.sh</code> 关闭HBase，但此命令只能在master上使用。</p>
<p>集群启动./start-hbase.sh，此命令在那个主机上启动，则该主机就默认为master。</p>
<blockquote>
<p>提示：如果集群之间的节点时间不同步，会导致regionserver无法启动，抛出ClockOutOfSyncException 异常。</p>
</blockquote>
<h1 id="二、HBase-Shell操作"><a href="#二、HBase-Shell操作" class="headerlink" title="二、HBase Shell操作"></a>二、HBase Shell操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="进入HBase客户端命令行"><a href="#进入HBase客户端命令行" class="headerlink" title="进入HBase客户端命令行"></a>进入HBase客户端命令行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hbase shell</span><br></pre></td></tr></table></figure>

<h3 id="查看帮助命令"><a href="#查看帮助命令" class="headerlink" title="查看帮助命令"></a>查看帮助命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; help</span><br></pre></td></tr></table></figure>

<img src="/2020/10/16/HBase-02/2.png" class>

<p>ddl是对表的操作，dml是对数据的操作。</p>
<h3 id="查看当前数据库有哪些表"><a href="#查看当前数据库有哪些表" class="headerlink" title="查看当前数据库有哪些表"></a>查看当前数据库有哪些表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase(main):002:0&gt; list</span><br></pre></td></tr></table></figure>

<p>显示为 0，list只能查用户建的表，系统表则查询不到。</p>
<h3 id="使用HBase客户端的注意事项"><a href="#使用HBase客户端的注意事项" class="headerlink" title="使用HBase客户端的注意事项"></a>使用HBase客户端的注意事项</h3><ol>
<li>backspace为删除后面的字符，若想删除前面，则需要按住Ctrl。</li>
<li>不熟悉某个命令，可以输入该命令，直接回车，则会给出提示和例子。</li>
</ol>
<h2 id="DDL（对表的操作）"><a href="#DDL（对表的操作）" class="headerlink" title="DDL（对表的操作）"></a>DDL（对表的操作）</h2><h2 id="DML（对数据的操作）"><a href="#DML（对数据的操作）" class="headerlink" title="DML（对数据的操作）"></a>DML（对数据的操作）</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put 表名, RowKey, 列族:列名, 数据</span><br><span class="line"></span><br><span class="line">put &#39;stu&#39;,&#39;1001&#39;,&#39;info1:name&#39;,&#39;zhangsan&#39;</span><br></pre></td></tr></table></figure>

<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p>查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan 表名</span><br><span class="line">scan &#39;stu&#39;</span><br><span class="line">scan &#39;stu&#39;,&#123;STARTROW&#x3D;&gt;&#39;1001&#39;,STOPROW&#x3D;&gt;&#39;1003&#39;&#125; # 指定查询的范围，从 RowKey 1001 ~ 1003 ，左闭右开，若前或后不写，则代表负无穷 或 正无穷</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get 表名, RowKey, 列族</span><br><span class="line"></span><br><span class="line">get &#39;stu&#39;, &#39;1001&#39;, &#39;info1&#39;</span><br><span class="line">get &#39;stu&#39;, &#39;1001&#39;, &#39;info1:name&#39;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase_01(HBase概念简介)</title>
    <url>/2020/10/15/HBase-01/</url>
    <content><![CDATA[<p>就今天吧，稀里糊涂的，入门学习个HBase！就记些比较重要的、需要重点掌握的知识点吧。别问为什么，死记硬背就完事了！</p>
<a id="more"></a>

<hr>
<h1 id="一、HBase简介"><a href="#一、HBase简介" class="headerlink" title="一、HBase简介"></a>一、HBase简介</h1><h2 id="HBase是什么？"><a href="#HBase是什么？" class="headerlink" title="HBase是什么？"></a>HBase是什么？</h2><p>Hbase是一种NoSQL数据库，这意味着它不像传统的RDBMS数据库那样支持SQL作为查询语言。</p>
<p>HBase是一种构建在HDFS之上的<strong>分布式、面向列</strong>的存储系统。在需要实时读写、随机访问超大规模数据集时，可以使用HBase。</p>
<h2 id="HBase的特点"><a href="#HBase的特点" class="headerlink" title="HBase的特点"></a>HBase的特点</h2><ol>
<li><strong>大</strong>：一个表可以有上亿行，上百万列。</li>
<li><strong>面向列</strong>：面向列表（簇）的存储和权限控制，列（簇）独立检索。</li>
<li><strong>稀疏</strong>：对于为空（NULL）的列，并不占用存储空间，因此，表可以设计的非常稀疏。</li>
<li><strong>无模式</strong>：每一行都有一个可以排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列。</li>
<li><strong>数据多版本</strong>：每个单元中的数据可以有多个版本，默认情况下，版本号自动分配，版本号就是单元格插入时的时间戳。</li>
<li><strong>数据类型单一</strong>：HBase中的数据都是字符串，没有类型。</li>
</ol>
<h1 id="二、数据模型"><a href="#二、数据模型" class="headerlink" title="二、数据模型"></a>二、数据模型</h1><h2 id="1、RowKey"><a href="#1、RowKey" class="headerlink" title="1、RowKey"></a>1、RowKey</h2><p><strong>RowKey</strong> 是一行记录的 <strong>主键</strong> ，用于检索记录数据的。HBase的数据是按照RowKey的 <strong>字典顺序</strong> 进行全局排序的，所有的查询都只能依赖于这一个排序维度。访问 HBase table 中的行，只有三种方式：</p>
<ol>
<li><p>通过单个 <strong>RowKey</strong> 访问。</p>
</li>
<li><p>通过 <strong>RowKey</strong> 的 range 全表扫描。</p>
</li>
<li><p><strong>RowKey</strong> 可以是任意字符串（最大长度是64KB，实际应用中长度一般为 10 ~ 100bytes），在HBase 内部，<strong>RowKey</strong> 保存为字节数组。</p>
</li>
</ol>
<blockquote>
<p> 通过下面一个例子来说明一下” <strong>字典排序</strong> “的原理：</p>
<p>RowKey列表{“abc”, “a”, “bdf”, “cdf”, “def”}按字典排序后的结果为{“a”, “abc”, “bdf”, “cdf”, “defg”}</p>
</blockquote>
<h2 id="2、Row（行）"><a href="#2、Row（行）" class="headerlink" title="2、Row（行）"></a>2、Row（行）</h2><p>HBase表中的每行数据都是一个RowKey和 多个Column（列）组成，数据是按照RowKey的字典顺序存储的。</p>
<h2 id="3、Column（列）"><a href="#3、Column（列）" class="headerlink" title="3、Column（列）"></a>3、Column（列）</h2><p>HBase每个列都由列族和列限定符进行限定，例如info：name , info :  age。建表时，只需要指定列族，而列限定符无需预先定义。</p>
<h2 id="4、Column-Family（列族）"><a href="#4、Column-Family（列族）" class="headerlink" title="4、Column Family（列族）"></a>4、Column Family（列族）</h2><p>如果将Region看成是一个表的 <strong>横向切割</strong> ，那么，一个Region中的数据列的 <strong>纵向切割</strong> ，称之为一个 <strong>Column Family</strong> 。每一个列，都必须归属于一个Column Family，这个归属关系是在写数据时指定的，而不是建表时预先定义。</p>
<h2 id="5、Cell"><a href="#5、Cell" class="headerlink" title="5、Cell"></a>5、Cell</h2><p>Cell 是由 {RowKey，ColumnFamily : Column Qualifier，TimeStamp} 唯一确定的单元。Cell 中的数据是没有类型的，全部是<strong>字节码</strong>形式存储。</p>
<h2 id="6、Region"><a href="#6、Region" class="headerlink" title="6、Region"></a>6、Region</h2><p>HBase中采用了”Range分区”，将Key的完整区间切割成一个个的”Key Range” ，每一个”Key Range”称之为一个Region。</p>
<p>也可以这么理解：将HBase中拥有数亿行的一个大表， <strong>横向切割</strong> 成一个个” <strong>子表</strong> “，这一个个” <strong>子表</strong> “就是 <strong>Region</strong> 。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分到多个server上。 </p>
<p>当一个Region增长到一定大小以后，会自动分裂成两个。</p>
<p>每个region由以下信息标识：</p>
<ol>
<li>&lt; 表名,startRowkey,创建时间&gt;</li>
<li>由目录表(-ROOT-和.META.)记录该region的endRowkey</li>
</ol>
<h2 id="7、TimeStamp（时间戳）"><a href="#7、TimeStamp（时间戳）" class="headerlink" title="7、TimeStamp（时间戳）"></a>7、TimeStamp（时间戳）</h2><p>HBase 中通过 Row 和 Columns 确定的一个存储单元称为 Cell。每个 Cell 都保存着同一份数据的多个版本。 版本通过时间戳来索引，时间戳的类型是 64 位整型。时间戳可以由HBase（在数据写入时自动）赋值，<br>此时时间戳是精确到毫秒的当前系统时间。时间戳也 可以由客户显示赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个 Cell 中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p>
<p>为了避免数据存在过多版本造成的管理（包括存储和索引）负担，HBase 提供了两种数据版本回收方式。 一是保存数据的最后 n 个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<h2 id="8、稀疏矩阵"><a href="#8、稀疏矩阵" class="headerlink" title="8、稀疏矩阵"></a>8、稀疏矩阵</h2><p>HBase中一个表的数据是按照稀疏矩阵的方式组织的，行与行之间也无须遵循一致的定义，而这种定义恰好符合半结构化数据或非结构化数据的特点。</p>
<p>HBase定义表是只需要声明 *<em>列族 *</em>即可，不需要声明具体的列，这意味着，往HBase写入数据时，字段可以 动态、按需 指定。</p>
<h2 id="9、Store"><a href="#9、Store" class="headerlink" title="9、Store"></a>9、Store</h2><p>每一个region由一个或多个store组成，至少是一个store，hbase会把一起访问的数据放在一个store里面，即为每个 ColumnFamily建一个store，如果有几个ColumnFamily，也就有几个Store。一个Store由一个memStore和0或者 多个StoreFile组成。 HBase以store的大小来判断是否需要切分region</p>
<img src="/2020/10/15/HBase-01/1.png" class>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>Hregion是Hbase中分布式存储和负载均衡的最小单元。最小单元就表示不同的Hregion可以分布在不同的HRegion server上。但一个Hregion是不会拆分到多个server上的。</p>
<img src="/2020/10/15/HBase-01/3.png" class>

<p>HRegion虽然是分布式存储的最小单元，但并不是存储的最小单元。HRegion由一个或者多个Store组成，每个store保存一个columns family。每个Strore又由一个memStore和0至多个StoreFile组成。如图：</p>
<img src="/2020/10/15/HBase-01/4.png" class>

<p>StoreFile以HFile格式保存在HDFS上。</p>
<h1 id="三、HBase系统架构"><a href="#三、HBase系统架构" class="headerlink" title="三、HBase系统架构"></a>三、HBase系统架构</h1><img src="/2020/10/15/HBase-01/5.png" class>

<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>包含访问hbase的接口，client维护着一些cache来加快对hbase的访问，比如regione的位置信息。</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>1 保证任何时候，集群中只有一个master</p>
<p>2 存贮所有Region的寻址入口。</p>
<p>3 实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master</p>
<p>4 存储Hbase的schema,包括有哪些table，每个table有哪些column family</p>
<h2 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h2><p>1 Region server维护Master分配给它的region，处理对这些region的IO请求</p>
<p>2 Region server负责切分在运行过程中变得过大的region</p>
<p>Data： get，put，delete （HBase通过时间戳控制每条数据，get最新数据，put写入数据，若没有此条数据则代表插入，有则代表修改，delete删除数据）</p>
<p>Region：splitRegion（切片），compactRegion（合并）</p>
<h2 id="Master（高可用）"><a href="#Master（高可用）" class="headerlink" title="Master（高可用）"></a>Master（高可用）</h2><p>1 为Region server分配region</p>
<p>2 负责region server的负载均衡</p>
<p>3 发现失效的region server并重新分配其上的region</p>
<p>4 GFS上的垃圾文件回收</p>
<p>5 处理schema更新请求</p>
<p>Table：create，alter，delete</p>
<p>RegionServer：分配region给每个regionServer，监控每个regionServer的状态</p>
<img src="/2020/10/15/HBase-01/2.png" class>

<blockquote>
<p>RegionServer管理着Region，对数据的操作，DML。</p>
<p>Master管理表的增删改查，以及Region的维护信息，DDL。</p>
</blockquote>
<p><strong>总结</strong></p>
<p>可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，数据读写访问regione server），master仅仅维护者table和region的元数据信息，负载很低。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>大三上_第3周总结</title>
    <url>/2020/10/07/%E5%A4%A7%E4%B8%89%E4%B8%8A-%E7%AC%AC3%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>10.7 ~ 10.10 日</p>
<hr>
<p>今天上午逃了刘丹的四节课，想着好好做建民的重大需求，但是竟然，一点进度都没有。明明有着超快的网络，但还是，唉。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel表格操作</title>
    <url>/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Excel 的重要性不言而喻，学会使用可以使自己的效率大大提高，今天开始学习，做此纪录。</p>
<a id="more"></a>

<hr>
<h1 id="Excel入门"><a href="#Excel入门" class="headerlink" title="Excel入门"></a>Excel入门</h1><p>1、<strong>开始</strong> 菜单的 <strong>合并后居中</strong>，可以实现跨单元格的合并居中。</p>
<p>2、自动匹配单元格长度，双击<strong>表头</strong>，<strong>列头</strong>，可以使该行（列）自动匹配本行（列）最长单元格。</p>
<p>3、可以选中若干列，点击<strong>开始</strong>，<strong>单元格样式</strong>，对选中的标题进行样式改变。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/1.png" class>

<p>4、可以选中所有列，使其所有单元格 宽度 相同。（对行同样适用）</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/1.gif" class>

<p>5、可以快速产生相同规律（等差数列）的一组数据，选取一个单元格或一组单元格，右下角鼠标变为 “+”，拖动即可实现。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/2.gif" class>

<p>6、关于<strong>日期</strong>操作</p>
<ul>
<li><p>日期如果手动输入，最好采用excel可以识别的格式，即 “/” 标识，如：2020/9/22</p>
</li>
<li><p>如果想插入当前日期，可以使用快捷键 ctrl + ;(分号)</p>
</li>
<li><p>并且可以在当前单元格右键选择 <strong>设置单元格格式</strong>，进行日期格式的选择。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/2.png" class>

<p>注意：若出现全部“#”，则代表当前单元格长度不够，未能显示，只需双击表头的间隔处，使单元格匹配内容长度即可。</p>
</li>
<li><p>同样，可以选择单元格右下角的 +，进行依次递增的日期。</p>
</li>
</ul>
<p>7、关于数学公式计算。例如上例中的总金额 = 单价 * 数量，这时我们可以用excel的计算能力，我们 在总金额单元格 输入等于号（=），然后单击 单价 之后 输入乘号 ，然后点击 数量，输入回车即可得到计算结果。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/3.gif" class>

<p>8、可以改变数字的显示。例如金额，可以加上金额符号，并指定数字小数位数。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/3.png" class>

<p>9、格式刷的使用，选中被格式的单元格，再选中待格式的单元格即可将复制前者的格式。</p>
<p>10、打印表格。可以点击左上角的<strong>打印预览和打印</strong>，在默认情况下只会打印数据，而表格线等则不会打印，可以在 <strong>页面布局</strong>，勾选 <strong>网格线</strong> 下的 <strong>打印</strong> 按钮。即可在打印时出现网格线。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/4.png" class>

<p>11、关于表格的格线操作。快捷键 按住 <strong>shift</strong>，选中单元格删除格线，<strong>Esc</strong> 退出。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/4.gif" class>

<p>12、背景图片。在页面布局中添加背景，可以取消<strong>网格线</strong>的<strong>查看</strong>按钮，来不显示图片上的表格线。也可以删除背景。</p>
<p>13、函数（自动求和 等）。在生成总和的单元格上，点击该按钮，选择被求和的所有单元格，然后enter，即可得到结果。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/5.png" class>

<p>14、冻结表格栏 与 拆分视窗。在<strong>视图</strong>选项卡操作。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/5.gif" class>

<p>15、排序。在排序中，选择待排序列的一个单元格即可，不要选择多个。在 <strong>开始</strong> 的右侧，<strong>排序和筛查</strong>。</p>
<p>要指定多层排序，可以在 <strong>排序和筛查</strong> 中选择 <strong>自定义排序</strong>，点击 <strong>添加条件</strong>，实现多条件排序。如下界面。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/6.png" class>

<p>16、自定义序列，在上面的自定义序列中，选择排序次序为自定义，跳到下面选项卡。</p>
<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/7.png" class>，输入自定义顺序，以回车间隔。

<img src="/2020/09/22/Excel%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/6.gif" class>]]></content>
      <categories>
        <category>Offices</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>C++文本操作</title>
    <url>/2020/09/09/C-%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本篇总结 C++ 的文本操作，即C++文件和流的概念。</p>
<a id="more"></a>

<hr>
<h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>到目前为止，我们使用了iostream标准库，它提供了cin 和 cout 方法分别用于从<strong>标准输入读取流</strong>和向<strong>标准输入写入流</strong>。</p>
<img src="/2020/09/09/C-%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C/1.gif" class>

<p>如何从<strong>标准输入读取流</strong>和向<strong>标准输入写入流</strong>？这就需要用到 C++ 中另一个标准库fstream，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ofstream</td>
<td>该数据类型表示输出文件流，用于创建文件并向文件写入信息</td>
</tr>
<tr>
<td>ifstream</td>
<td>该数据类型表示输入文件流，用于从文件读取信息</td>
</tr>
<tr>
<td>fstream</td>
<td>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在C++中进行文件处理，必须在 C++ 代码中包含头文件 <code>&lt;iostream&gt;</code> 和 <code>&lt;fstream&gt;</code></p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong>对象都可以用来打开文件进行<strong>写</strong>操作；如果只需要打开文件进行<strong>读</strong>操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是open()函数的标准语法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，open()成员函数的第一参数指定要打开的文件名字，第二个参数指定打开文件的模式。</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::app</td>
<td>追加模式，所有写入都追加到文件末尾</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后将文件指针位置定位到文件末尾</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开之前被截断，即把文件长度设为0.</td>
</tr>
</tbody></table>
<p>可以把以上两种或两种以上的模式结合使用，以“或”运算（“|”）的方式。例如：如果想要以写入模式打开文件，并希望截断文件，以防文件已经存在，那么可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">outFile.<span class="built_in">open</span>( <span class="string">"file.dat"</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似的，如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream afile;</span><br><span class="line">afile.<span class="built_in">open</span>(<span class="string">"file.dat"</span>, ios::out | ios::in)</span><br></pre></td></tr></table></figure>

<p>很多程序中，可能会碰到ofstream out(“Hello.txt”), ifstream in(“…”),fstream foi(“…”)这样的的使用，并没有显式的去调用open（）函数就进行文件的操作，直接调用了其默认的打开方式，因为在stream类的构造函数中调用了open()函数,并拥有同样的构造函数，所以在这里可以直接使用流对象进行文件的操作，默认方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"..."</span>, ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"..."</span>, ios::in)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">foi</span><span class="params">(<span class="string">"..."</span>, ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>使用close() 函数关闭打开的文件，它是 fstream，ifstream 和 ofstream 对象的一个成员。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>我们使用 流插入运算符（ &lt;&lt; ）向文件写入信息。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>我们使用 流提取运算符（ &gt;&gt; ）从文件读取信息。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面给出一个例子，读取hello.txt文件中的字符串，写入out.txt中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">ifstream <span class="title">myfile</span><span class="params">(<span class="string">"hello.txt"</span>)</span></span>; </span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"out.txt"</span>, ios::app)</span></span>; </span><br><span class="line">    <span class="built_in">string</span> temp; </span><br><span class="line">    <span class="keyword">if</span> (!myfile.is_open()) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"未成功打开文件"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(getline(myfile,temp)) </span><br><span class="line">    &#123; </span><br><span class="line">        outfile &lt;&lt; temp; </span><br><span class="line">        outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    myfile.<span class="built_in">close</span>(); </span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中getline(stream, string)函数的功能：按行从输入流中读入字符，存到string变量</p>
<ul>
<li><p>直到出现以下情况为止：</p>
</li>
<li><p>读入了文件结束标志</p>
</li>
<li><p>读到一个新行</p>
</li>
<li><p>达到字符串的最大长度</p>
</li>
</ul>
<p>如果getline()没有读入字符，将返回false，可用于判断文件是否结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v, w, weight;</span><br><span class="line">ifstream infile;   <span class="comment">//输入流</span></span><br><span class="line"> </span><br><span class="line">infile.<span class="built_in">open</span>(<span class="string">"data.txt"</span>, ios::in); </span><br><span class="line"><span class="keyword">if</span>(!infile.is_open ())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Open file failure"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof())            <span class="comment">// 到达文件末尾时返回true</span></span><br><span class="line">&#123;</span><br><span class="line">    infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">"\t"</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> infile.<span class="built_in">close</span>();   <span class="comment">//关闭文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码的功能是读取data.txt文件的数据，注意，此时要求data.txt文件中的数据是三个一行，每个数据用空格或换行符隔开。</p>
</blockquote>
<h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p> 文件指针位置在c++中的用法：</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::beg</td>
<td>文件头</td>
</tr>
<tr>
<td>ios::end</td>
<td>文件尾</td>
</tr>
<tr>
<td>ios::cur</td>
<td>当前位置</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">file.seekg(<span class="number">0</span>,ios::beg);   <span class="comment">//让文件指针定位到文件开头 </span></span><br><span class="line">file.seekg(<span class="number">0</span>,ios::<span class="built_in">end</span>);   <span class="comment">//让文件指针定位到文件末尾 </span></span><br><span class="line">file.seekg(<span class="number">10</span>,ios::cur);   <span class="comment">//让文件指针从当前位置向文件末方向移动10个字节 </span></span><br><span class="line">file.seekg(<span class="number">-10</span>,ios::cur);   <span class="comment">//让文件指针从当前位置向文件开始方向移动10个字节 </span></span><br><span class="line">file.seekg(<span class="number">10</span>,ios::beg);   <span class="comment">//让文件指针定位到离文件开头10个字节的位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：移动的单位是字节，而不是行</strong>。</p>
<h2 id="状态标志符的验证-Verification-of-state-flags"><a href="#状态标志符的验证-Verification-of-state-flags" class="headerlink" title="状态标志符的验证(Verification of state flags)"></a>状态标志符的验证(Verification of state flags)</h2><p>除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回值）：</p>
<ul>
<li><p><strong>bad()</strong></p>
<p>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</p>
</li>
<li><p><strong>fail()</strong></p>
<p>除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</p>
</li>
<li><p><strong>eof()</strong></p>
<p>如果读文件到达文件末尾，返回true。</p>
</li>
<li><p><strong>good()</strong></p>
<p>这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。</p>
</li>
</ul>
<p>要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</p>
<h1 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h1><p>string头文件定义了三个类型来支持内存IO，istringstream向string读取数据，ostringstream从string写数据，stringstream既可从string读取数据也可向string写数据，就像string是一个IO流一样。</p>
<h2 id="istringstream的用法"><a href="#istringstream的用法" class="headerlink" title="istringstream的用法"></a>istringstream的用法</h2><p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;    //使用istringstream所需要的头文件 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Hello world! I am Lee"</span>; </span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;    <span class="comment">//将is绑定到str</span></span><br><span class="line">    <span class="built_in">string</span> s; </span><br><span class="line">    <span class="keyword">while</span> (is &gt;&gt; s) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于把一个句子拆分成单词，联系到前文提到的从文件中读取string的方法，如果读取到的string对象为一个句子，包含很多单词，那么我们就可以运用这种方法把string对象拆分开来。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">world!</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">Lee</span><br></pre></td></tr></table></figure>

<h2 id="ostringstream的用法"><a href="#ostringstream的用法" class="headerlink" title="ostringstream的用法"></a>ostringstream的用法</h2><p>​    ostringstream同样是由一个string对象构造而来，ostringstream类向一个string插入字符。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;    //使用ostringstream所需要的头文件 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">ostringstream</span> ostr;  </span><br><span class="line">   <span class="comment">// ostr.str("abc");//如果构造的时候设置了字符串参数,那么增长操作的时候不会从结尾开始增加,而是修改原有数据,超出的部分增长  </span></span><br><span class="line">    ostr.<span class="built_in">put</span>(<span class="string">'d'</span>);  </span><br><span class="line">    ostr.<span class="built_in">put</span>(<span class="string">'e'</span>);  </span><br><span class="line">    ostr&lt;&lt;<span class="string">"fg"</span>;    </span><br><span class="line">    <span class="built_in">string</span> gstr = ostr.str();  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;gstr &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例代码中，我们通过put()或者左移操作符可以不断向ostr插入单个字符或者是字符串，通过str()函数返回增长过后的完整字符串数据，但值 得注意的一点是，当构造的时候对象内已经存在字符串数据的时候，那么增长操作的时候不会从结尾开始增加,而是修改原有数据,超出的部分增长。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>文本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>停歇_在此靠岸</title>
    <url>/2020/09/04/%E5%81%9C%E6%AD%87-%E5%9C%A8%E6%AD%A4%E9%9D%A0%E5%B2%B8/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=522353195&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_11(函数,数据压缩存储,调优)</title>
    <url>/2020/08/29/%E5%A4%A7%E6%95%B0%E6%8D%AE-11/</url>
    <content><![CDATA[<p>本篇总结Hive的函数、数据压缩和数据存储格式 以及 Hive调优等。</p>
<a id="more"></a>

<hr>
<h1 id="Hive函数"><a href="#Hive函数" class="headerlink" title="Hive函数"></a>Hive函数</h1><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>内容较多，见<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF" target="_blank" rel="noopener">《Hive官方文档》</a>。</p>
<ol>
<li><p>查看系统自带的函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> show <span class="built_in">functions</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示自带的函数的用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc <span class="keyword">function</span> upper;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>详细显示自带的函数的用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> desc <span class="keyword">function</span> extended upper;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">字符串连接函数： concat </span></span><br><span class="line">  select concat('abc','def’,'gh');</span><br><span class="line"><span class="meta">#</span><span class="bash">带分隔符字符串连接函数： concat_ws </span></span><br><span class="line">  select concat_ws(',','abc','def','gh');</span><br><span class="line"><span class="meta">#</span><span class="bash">cast类型转换</span></span><br><span class="line">  select cast(1.5 as int);</span><br><span class="line"><span class="meta">#</span><span class="bash">get_json_object(json 解析函数，用来处理json，必须是json格式)</span></span><br><span class="line">   select get_json_object('&#123;"name":"jack","age":"20"&#125;','$.name');</span><br><span class="line"><span class="meta">#</span><span class="bash">URL解析函数</span></span><br><span class="line">   select parse_url('http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1', 'HOST');</span><br><span class="line"><span class="meta">#</span><span class="bash">explode：把map集合中每个键值对或数组中的每个元素都单独生成一行的形式</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Hive 自带了一些函数，比如：max/min等，当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数(UDF).</li>
<li>根据用户自定义函数类别分为以下三种：<ol>
<li>UDF（User-Defined-Function）<ul>
<li>一进一出</li>
</ul>
</li>
<li>UDAF（User-Defined Aggregation Function）<ul>
<li>聚集函数，多进一出</li>
<li>类似于：<code>count</code>/<code>max</code>/<code>min</code></li>
</ul>
</li>
<li>UDTF（User-Defined Table-Generating Functions）<ul>
<li>一进多出</li>
<li>如 <code>lateral</code> <code>view</code> <code>explore()</code></li>
</ul>
</li>
</ol>
</li>
<li>编程步骤：<ol>
<li>继承org.apache.hadoop.hive.ql.UDF</li>
<li>需要实现evaluate函数；evaluate函数支持重载；</li>
</ol>
</li>
<li>注意事项<ol>
<li>UDF必须要有返回类型，可以返回null，但是返回类型不能为void；</li>
<li>UDF中常用Text/LongWritable等类型，不推荐使用java类型；</li>
</ol>
</li>
</ol>
<h3 id="UDF-开发实例"><a href="#UDF-开发实例" class="headerlink" title="UDF 开发实例"></a>UDF 开发实例</h3><p>需求，建立的自己的my_upper方法，将输入的字符串第一个字符大写。</p>
<h4 id="1、创建maven工程"><a href="#1、创建maven工程" class="headerlink" title="1、创建maven工程"></a>1、创建maven工程</h4><p>其中的pom.xml文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：这一步踩了坑，hive-exec坐标引用后爆红（org\pentaho\pentaho-aggdesigner-algorithm\5.1.5-jhyde.jar有红线），<strong>解决方法：</strong></p>
<ul>
<li><p>进入<a href="https://mvnrepository.com/artifact/org.pentaho/pentaho-aggdesigner-algorithm/5.1.5-jhyde下载相应jar包" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.pentaho/pentaho-aggdesigner-algorithm/5.1.5-jhyde下载相应jar包</a></p>
</li>
<li><p>放入本地maven仓库中（我的目录为D:\Server\Tools\maven_repository\org\pentaho\pentaho-aggdesigner-algorithm\5.1.5-jhyde）</p>
</li>
<li><p>重启IDEA，并在pom.xml中导入以下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pentaho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pentaho-aggdesigner-algorithm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5-jhyde<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成。</p>
</li>
</ul>
<h4 id="2、编写程序代码"><a href="#2、编写程序代码" class="headerlink" title="2、编写程序代码"></a>2、编写程序代码</h4><p><strong>开发 Java 类集成 UDF</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUDF</span>  <span class="keyword">extends</span> <span class="title">UDF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> Text str)</span></span>&#123;</span><br><span class="line">        String tmp_str = str.toString();</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; !tmp_str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">          String str_ret = tmp_str.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + tmp_str.substring(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span>  <span class="keyword">new</span> Text(str_ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Text(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、项目打包"><a href="#3、项目打包" class="headerlink" title="3、项目打包"></a>3、项目打包</h4><p>利用maven 的package命令打成jar包，并上传到集群（bigdata3）的hive的lib目录下。</p>
<h4 id="4、添加jar包到hive中"><a href="#4、添加jar包到hive中" class="headerlink" title="4、添加jar包到hive中"></a>4、添加jar包到hive中</h4><p>重命名我们的jar包名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/apache-hive-2.7.5-bin/lib</span><br><span class="line">mv hive-1.0-SNAPSHOT.jar my_upper.jar</span><br></pre></td></tr></table></figure>

<p>hive的客户端添加我们的jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> add jar /<span class="built_in">export</span>/servers/apache-hive-2.7.5-bin/lib/my_upper.jar;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、设置函数与我们的自定义函数关联"><a href="#5、设置函数与我们的自定义函数关联" class="headerlink" title="5、设置函数与我们的自定义函数关联"></a>5、设置函数与我们的自定义函数关联</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">hive&gt; create temporary function my_upper as 'udf.MyUDF';</span><br></pre></td></tr></table></figure>

<h4 id="6、使用自定义函数"><a href="#6、使用自定义函数" class="headerlink" title="6、使用自定义函数"></a>6、使用自定义函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> my_upper(<span class="string">'hello world!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果 Hello world!</span></span><br></pre></td></tr></table></figure>

<h1 id="数据压缩、数据存储格式"><a href="#数据压缩、数据存储格式" class="headerlink" title="数据压缩、数据存储格式"></a>数据压缩、数据存储格式</h1>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_10(查询、Shell参数)</title>
    <url>/2020/08/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-10/</url>
    <content><![CDATA[<p>本篇总结Hive的查询语法、Shell命令。</p>
<a id="more"></a>

<hr>
<h1 id="Hive-查询语法"><a href="#Hive-查询语法" class="headerlink" title="Hive 查询语法"></a>Hive 查询语法</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line"><span class="keyword">FROM</span> table_reference</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list [<span class="keyword">HAVING</span> condition]]</span><br><span class="line">[CLUSTER <span class="keyword">BY</span> col_list</span><br><span class="line">| [<span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> col_list] [<span class="keyword">SORT</span> <span class="keyword">BY</span>| <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">]</span><br><span class="line">[<span class="keyword">LIMIT</span> <span class="built_in">number</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li>order by 会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li>
<li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只保证每个reducer的输出有序，不保证全局有序。</li>
<li>distribute by(字段)根据指定的字段将数据分到不同的reducer，且分发算法是hash散列。</li>
<li>cluster by(字段) 除了具有distribute by的功能外，还会对该字段进行排序.</li>
<li>因此，如果distribute 和sort字段是同一个时，此时，<code>cluster by = distribute by + sort by</code></li>
</ol>
<h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><p><strong>全表查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<p><strong>选择特定列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,c_id <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<p><strong>列别名</strong></p>
<p>1）重命名一个列。<br>2）便于计算。<br>3）紧跟列名，也可以在列名和别名之间加入关键字‘AS’</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id <span class="keyword">as</span> myid ,c_id <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li>求总行数（count）注：count(1) 等价于 count(*)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<ul>
<li>求分数的最大值（max）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(s_score) <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<ul>
<li>求分数的最小值（min）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(s_score) <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<ul>
<li>求分数的总和（sum）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(s_score) <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<ul>
<li>求分数的平均值（avg）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(s_score) <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

<h2 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h2><p>典型的查询会返回多行数据。LIMIT子句用于限制返回的行数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h2><ol>
<li>使用WHERE 子句，将不满足条件的行过滤掉。</li>
<li>WHERE 子句紧随 FROM 子句。</li>
<li>案例实操</li>
</ol>
<p>查询出分数大于60的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score &gt; <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A=B</td>
<td>基本数据类型</td>
<td>如果A等于B则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=&gt;B</td>
<td>基本数据类型</td>
<td>如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL</td>
</tr>
<tr>
<td>A&lt;&gt;B, A!=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A [NOT] BETWEEN B AND C</td>
<td>基本数据类型</td>
<td>如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A IS NULL</td>
<td>所有数据类型</td>
<td>如果A等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A IS NOT NULL</td>
<td>所有数据类型</td>
<td>如果A不等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>IN(数值1, 数值2)</td>
<td>所有数据类型</td>
<td>使用 IN运算显示列表中的值</td>
</tr>
<tr>
<td>A [NOT] LIKE B</td>
<td>STRING 类型</td>
<td>B是一个SQL下的简单正则表达式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A RLIKE B, A REGEXP B</td>
<td>STRING</td>
<td>类型 B是一个正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td>
</tr>
</tbody></table>
<ul>
<li>查询分数等于80的所有的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score = <span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询分数在80到100的所有数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="keyword">between</span> <span class="number">80</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询成绩为空的所有数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询成绩是80和90的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="keyword">in</span>(<span class="number">80</span>,<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<h2 id="LIKE-和-RLIKE"><a href="#LIKE-和-RLIKE" class="headerlink" title="LIKE 和 RLIKE"></a>LIKE 和 RLIKE</h2><p>1、使用LIKE运算选择类似的值，选择条件可以包含字符或数字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 代表零个或多个字符(任意个字符)。</span><br><span class="line">_ 代表一个字符。</span><br></pre></td></tr></table></figure>

<p>2、RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件。</p>
<p><strong>案例实操</strong></p>
<ol>
<li>查找以8开头的所有成绩</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="keyword">like</span> <span class="string">'8%'</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>查找第二个数值为9的所有成绩数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score <span class="keyword">like</span> <span class="string">'_9%'</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>查找s_id中含1的数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_id <span class="keyword">rlike</span> <span class="string">'[1]'</span>;  <span class="comment">#  like '%1%'</span></span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>逻辑并</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑或</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑否</td>
</tr>
</tbody></table>
<ul>
<li>查询成绩大于80，并且s_id是01的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score &gt;<span class="number">80</span> <span class="keyword">and</span> s_id = <span class="string">'01'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询成绩大于80，或者s_id 是01的数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_score &gt; <span class="number">80</span> <span class="keyword">or</span> s_id = <span class="string">'01'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询s_id 不是 01和02的学生</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> s_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'01'</span>,<span class="string">'02'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h3 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h3><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。<br>案例实操：</p>
<ul>
<li>计算每个学生的平均分数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">avg</span>(s_score) <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算每个学生最高成绩</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">max</span>(s_score) <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id;</span><br></pre></td></tr></table></figure>

<h3 id="HAVING-语句"><a href="#HAVING-语句" class="headerlink" title="HAVING 语句"></a>HAVING 语句</h3><ol>
<li><p>having与where不同点</p>
<ol>
<li>where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。</li>
<li>where后面不能写分组函数，而having后面可以使用分组函数。</li>
<li>having只用于group by分组统计语句。</li>
</ol>
</li>
<li><p>案例实操：</p>
<ul>
<li>求每个学生的平均分数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">avg</span>(s_score) <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id;</span><br></pre></td></tr></table></figure>

<ul>
<li>求每个学生平均分数大于85的人</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">avg</span>(s_score) avgscore <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">having</span> avgscore &gt; <span class="number">85</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="JOIN-语句"><a href="#JOIN-语句" class="headerlink" title="JOIN 语句"></a>JOIN 语句</h2><h3 id="等值-JOIN"><a href="#等值-JOIN" class="headerlink" title="等值 JOIN"></a>等值 JOIN</h3><p>Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。</p>
<p>案例操作: 查询分数对应的姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.s_id,s.s_score,stu.s_name,stu.s_birth  <span class="keyword">from</span> score s  <span class="keyword">join</span> student stu <span class="keyword">on</span> s.s_id = stu.s_id;</span><br></pre></td></tr></table></figure>

<h3 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h3><ul>
<li><p>好处</p>
<ul>
<li>使用别名可以简化查询。</li>
<li>使用表名前缀可以提高执行效率。</li>
</ul>
</li>
<li><p>案例实操</p>
<ul>
<li>合并老师与课程表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> techer t <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> techer t <span class="keyword">inner</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id;</span><br></pre></td></tr></table></figure>

<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>左外连接：JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。<br>查询老师对应的课程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> techer t <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id;</span><br></pre></td></tr></table></figure>

<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接：JOIN操作符右边表中符合WHERE子句的所有记录将会被返回。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher t <span class="keyword">right</span> <span class="keyword">join</span> course c <span class="keyword">on</span> t.t_id = c.t_id;</span><br></pre></td></tr></table></figure>

<h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><p>注意：连接 n个表，至少需要n-1个连接条件。例如：连接三个表，至少需要两个连接条件。</p>
<p>多表连接查询，查询老师对应的课程，以及对应的分数，对应的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> t.t_id = c.t_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> score s</span><br><span class="line"><span class="keyword">on</span> s.c_id = c.c_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student stu</span><br><span class="line"><span class="keyword">on</span> s.s_id = stu.s_id;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，Hive会对每对JOIN连接对象启动一个MapReduce任务。本例中会首先启动一个MapReduce job对表techer和表course进行连接操作，然后会再启动一个MapReduce job将第一个MapReduce job的输出和表score;进行连接操作。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="全局排序"><a href="#全局排序" class="headerlink" title="全局排序"></a>全局排序</h3><p>Order By：全局排序，只能有一个reduce</p>
<ol>
<li><p>使用 ORDER BY 子句排序<br>ASC（ascend）: 升序（默认）<br>DESC（descend）: 降序</p>
</li>
<li><p>ORDER BY 子句在SELECT语句的结尾。</p>
</li>
<li><p>案例实操</p>
<ol>
<li>查询学生的成绩，并按照分数降序排列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sco <span class="keyword">ON</span> s.s_id = sco.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sco.s_score <span class="keyword">DESC</span>;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>​    2. 查询学生的成绩，并按照分数升序排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sco <span class="keyword">ON</span> s.s_id = sco.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sco.s_score <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="按照别名排序"><a href="#按照别名排序" class="headerlink" title="按照别名排序"></a>按照别名排序</h3><p>按照分数的平均值排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">avg</span>(s_score) <span class="keyword">avg</span> <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多个列排序"><a href="#多个列排序" class="headerlink" title="多个列排序"></a>多个列排序</h3><p>按照学生id和平均成绩进行排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id ,<span class="keyword">avg</span>(s_score) <span class="keyword">avg</span> <span class="keyword">from</span> score <span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">order</span> <span class="keyword">by</span> s_id,<span class="keyword">avg</span>;</span><br></pre></td></tr></table></figure>

<h3 id="每个MapReduce内部排序（Sort-By）局部排序"><a href="#每个MapReduce内部排序（Sort-By）局部排序" class="headerlink" title="每个MapReduce内部排序（Sort By）局部排序"></a>每个MapReduce内部排序（Sort By）局部排序</h3><p>Sort By：每个MapReduce内部进行排序，对全局结果集来说不是排序。</p>
<ol>
<li><p>设置reduce个数</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看设置reduce个数</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询成绩按照成绩降序排列</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">sort</span> <span class="keyword">by</span> s_score;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将查询结果导入到文件中（按照成绩降序排列）</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">'/export/servers/hivedatas/sort'</span> <span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">sort</span> <span class="keyword">by</span> s_score;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="分区排序（DISTRIBUTE-BY）"><a href="#分区排序（DISTRIBUTE-BY）" class="headerlink" title="分区排序（DISTRIBUTE BY）"></a>分区排序（DISTRIBUTE BY）</h3><p>Distribute By：类似MR中partition，进行分区，结合sort by使用。</p>
<p>注意，Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前。</p>
<p>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p>
<p>案例实操：先按照学生id进行分区，再按照学生成绩进行排序。</p>
<ol>
<li><p>设置reduce的个数，将我们对应的s_id划分到对应的reduce当中去</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过distribute by 进行数据的分区</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">'/export/servers/hivedatas/sort'</span> <span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">distribute</span> <span class="keyword">by</span> s_id <span class="keyword">sort</span> <span class="keyword">by</span> s_score;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="CLUSTER-BY"><a href="#CLUSTER-BY" class="headerlink" title="CLUSTER BY"></a>CLUSTER BY</h3><p>当distribute by和sort by字段相同时，可以使用cluster by方式。</p>
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是倒序排序，不能指定排序规则为ASC或者DESC。</p>
<p>以下两种写法等价</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score cluster <span class="keyword">by</span> s_id;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">distribute</span> <span class="keyword">by</span> s_id <span class="keyword">sort</span> <span class="keyword">by</span> s_id;</span><br></pre></td></tr></table></figure>

<h1 id="Shell参数"><a href="#Shell参数" class="headerlink" title="Shell参数"></a>Shell参数</h1><h2 id="Hive命令行"><a href="#Hive命令行" class="headerlink" title="Hive命令行"></a>Hive命令行</h2><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hive [-hiveconf x=y]* [&lt;-i filename&gt;]* [&lt;-f filename&gt;|&lt;-e query-string&gt;] [-S]</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1、 -i 从文件初始化HQL。</p>
<p>2、 <code>-e从命令行执行指定的HQL</code></p>
<p>3、 <code>-f 执行HQL脚本</code></p>
<p>4、 -v 输出执行的HQL语句到控制台</p>
<p>5、 -p connect to Hive Server on port number</p>
<p>6、 -hiveconf x=y Use this to set hive/hadoop configuration variables. 设置hive运行时候的参数配置</p>
<h2 id="Hive参数配置方式"><a href="#Hive参数配置方式" class="headerlink" title="Hive参数配置方式"></a>Hive参数配置方式</h2><p>开发Hive应用时，不可避免地需要设定Hive的参数。设定Hive的参数可以调优HQL代码的执行效率，或帮助定位问题。</p>
<p><strong>对于一般参数，有以下三种设定方式：</strong></p>
<ul>
<li>配置文件</li>
<li>命令行参数</li>
<li>参数声明</li>
</ul>
<p><code>配置文件</code>：Hive的配置文件包括</p>
<ul>
<li><p>用户自定义配置文件：$HIVE_CONF_DIR/hive-site.xml</p>
</li>
<li><p>默认配置文件： $HIVE_CONF_DIR/hive-default.xml</p>
<p><strong>用户自定义配置会覆盖默认配置。</strong></p>
</li>
</ul>
<p>另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。</p>
<p>配置文件的设定对本机启动的所有Hive进程都有效。</p>
<p><code>命令行参数：</code>启动Hive（客户端或Server方式）时，可以在命令行添加-hiveconf param=value来设定参数，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">bin/hive -hiveconf hive.root.logger=INFO,console</span><br></pre></td></tr></table></figure>

<p>这一设定对本次启动的Session（对于Server方式启动，则是所有请求的Sessions）有效。</p>
<p><code>参数声明</code>：可以在HQL中使用SET关键字设定参数，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapred.reduce.tasks=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这一设定的作用域也是session级的。</p>
<p>上述三种设定方式的优先级依次递增。即参数声明覆盖命令行参数，命令行参数覆盖配置文件设定。注意某些系统级的参数，例如log4j相关的设定，必须用前两种方式设定，因为那些参数的读取在Session建立以前已经完成了。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_09(Hive基本操作)</title>
    <url>/2020/08/22/%E5%A4%A7%E6%95%B0%E6%8D%AE-09/</url>
    <content><![CDATA[<p>本篇总结Hive的交互方式和<strong>基本操作命令</strong>。</p>
<a id="more"></a>

<hr>
<h1 id="Hive-的交互方式"><a href="#Hive-的交互方式" class="headerlink" title="Hive 的交互方式"></a>Hive 的交互方式</h1><h2 id="第一种交互方式：-bin-hive"><a href="#第一种交互方式：-bin-hive" class="headerlink" title="第一种交互方式：./bin/hive"></a>第一种交互方式：./bin/hive</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database if not exists mytest;</span><br></pre></td></tr></table></figure>

<h2 id="第二种交互方式：使用-sql-语句或者-sql-脚本进行交互"><a href="#第二种交互方式：使用-sql-语句或者-sql-脚本进行交互" class="headerlink" title="第二种交互方式：使用 sql 语句或者 sql 脚本进行交互"></a>第二种交互方式：使用 sql 语句或者 sql 脚本进行交互</h2><p>不进入hive的客户端直接执行hive的hql语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hive -e "create database if not exists mytest;"</span><br></pre></td></tr></table></figure>

<p>或者我们可以将我们的hql语句写成一个sql脚本执行，通过hive -f 来执行我们的sql脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hive -f /export/servers/hive.sql</span><br></pre></td></tr></table></figure>

<h1 id="Hive-的基本操作"><a href="#Hive-的基本操作" class="headerlink" title="Hive 的基本操作"></a>Hive 的基本操作</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p><strong>创建数据库：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> myhive;</span><br></pre></td></tr></table></figure>

<p><strong>创建数据库并指定位置：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> myhive location <span class="string">'/myhive'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设置数据库键值对信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> foo <span class="keyword">with</span> dbproperties (<span class="string">'owner'</span>=<span class="string">'itcast'</span>,<span class="string">'date'</span>=<span class="string">'20190120'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>查看数据库更多详细信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc database extended myhive;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据库：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> myhive;</span><br></pre></td></tr></table></figure>

<p>​    强制删除数据库，包含数据库下面的表一起删除：（效果相当于 rm -rf，慎用！！！）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> myhive <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h2><h3 id="创建表的语法"><a href="#创建表的语法" class="headerlink" title="创建表的语法"></a><strong>创建表的语法</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">external</span>] <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] table_name (</span><br><span class="line">col_name data_type [<span class="keyword">comment</span> <span class="string">'字段描述信息'</span>]</span><br><span class="line">col_name data_type [<span class="keyword">comment</span> <span class="string">'字段描述信息'</span>])</span><br><span class="line">[<span class="keyword">comment</span> <span class="string">'表的描述信息'</span>]</span><br><span class="line">[partitioned <span class="keyword">by</span> (col_name data_type,...)]</span><br><span class="line">[clustered <span class="keyword">by</span> (col_name,col_name,...)]</span><br><span class="line">[sorted <span class="keyword">by</span> (col_name [<span class="keyword">asc</span>|<span class="keyword">desc</span>],...) <span class="keyword">into</span> num_buckets buckets]</span><br><span class="line">[<span class="keyword">row</span> <span class="keyword">format</span> row_format]</span><br><span class="line">[storted <span class="keyword">as</span> ....]</span><br><span class="line">[location <span class="string">'指定表的路径'</span>]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<ol>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">create table</a></p>
<p>创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">external</a></p>
<p>可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive 创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">comment</a></p>
<p>表示注释,默认不能使用中文</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">partitioned by</a></p>
<p>表示使用表分区,一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下 .</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">clustered by</a></p>
<p>对于每一个表分文件， Hive可以进一步组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive也是 针对某一列进行桶的组织。</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">sorted by</a></p>
<p>指定排序字段和排序规则</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">row format</a></p>
<p>指定表文件字段分隔符</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">storted as</a></p>
<p>指定表文件的存储格式, 常用格式:SEQUENCEFILE, TEXTFILE, RCFILE,如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 storted as SEQUENCEFILE。</p>
</li>
<li><p><a href="https://blog.csdn.net/chipeize/article/details/100364057" target="_blank" rel="noopener">location</a></p>
<p>指定表文件的存储路径</p>
</li>
</ol>
</blockquote>
<h3 id="内部表操作"><a href="#内部表操作" class="headerlink" title="内部表操作"></a>内部表操作</h3><p>创建表时，如果没有使用external关键字，则该表是内部表（管理表，managed table）。</p>
<p><strong>Hive 建表字段类型</strong></p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">类型</th>
<th align="left">描述</th>
<th align="left">字面量示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原始类型</td>
<td align="left">BOOLEAN</td>
<td align="left">true/false</td>
<td align="left">TRUE</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TINYINT</td>
<td align="left">1字节的有符号整数, -128~127</td>
<td align="left">1Y</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SMALLINT</td>
<td align="left">2个字节的有符号整数，-32768~32767</td>
<td align="left">1S</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INT</td>
<td align="left">4个字节的带符号整数</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">BIGINT</td>
<td align="left">8字节带符号整数</td>
<td align="left">1L</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">FLOAT</td>
<td align="left">4字节单精度浮点数</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">DOUBLE</td>
<td align="left">8字节双精度浮点数</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">DEICIMAL</td>
<td align="left">任意精度的带符号小数</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">STRING</td>
<td align="left">字符串，变长</td>
<td align="left">“a”,’b’</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">VARCHAR</td>
<td align="left">变长字符串</td>
<td align="left">“a”,’b’</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">CHAR</td>
<td align="left">固定长度字符串</td>
<td align="left">“a”,’b’</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">BINARY</td>
<td align="left">字节数组</td>
<td align="left">无法表示</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TIMESTAMP</td>
<td align="left">时间戳，毫秒值精度</td>
<td align="left">122327493795</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">DATE</td>
<td align="left">日期</td>
<td align="left">‘2016-03-29’</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INTERVAL</td>
<td align="left">时间频率间隔</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">复杂类型</td>
<td align="left">ARRAY</td>
<td align="left">有序的的同类型的集合</td>
<td align="left">array(1,2)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">MAP</td>
<td align="left">key-value,key必须为原始类型，value可以任意类型</td>
<td align="left">map(‘a’,1,’b’,2)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">STRUCT</td>
<td align="left">字段集合,类型可以不同</td>
<td align="left">struct(‘1’,1,1.0), named_stract(‘col1’,’1’,’col2’,1,’clo3’,1.0)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UNION</td>
<td align="left">在有限取值范围内的一个值</td>
<td align="left">create_union(1,’a’,63)</td>
</tr>
</tbody></table>
<p><strong>建表入门</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> myhive;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"zhangsan"</span>);  <span class="comment">#插入数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure>

<p>创建表并指定字段之间的分隔符，默认为 <code>\001</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> stu2(<span class="keyword">id</span> <span class="built_in">int</span> ,<span class="keyword">name</span> <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建表并指定表文件的存放路径</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> stu2(<span class="keyword">id</span> <span class="built_in">int</span> ,<span class="keyword">name</span> <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> location <span class="string">'/user/stu2'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>根据查询结果创建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过复制表结构和表内容创建新表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu3 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> stu2;</span><br></pre></td></tr></table></figure>

<p><strong>根据已经存在的表结构创建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu4 <span class="keyword">like</span> stu;</span><br></pre></td></tr></table></figure>

<p><strong>查询表的详细信息</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc formatted stu2;</span><br></pre></td></tr></table></figure>

<p><strong>删除表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> stu;</span><br></pre></td></tr></table></figure>

<h3 id="外部表的操作"><a href="#外部表的操作" class="headerlink" title="外部表的操作"></a><strong>外部表的操作</strong></h3><p>外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以删除hive表的时候，数据仍然存放在hdfs当中，不会删掉.</p>
<p><strong>内部表和外部表的使用场景</strong></p>
<p>每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。</p>
<h4 id="操作案例"><a href="#操作案例" class="headerlink" title="操作案例"></a>操作案例</h4><p>分别创建老师与学生外部表，并向表中加载数据。</p>
<p><strong>创建老师表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> teacher(t_id <span class="keyword">string</span>,t_name <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建学生表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> student (s_id <span class="keyword">string</span>,s_name <span class="keyword">string</span>,s_birth <span class="keyword">string</span> , s_sex <span class="keyword">string</span> ) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>加载数据</strong></p>
<ol>
<li><p>可以直接把指定结构的文件上传到hdfs文件系统的表目录下。</p>
<p>比如之前的teacher表有两个string字段，分隔符为 \t，我们可以建如下文件，teacher.txt，内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	zhangsan</span><br><span class="line"><span class="number">2</span>	lisi</span><br><span class="line"><span class="number">3</span>	wangwu           <span class="comment"># 分割符为 \t</span></span><br></pre></td></tr></table></figure>

<p>即可在hive命令下，使用select查询得到如上结果。</p>
</li>
<li><p>本地加载，可以加载本地的文件读入到hive数据仓库中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/export/servers/hivedatas/student.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> student;</span><br><span class="line"></span><br><span class="line">加载本地路径下的csv文件到student表中。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以在此验证外部表：通过drop删除表后，select不能查询，但是hdfs系统的数据文件仍在，通过之前的建表语句再次建表，就可查询成功。可见，外部表只是与真实数据的一种映射关系。</p>
</blockquote>
</li>
<li><p>加载数据并覆盖已有数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">load data local inpath '/export/servers/hivedatas/student.csv' overwrite into table student;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从hdfs文件系统向表中加载数据（需要提前将数据上传到hdfs文件系统）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">load data inpath '/student.csv' into table student;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="分区表的操作"><a href="#分区表的操作" class="headerlink" title="分区表的操作"></a><strong>分区表的操作</strong></h3><p>​    在大数据中，最常用的一种思想就是分治，我们可以把大的文件切割划分成一个个的小的文件，这样每次操作一个小的文件就会很容易了，同样的道理，在hive当中也是支持这种思想的，就是我们可以把大的数据，按照每月，或者天进行切分成一个个的小的文件,存放在不同的文件夹中.</p>
<p><strong>创建分区表语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(s_id <span class="keyword">string</span>,c_id <span class="keyword">string</span>, s_score <span class="built_in">int</span>) partitioned <span class="keyword">by</span> (<span class="keyword">month</span> <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个表带多个分区</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table score2 (s_id string,c_id string, s_score int) partitioned by (year string,month string,day string) row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>加载数据到分区表中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/export/servers/hivedatas/score.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> score <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'201806'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>加载数据到多分区表中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/export/servers/hivedatas/score.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> score2 <span class="keyword">partition</span>(<span class="keyword">year</span>=<span class="string">'2018'</span>,<span class="keyword">month</span>=<span class="string">'06'</span>,<span class="keyword">day</span>=<span class="string">'01'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>多分区表联合查询（使用union all）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">'201806'</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">'201806'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查看分区</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span>  <span class="keyword">partitions</span>  score;</span><br></pre></td></tr></table></figure>

<p><strong>添加一个分区</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201805'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除分区</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">drop</span> <span class="keyword">partition</span>(<span class="keyword">month</span> = <span class="string">'201806'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="分区表综合练习"><a href="#分区表综合练习" class="headerlink" title="分区表综合练习"></a>分区表综合练习</h3><p><strong>需求描述：</strong></p>
<p> 现在有一个文件score.csv文件，存放在集群的这个目录下/scoredatas/month=201806，这个文件每天都会生成，存放到对应的日期文件夹下面去，文件别人也需要公用，不能移动。需求，创建hive对应的表，并将数据加载到表中，进行数据统计分析，且删除表之后，数据不能删除</p>
<p><strong>数据准备：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /scoredatas/month=201806</span><br><span class="line">hdfs dfs -put score.csv /scoredatas/month=201806/</span><br></pre></td></tr></table></figure>

<p><strong>创建外部分区表，并指定文件数据存放目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create external table score4(s_id string, c_id string,s_score int) partitioned by (month string) row format delimited fields terminated by '\t' location '/scoredatas';</span><br></pre></td></tr></table></figure>

<p><strong>进行表的修复(建立表与数据文件之间的一个关系映射)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msck repair table score4;</span><br></pre></td></tr></table></figure>

<p>之后便可select查询该表验证结果。</p>
<h3 id="分桶表操作"><a href="#分桶表操作" class="headerlink" title="分桶表操作"></a>分桶表操作</h3><p>分桶，就是将数据按照指定的字段进行划分到多个文件当中去,分桶就是MapReduce中的分区.</p>
<p><strong>开启 Hive 的分桶功能</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设置 Reduce 个数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建分桶表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (c_id <span class="keyword">string</span>,c_name <span class="keyword">string</span>,t_id <span class="keyword">string</span>) clustered <span class="keyword">by</span>(c_id) <span class="keyword">into</span> <span class="number">3</span> buckets <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建普通表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course_common (c_id <span class="keyword">string</span>,c_name <span class="keyword">string</span>,t_id <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>普通表中加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/export/servers/hivedatas/course.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> course_common;</span><br></pre></td></tr></table></figure>

<p><strong>通过insert overwrite给桶表中加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> course <span class="keyword">select</span> * <span class="keyword">from</span> course_common cluster <span class="keyword">by</span>(c_id);</span><br></pre></td></tr></table></figure>

<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p><strong>重命名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  old_table_name  <span class="keyword">rename</span>  <span class="keyword">to</span>  new_table_name;</span><br></pre></td></tr></table></figure>

<p>把表score4修改成score5</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score4 <span class="keyword">rename</span> <span class="keyword">to</span> score5;</span><br></pre></td></tr></table></figure>

<p><strong>增加/修改列信息:</strong></p>
<ul>
<li>查询表结构</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc score5;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score5 <span class="keyword">add</span> <span class="keyword">columns</span> (mycol <span class="keyword">string</span>, mysco <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>更新列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score5 <span class="keyword">change</span> <span class="keyword">column</span> mysco mysconew <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> score5;</span><br></pre></td></tr></table></figure>

<h2 id="Hive表中加载数据"><a href="#Hive表中加载数据" class="headerlink" title="Hive表中加载数据"></a>Hive表中加载数据</h2><p><strong>直接向分区表中插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score3 <span class="keyword">like</span> score;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> score3 <span class="keyword">partition</span>(<span class="keyword">month</span> =<span class="string">'201807'</span>) <span class="keyword">values</span> (<span class="string">'001'</span>,<span class="string">'002'</span>,<span class="string">'100'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过load方式加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/export/servers/hivedatas/score.csv'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> score <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201806'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过查询方式加载数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score4 <span class="keyword">like</span> score;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> score4 <span class="keyword">partition</span>(<span class="keyword">month</span> = <span class="string">'201806'</span>) <span class="keyword">select</span> s_id,c_id,s_score <span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_08(Hive介绍和安装)</title>
    <url>/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/</url>
    <content><![CDATA[<p>本篇总结Hive（数据仓库）数据仓库和 Hive 的基本概念。</p>
<a id="more"></a>

<hr>
<h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>英文名称为 Data Warehouse，可简写为 DW 或 DWH。数据仓库的目的是构建面相分析的集成化数据环境，为企业提供决策支持（Decision Support）。</p>
<p>​    数据仓库是存数据的，企业的各种数据往里面存，主要目的是为了分析有效数据，后续会基于它产出供分析挖掘的数据，或者数据应用需要的数据，如企业的分析性报告和各类报表等。</p>
<p>​    可以理解为：<strong>面向分析的存储系统。</strong></p>
<h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><p>数据仓库是面向主题的（Subject-Oriented）、集成的（Integrated）、非易失的（Non-Volatile）和时变的（Time-Variant）数据集合，用以支持管理决策。</p>
<h3 id="面向主题"><a href="#面向主题" class="headerlink" title="面向主题"></a>面向主题</h3><p>数据仓库是面向主题的,数据仓库通过一个个主题域将多个业务系统的数据加载到一起，为了各个主题（如：用户、订单、商品等）进行分析而建，操作型数据库是为了支撑各种业务而建立。</p>
<h3 id="集成性"><a href="#集成性" class="headerlink" title="集成性"></a>集成性</h3><p>数据仓库会将不同源数据库中的数据汇总到一起,数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与整合，这一步是数据仓库建设中最关键、最复杂的一步(ETL)，要统一源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致，等等。</p>
<h3 id="非易失性"><a href="#非易失性" class="headerlink" title="非易失性"></a>非易失性</h3><p>操作型数据库主要服务于日常的业务操作，使得数据库需要不断地对数据实时更新，以便迅速获得当前最新数据，不至于影响正常的业务运作。</p>
<p>​    在数据仓库中只要保存过去的业务数据，不需要每一笔业务都实时更新数据仓库，而是根据商业需要每隔一段时间把一批较新的数据导入数据仓库。 数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库的集合，以及基于这些快照进行统计、综合和重组的导出数据。数据仓库中的数据一般仅执行查询操作，很少会有删除和更新。但是需定期加载和刷新数据。</p>
<h3 id="时变性"><a href="#时变性" class="headerlink" title="时变性"></a>时变性</h3><p>数据仓库包含各种粒度的历史数据。数据仓库中的数据可能与某个特定日期、星期、月份、季度或者年份有关。数据仓库的目的是通过分析企业过去一段时间业务的经营状况，挖掘其中隐藏的模式。虽然数据仓库的用户不能修改数据，但并不是说数据仓库的数据是永远不变的。分析的结果只能反映过去的情况，当业务变化后，挖掘出的模式会失去时效性。因此数据仓库的数据需要定时更新，以适应决策的需要。</p>
<h2 id="数据库与数据仓库的区别"><a href="#数据库与数据仓库的区别" class="headerlink" title="数据库与数据仓库的区别"></a>数据库与数据仓库的区别</h2><p>​    数据库与数据仓库的区别实际讲的是 <code>OLTP</code> 与 <code>OLAP</code> 的区别。</p>
<p>​    操作型处理，叫联机事务处理 OLTP（On-Line Transaction Processing，），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p>
<p>​    分析型处理，叫联机分析处理 OLAP（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持 管理决策。</p>
<p>首先要明白，数据仓库的出现，并不是要取代数据库。</p>
<ul>
<li>数据库是面向事务的设计，数据仓库是面向主题设计的。</li>
<li>数据库一般存储业务数据，数据仓库存储的一般是历史数据。</li>
<li>数据库设计是尽量避免冗余，一般针对某一业务应用进行设计，比如一张简单的User表，记录用户名、密码等简单数据即可，符合业务应用，但是不符合分析。数据仓库在设计是有意引入冗余，依照分析需求，分析维度、分析指标进行设计。</li>
<li>数据库是为捕获数据而设计，数据仓库是为分析数据而设计。</li>
</ul>
<p>​    <strong>数据仓库，是在数据库已经大量存在的情况下，为了进一步挖掘数据资源、为了决策需要而产生的，它决不是所谓的“大型数据库”。</strong></p>
<h2 id="数仓的分层架构"><a href="#数仓的分层架构" class="headerlink" title="数仓的分层架构"></a>数仓的分层架构</h2><p>按照数据流入流出的过程，数据仓库架构可分为三层——源数据、数据仓库、数据应用。</p>
<img src="/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/1.jpg" class>

<p>数据仓库的数据来源于不同的源数据，并提供多样的数据应用，数据自下而上流入数据仓库后向上层开放应用，而数据仓库只是中间集成化数据管理的一个平台。</p>
<ul>
<li><code>源数据层（ODS）</code>：此层数据无任何更改，直接沿用外围系统数据结构和数据，不对外开放；为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。</li>
<li><code>数据仓库层（DW）</code>：也称为细节层，DW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。</li>
<li><code>数据应用层（DA或APP）</code>：前端应用直接读取的数据源；根据报表、专题分析需求而计算生成的数据。</li>
</ul>
<p>​    数据仓库从各数据源获取数据及在数据仓库内的数据转换和流动都可以认为是ETL（抽取Extra, 转化Transfer, 装载Load）的过程，ETL是数据仓库的流水线，也可以认为是数据仓库的血液，它维系着数据仓库中数据的新陈代谢，而数据仓库日常的管理和维护工作的大部分精力就是保持ETL的正常和稳定。</p>
<p><strong>为什么要对数据仓库分层？</strong></p>
<p>​    用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据；不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。</p>
<p>​    通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。</p>
<h2 id="数仓的元数据管理"><a href="#数仓的元数据管理" class="headerlink" title="数仓的元数据管理"></a>数仓的元数据管理</h2><p>​    元数据（Meta Date），主要记录数据仓库中模型的定义、各层级间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态。一般会通过元数据资料库（Metadata Repository）来统一地存储和管理元数据，其主要目的是使数据仓库的设计、部署、操作和管理能达成协同和一致。</p>
<p>​    元数据是数据仓库管理系统的重要组成部分，元数据管理是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。</p>
<ul>
<li>构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。</li>
<li>用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。</li>
<li>数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。</li>
</ul>
<img src="/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/2.jpg" class>

<p>元数据可分为技术元数据和业务元数据。技术元数据为开发和管理数据仓库的IT 人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而业务元数据为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。</p>
<p>​    由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体。</p>
<h1 id="Hive-的基本概念"><a href="#Hive-的基本概念" class="headerlink" title="Hive 的基本概念"></a>Hive 的基本概念</h1><h2 id="Hive-简介"><a href="#Hive-简介" class="headerlink" title="Hive 简介"></a>Hive 简介</h2><p>​    Hive是基于Hadoop的一个数据仓库工具，可以将<strong>结构化的数据(有固定的字段，字段之间有固定的分隔符)</strong>文件映射为一张数据库表，并提供类SQL查询功能。</p>
<p>​    其本质是将SQL转换为MapReduce的任务进行运算，底层由HDFS来提供数据的存储，说白了hive可以理解为一个将SQL转换为MapReduce的任务的工具，甚至更进一步可以说hive就是一个MapReduce的客户端</p>
<p><strong>为什么使用 Hive</strong></p>
<ul>
<li>采用类SQL语法去操作数据，提供快速开发的能力。</li>
<li>避免了去写MapReduce，减少开发人员的学习成本。</li>
<li>功能扩展很方便。</li>
</ul>
<h2 id="Hive-架构"><a href="#Hive-架构" class="headerlink" title="Hive 架构"></a>Hive 架构</h2><img src="/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/3.jpg" class>

<ul>
<li><strong>用户接口：</strong> 包括CLI、JDBC/ODBC、WebGUI。其中，CLI(command line interface)为shell命令行；JDBC/ODBC是Hive的JAVA实现，与传统数据库JDBC类似；WebGUI是通过浏览器访问Hive。</li>
<li><strong>元数据存储：</strong> 通常是存储在关系数据库如mysql/derby中。Hive 将元数据存储在数据库中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</li>
<li><strong>解释器、编译器、优化器、执行器:</strong> 完成HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在HDFS 中，并在随后有MapReduce 调用执行。</li>
</ul>
<h2 id="Hive-与-Hadoop-的关系"><a href="#Hive-与-Hadoop-的关系" class="headerlink" title="Hive 与 Hadoop 的关系"></a>Hive 与 Hadoop 的关系</h2><p>Hive利用HDFS存储数据，利用MapReduce查询分析数据</p>
<img src="/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/4.jpg" class>

<h2 id="Hive与传统数据库对比"><a href="#Hive与传统数据库对比" class="headerlink" title="Hive与传统数据库对比"></a>Hive与传统数据库对比</h2><p>hive用于海量数据的离线数据分析</p>
<img src="/2020/08/21/%E5%A4%A7%E6%95%B0%E6%8D%AE-08/5.jpg" class>

<p><strong>总结：</strong>hive具有sql数据库的外表，但应用场景完全不同，hive只适合用来做批量数据统计分析</p>
<h1 id="Hive-的安装和配置"><a href="#Hive-的安装和配置" class="headerlink" title="Hive 的安装和配置"></a>Hive 的安装和配置</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载Hive"><a href="#下载Hive" class="headerlink" title="下载Hive"></a>下载Hive</h3><ul>
<li><p>下载Hive安装包：这里我们选用hive的版本是 <strong>2.1.1</strong> 下载地址为：<a href="http://archive.apache.org/dist/hive/hive-2.1.1/apache-hive-2.1.1-bin.tar.gz" target="_blank" rel="noopener">http://archive.apache.org/dist/hive/hive-2.1.1/apache-hive-2.1.1-bin.tar.gz</a></p>
</li>
<li><p>解压到相应安装目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/softwares/</span><br><span class="line">tar -zxvf apache-hive-2.1.1-bin.tar.gz -C ../servers/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">sudo rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum install mysql mysql-server</span><br><span class="line"></span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h3 id="修改hive的配置文件"><a href="#修改hive的配置文件" class="headerlink" title="修改hive的配置文件"></a>修改hive的配置文件</h3><p><strong>修改hive-env.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/apache-hive-2.1.1-bin/conf</span><br><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>

<p>修改内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HADOOP_HOME=/export/servers/hadoop-2.7.5</span><br><span class="line">export HIVE_CONF_DIR=/export/servers/apache-hive-2.1.1-bin/conf</span><br></pre></td></tr></table></figure>

<p><strong>修改hive-site.xml</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/apache-hive-2.1.1-bin/conf</span><br><span class="line">vim hive-site.xml</span><br></pre></td></tr></table></figure>

<p>修改内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://node03:3306/hive?createDatabaseIfNotExist=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.schema.verification<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>datanucleus.schema.autoCreateAll<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.thrift.bind.host<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>node03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加mysql的连接驱动包到hive的lib目录下"><a href="#添加mysql的连接驱动包到hive的lib目录下" class="headerlink" title="添加mysql的连接驱动包到hive的lib目录下"></a>添加mysql的连接驱动包到hive的lib目录下</h3><p>将mysql 的 驱动 mysql-connector-java-5.1.18-bin.jar 添加 hive的lib目录下即可。</p>
<h3 id="配置hive的环境变量"><a href="#配置hive的环境变量" class="headerlink" title="配置hive的环境变量"></a>配置hive的环境变量</h3><p> 在 /etc/profile 中添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HIVE_HOME=/export/servers/apache-hive-2.1.1-bin    (安装目录)</span><br><span class="line">export PATH=:$HIVE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_07(Yarn)</title>
    <url>/2020/08/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-07/</url>
    <content><![CDATA[<p>本篇总结<strong>Yarn资源调度</strong>的基础知识。</p>
<a id="more"></a>

<hr>
<h1 id="Yarn介绍"><a href="#Yarn介绍" class="headerlink" title="Yarn介绍"></a>Yarn介绍</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一 种新的 Hadoop 资源管理器，它是一个通用资源管理系统和调度平台，可为上层应用提供统 一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p>
<p>Yarn核心出发点是为了分离资源管理与作业监控，实现分离的做法是拥有一个全局的资源管理（ResourceManager，RM），以及每个应用程序对应一个的应用管理器（ApplicationMaster，AM）</p>
<p>总结一句话就是：<strong>Yarn就是为了调度资源，管理任务的</strong> 。</p>
<p>其调度分为两个层次：</p>
<ul>
<li>一级调度管理：计算资源管理（CPU，内存，网络IO，磁盘）</li>
<li>二级调度管理：任务内部的计算模型管理（AppMaster的任务精细化管理）</li>
</ul>
<h1 id="Yarn的主要组件介绍和作用"><a href="#Yarn的主要组件介绍和作用" class="headerlink" title="Yarn的主要组件介绍和作用"></a>Yarn的主要组件介绍和作用</h1><p>Yarn总体上是Master/Slave结构，主要由ResourceManager、NodeManager、ApplicationMaster和Container等几个组件构成。</p>
<img src="/2020/08/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-07/1.gif" class>

<h2 id="1-ResourceManager"><a href="#1-ResourceManager" class="headerlink" title="1. ResourceManager"></a>1. ResourceManager</h2><p>每个Hadoop集群只会有一个ResourceManager（如果是HA的话会存在两个，但是有且只有一个处于active状态），它负责管理整个集群的计算资源，并将这些资源分别给应用程序。ResourceManager 内部主要有<strong>两个组件</strong>：</p>
<ol>
<li><strong>调度器</strong>（Scheduler）:负责资源的 分配。</li>
<li><strong>应用程序管理器</strong>  ApplicationsManager (AsM):这个组件用于管理整个集群应用程序的application masters，负责接收应用程序的提交；为application master启动提供资源；监控应用程序的运行进度以及在应用程序出现故障时重启它。</li>
</ol>
<h2 id="2-NodeManager"><a href="#2-NodeManager" class="headerlink" title="2. NodeManager"></a>2. NodeManager</h2><p>NodeManager是YARN中每个节点上的代理，它管理Hadoop集群中单个计算节点，根据相关的设置来启动容器的。NodeManager会定期向ResourceManager发送心跳信息来更新其健康状态。同时其也会监督Container的生命周期管理，监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况，管理日志和不同应用程序用到的附属服务（auxiliary service）。</p>
<h2 id="3-ApplicationMaster"><a href="#3-ApplicationMaster" class="headerlink" title="3. ApplicationMaster"></a>3. ApplicationMaster</h2><p>ApplicationMaster是应用程序级别的，每个ApplicationMaster管理运行在YARN上的应用程序。YARN 将 ApplicationMaster看做是第三方组件，ApplicationMaster负责和ResourceManager scheduler协商资源，并且和NodeManager通信来运行相应的task。ResourceManager 为 ApplicationMaster 分配容器，这些容器将会用来运行task。ApplicationMaster 也会追踪应用程序的状态，监控容器的运行进度。当容器运行完成， ApplicationMaster 将会向 ResourceManager 注销这个容器；如果是整个作业运行完成，其也会向 ResourceManager 注销自己，这样这些资源就可以分配给其他的应用程序使用了。</p>
<h2 id="4-Container"><a href="#4-Container" class="headerlink" title="4. Container"></a>4. Container</h2><p>是Yarn中的资源抽象。Container是与特定节点绑定的，其包含了内存、CPU磁盘等逻辑资源。不过在现在的容器实现中，这些资源只包括了内存和CPU。容器是由 ResourceManager scheduler 服务动态分配的资源构成。容器授予 ApplicationMaster 使用特定主机的特定数量资源的权限。ApplicationMaster 也是在容器中运行的，其在应用程序分配的第一个容器中运行。</p>
<p>作业的完整运行如下所示：</p>
<img src="/2020/08/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-07/2.jpeg" class>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_06(MapReduce 的 Shuffle 详解（分区、排序、规约、分组）)</title>
    <url>/2020/08/13/%E5%A4%A7%E6%95%B0%E6%8D%AE-06/</url>
    <content><![CDATA[<p>本篇总结MapReduce<strong>分区、排序、规约</strong>的基础知识。</p>
<a id="more"></a>

<hr>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>在 MapReduce 中, 通过我们指定分区, 会将同一个分区的数据发送到同一个 Reduce 当中进行处理</p>
<p>​    例如: 为了数据的统计, 可以把一批类似的数据发送到同一个 Reduce 当中, 在同一个 Reduce 当中统计相同类型的数据, 就可以实现类似的数据分区和统计等</p>
<p>​    其实就是相同类型的数据, 有共性的数据, 送到一起去处理</p>
<p>​    Reduce 当中默认的分区只有一个</p>
<h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> partition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Counter;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* K1：行偏移量 LongWritable</span></span><br><span class="line"><span class="comment">* V1:行文本数据 Text</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* K2:行文本数据 Text</span></span><br><span class="line"><span class="comment">* V2:NullWritable</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// map 方法：将 K1 V1 转为 K2 V2</span></span><br><span class="line">    <span class="comment">// K2 就是 V1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 方法1：定义计数器</span></span><br><span class="line">        <span class="comment">// 参数： 计数器类型，  计数器变量</span></span><br><span class="line">        Counter counter = context.getCounter(<span class="string">"MY_COUNTER"</span>, <span class="string">"partition_counter"</span>);</span><br><span class="line">        <span class="comment">//每次执行map方法，计数器被执行，1L 表示每次执行 +1</span></span><br><span class="line">        counter.increment(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        context.write(value,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionerReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">NullWritable</span>, <span class="title">Text</span>,<span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;NullWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write(key, NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> partition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Partitioner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定义分区规则</span></span><br><span class="line"><span class="comment">    * 返回对应分区编号</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text text, NullWritable nullWritable, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拆分行文本数据(K2),获取中奖字段值</span></span><br><span class="line">        String[] split = text.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">        String numStr = split[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 判断中奖字段值和15的关系，然后返回对应的分区编号</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(numStr) &gt; <span class="number">15</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JobMain"><a href="#JobMain" class="headerlink" title="JobMain"></a>JobMain</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> partition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建job任务对象</span></span><br><span class="line">        Job job = Job.getInstance(<span class="keyword">super</span>.getConf(), <span class="string">"PartitionMapReduce"</span>);</span><br><span class="line">        <span class="comment">// 对job任务进行配置(8个步骤)</span></span><br><span class="line">        <span class="comment">// 1、设置输入类和输入的路径</span></span><br><span class="line">        job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextInputFormat.addInputPath(job,<span class="keyword">new</span> Path(<span class="string">"hdfs://bigdata1:8020/input"</span>));</span><br><span class="line">        TextInputFormat.addInputPath(job,<span class="keyword">new</span> Path(<span class="string">"file:///D:\\input"</span>));</span><br><span class="line">        <span class="comment">//2、设置mapper类和数据类型</span></span><br><span class="line">        job.setMapperClass(PartitionMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//3、指定分区类</span></span><br><span class="line">        job.setPartitionerClass(MyPartitioner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//4、5、6</span></span><br><span class="line">        <span class="comment">//7、指定reducer类和数据类型（K3 和 V3）</span></span><br><span class="line">        job.setReducerClass(PartitionerReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置reduceTask的个数</span></span><br><span class="line">        job.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、指定输出类和输出类型</span></span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">"hdfs://bigdata1:8020/out/partition_out"</span>));</span><br><span class="line">        TextOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">"file:///D:\\out\\partition_out"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 启动job任务</span></span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(configuration, <span class="keyword">new</span> JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>其中在 mapper 和 reducer 里添加了计数器的相关使用，得到结果如下。</p>
<img src="/2020/08/13/%E5%A4%A7%E6%95%B0%E6%8D%AE-06/1.png" class>

<img src="/2020/08/13/%E5%A4%A7%E6%95%B0%E6%8D%AE-06/2.png" class>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>序列化 (Serialization) 是指把结构化对象转化为字节流</li>
<li>反序列化 (Deserialization) 是序列化的逆过程. 把字节流转为结构化对象. 当要在进程间传递对象或持久化对象的时候, 就需要序列化对象成字节流, 反之当要将接收到或从磁盘读取的字节流转换为对象, 就要进行反序列化</li>
<li>Java 的序列化 (Serializable) 是一个重量级序列化框架, 一个对象被序列化后, 会附带很多额外的信息 (各种校验信息, header, 继承体系等）, 不便于在网络中高效传输. 所以, Hadoop 自己开发了一套序列化机制(Writable), 精简高效. 不用像 Java 对象类一样传输多层的父子关系, 需要哪个属性就传输哪个属性值, 大大的减少网络传输的开销</li>
<li>Writable 是 Hadoop 的序列化格式, Hadoop 定义了这样一个 Writable 接口. 一个类要支持可序列化只需实现这个接口即可</li>
<li>另外 Writable 有一个子接口是 WritableComparable, WritableComparable 是既可实现序列化, 也可以对key进行比较, 我们这里可以通过自定义 Key 实现 WritableComparable 来实现我们的排序功能</li>
</ul>
<p>数据格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a   1</span><br><span class="line">a   9</span><br><span class="line">b   3</span><br><span class="line">a   7</span><br><span class="line">b   8</span><br><span class="line">b   10</span><br><span class="line">a   5</span><br></pre></td></tr></table></figure>

<p>要求:</p>
<ul>
<li>第一列按照字典顺序进行排列</li>
<li>第一列相同的时候, 第二列按照升序进行排列</li>
</ul>
<p>解决思路:</p>
<ul>
<li>将 Map 端输出的 <code>&lt;key,value&gt;</code> 中的 key 和 value 组合成一个新的 key (newKey), value值不变</li>
<li>这里就变成 <code>&lt;(key,value),value&gt;</code>, 在针对 newKey 排序的时候, 如果 key 相同, 就再对value进行排序</li>
</ul>
<h2 id="自定义类型和比较器"><a href="#自定义类型和比较器" class="headerlink" title="自定义类型和比较器"></a>自定义类型和比较器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cpz.mapreduce.sort;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.fastinfoset.algorithm.BuiltInEncodingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.WritableComparable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortBean</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">SortBean</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  word + <span class="string">"\t"</span> + num ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实现比较器，指定排序的规则</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    规则：</span></span><br><span class="line"><span class="comment">        第一列（word）按照字典顺序进行排列     //字典顺序：aac aad abc (按照ASCII码相减)</span></span><br><span class="line"><span class="comment">        第一列相同的私事后，第二列（num）按照升序进行排列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(SortBean sortBean)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// // 先对第一列排序：word排序</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">this</span>.word.compareTo(sortBean.word);</span><br><span class="line">        <span class="comment">// 如果第一列相同，则按照第二列进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.num - sortBean.num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实现序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(word);</span><br><span class="line">        dataOutput.writeInt(num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实现反序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.num = dataInput.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mapper-1"><a href="#Mapper-1" class="headerlink" title="Mapper"></a>Mapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">SortBean</span>,<span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 将行文本数据（V1)拆分，并将数据封装到 SortBean 对象，就可以得到K2</span></span><br><span class="line">        String[] split = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line"> </span><br><span class="line">        SortBean sortBean = <span class="keyword">new</span> SortBean();</span><br><span class="line">        sortBean.setWord(split[<span class="number">0</span>]);</span><br><span class="line">        sortBean.setNum(Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将K2 V2 写入上下文中</span></span><br><span class="line">        context.write(sortBean,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reducer-1"><a href="#Reducer-1" class="headerlink" title="Reducer"></a>Reducer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">SortBean</span>,<span class="title">NullWritable</span>,<span class="title">SortBean</span>,<span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(SortBean key, Iterable&lt;NullWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write(key,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JobMain-1"><a href="#JobMain-1" class="headerlink" title="JobMain"></a>JobMain</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Job job = Job.getInstance(<span class="keyword">super</span>.getConf(), <span class="string">"mapreduce_sort"</span>);</span><br><span class="line"> </span><br><span class="line">        job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(<span class="string">"d:\\mapreduce\\sort_in"</span>));</span><br><span class="line"> </span><br><span class="line">        job.setMapperClass(SortMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(SortBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 排序：不需要配置，只需要定义排序规则（SortBean中的排序规则）</span></span><br><span class="line"> </span><br><span class="line">        job.setReducerClass(SortReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(SortBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(<span class="string">"d:\\mapreduce\\sort_out"</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> bl = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bl ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(configuration, <span class="keyword">new</span> JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h1><p><strong>概念：</strong></p>
<p>​    每一个 map 都可能会产生大量的本地输出，Combiner 的作用就是对 map 端的输出先做一次合并，以减少在 map 和 reduce 节点之间的数据传输量，以提高网络IO 性能，是 MapReduce 的一种优化手段之一</p>
<ul>
<li>combiner 是 MR 程序中 Mapper 和 Reducer 之外的一种组件</li>
<li>combiner 组件的父类就是 Reducer</li>
<li>combiner 和 reducer 的区别在于运行的位置<ul>
<li>Combiner 是在每一个 maptask 所在的节点运行</li>
<li>Reducer 是接收全局所有 Mapper 的输出结果</li>
</ul>
</li>
<li>combiner 的意义就是对每一个 maptask 的输出进行局部汇总，以减小网络传输量</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>自定义一个 combiner 继承 Reducer，重写 reduce 方法（与之前步骤几乎一致）</li>
<li>在 job 中设置 <code>job.setCombinerClass(CustomCombiner.class)</code></li>
</ol>
<p>Combiner 能够应用的前提是不能影响最终的业务逻辑，而且，combiner 的输出 kv 应该跟 reducer 的输入 kv 类型要对应起来</p>
<h2 id="Mapper-2"><a href="#Mapper-2" class="headerlink" title="Mapper"></a>Mapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Text text = <span class="keyword">new</span> Text();</span><br><span class="line">        LongWritable longWritable = <span class="keyword">new</span> LongWritable();</span><br><span class="line">        String[] split = value.toString().split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            text.set(s);</span><br><span class="line">            longWritable.set(<span class="number">1</span>);</span><br><span class="line">            context.write(text,longWritable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyCombiner"><a href="#MyCombiner" class="headerlink" title="MyCombiner"></a>MyCombiner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCombiner</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key,<span class="keyword">new</span> LongWritable(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reducer-2"><a href="#Reducer-2" class="headerlink" title="Reducer"></a>Reducer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinerReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key,<span class="keyword">new</span> LongWritable(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JobMain-2"><a href="#JobMain-2" class="headerlink" title="JobMain"></a>JobMain</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Job job = Job.getInstance(<span class="keyword">super</span>.getConf(), <span class="string">"mapreduce_combiner"</span>);</span><br><span class="line"> </span><br><span class="line">        job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(<span class="string">"d:\\mapreduce\\combiner_in"</span>));</span><br><span class="line"> </span><br><span class="line">        job.setMapperClass(CombinerMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        job.setCombinerClass(MyCombiner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        job.setReducerClass(CombinerReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(<span class="string">"d:\\mapreduce\\combiner_out"</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> bl = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bl ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(configuration, <span class="keyword">new</span> JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_05(MapReduce基础和入门案例(单词统计))</title>
    <url>/2020/08/11/%E5%A4%A7%E6%95%B0%E6%8D%AE-05/</url>
    <content><![CDATA[<p>本篇总结MapReduce的入门基础知识。</p>
<a id="more"></a>

<hr>
<h1 id="MapReduce介绍"><a href="#MapReduce介绍" class="headerlink" title="MapReduce介绍"></a>MapReduce介绍</h1><p>MapReduce的核心思想是“分而治之”，适用于大量复杂的任务处理场景。</p>
<ul>
<li><p>Map负责“分”，即把复杂的任务分解为若干“简单的任务”来并行处理。可以进行拆分的前提是这些小任务可以并行计算，彼此间几乎没有依赖关系。</p>
</li>
<li><p>Reduce负责“合”，即对Map阶段的结果进行全局汇总。</p>
</li>
<li><p>MapReduce运行在Yarn集群，是一个“主从” 结构。</p>
<ol>
<li>ResourceManager</li>
<li>NodeManager</li>
</ol>
<p>这两个阶段合起来正是MapReduce思想的体现。</p>
</li>
</ul>
<img src="/2020/08/11/%E5%A4%A7%E6%95%B0%E6%8D%AE-05/1.png" class>

<h2 id="MapReduce设计构思"><a href="#MapReduce设计构思" class="headerlink" title="MapReduce设计构思"></a>MapReduce设计构思</h2><p>MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。</p>
<p>​    MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。为程序员提供一个抽象和高层的编程接口和框架。程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理：</p>
<p>​    Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是&lt;key,value&gt;键值对。</p>
<ul>
<li>Map: <code>(k1; v1) → [(k2; v2)]</code></li>
<li>Reduce: <code>(k2; [v2]) → [(k3; v3)]</code></li>
</ul>
<p>一个完整的mapreduce程序在分布式运行时有三类实例进程：</p>
<ol>
<li><code>MRAppMaster</code> 负责整个程序的过程调度及状态协调</li>
<li><code>MapTask</code> 负责map阶段的整个数据处理流程</li>
<li><code>ReduceTask</code> 负责reduce阶段的整个数据处理流程</li>
</ol>
<img src="/2020/08/11/%E5%A4%A7%E6%95%B0%E6%8D%AE-05/2.png" class>

<h1 id="MapReduce编程规范"><a href="#MapReduce编程规范" class="headerlink" title="MapReduce编程规范"></a>MapReduce编程规范</h1><p>MapReduce的开发一共有8个步骤：</p>
<h2 id="Map阶段2个步骤"><a href="#Map阶段2个步骤" class="headerlink" title="Map阶段2个步骤"></a>Map阶段2个步骤</h2><ul>
<li>设置InputFormat类，将数据切分为 key-value(<strong>K1</strong>和<strong>V1</strong>)对，输入到第二步</li>
<li>自定义Map逻辑，将第一步的结果转换成另一种的key-value(<strong>K2</strong>和<strong>V2</strong>)对，输出结果</li>
</ul>
<h2 id="Shuffle阶段4个步骤"><a href="#Shuffle阶段4个步骤" class="headerlink" title="Shuffle阶段4个步骤"></a>Shuffle阶段4个步骤</h2><ul>
<li>对输出的key-value对进行<strong>分区</strong></li>
<li>对不同分区的数据按照相同的Key<strong>排序</strong></li>
<li>（可选）对分组过的数据初步<strong>规约</strong>，降低数据的网络拷贝</li>
<li>对数据进行<strong>分组</strong>，相同Key的Value放入一个集合中</li>
</ul>
<h2 id="Reduce阶段2个步骤"><a href="#Reduce阶段2个步骤" class="headerlink" title="Reduce阶段2个步骤"></a>Reduce阶段2个步骤</h2><ul>
<li>对多个Map任务的结果进行排序以及合并，编写Reduce函数实现自己的逻辑，对输入的Key-Value进行处理，转为新的Key-Value（K3 和 V3）输出</li>
<li>设置OutputFormat处理并保存Reduce输出的 Key-Value数据</li>
</ul>
<h1 id="入门案例：单词统计"><a href="#入门案例：单词统计" class="headerlink" title="入门案例：单词统计"></a>入门案例：单词统计</h1><h2 id="数据格式准备"><a href="#数据格式准备" class="headerlink" title="数据格式准备"></a>数据格式准备</h2><h3 id="创建一个新的文件"><a href="#创建一个新的文件" class="headerlink" title="创建一个新的文件"></a>创建一个新的文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;export&#x2F;servers</span><br><span class="line">vim wordcount.txt</span><br></pre></td></tr></table></figure>

<h3 id="向其中放入以下内容并保存"><a href="#向其中放入以下内容并保存" class="headerlink" title="向其中放入以下内容并保存"></a>向其中放入以下内容并保存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,world,hadoop</span><br><span class="line">hive,sqoop,flume,hello</span><br><span class="line">kitty,tom,jerry,world</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure>

<h3 id="上传到-HDFS"><a href="#上传到-HDFS" class="headerlink" title="上传到 HDFS"></a>上传到 HDFS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir &#x2F;wordcount&#x2F;</span><br><span class="line">hdfs dfs -put wordcount.txt &#x2F;wordcount&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="具体程序代码实现"><a href="#具体程序代码实现" class="headerlink" title="具体程序代码实现"></a>具体程序代码实现</h2><h3 id="WordCountMapper-java"><a href="#WordCountMapper-java" class="headerlink" title="WordCountMapper.java"></a>WordCountMapper.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 其中 Mapper类的四个泛型解释：</span></span><br><span class="line"><span class="comment">* KETIN：K1的类型</span></span><br><span class="line"><span class="comment">* VALUEIN:V1的类型</span></span><br><span class="line"><span class="comment">* KEYOUT:K2的类型</span></span><br><span class="line"><span class="comment">* VALUEOUT:V2的类型</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用已经给出定义好的类型，基本类型的封装，操作序列化起来更加方便</span></span><br><span class="line"><span class="comment">* &lt;Long, String, Long, String&gt;  - &gt; &lt;LongWritable, Text, Text, LongWritable&gt;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/* map方法就是将 K1 和 V1 转换为 K2 和 V2</span></span><br><span class="line"><span class="comment">    * 参数：</span></span><br><span class="line"><span class="comment">    *   key  : K1 行偏移量</span></span><br><span class="line"><span class="comment">    *   value: V1 每一行的文本数据</span></span><br><span class="line"><span class="comment">    *   context : 上下文对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 如何将 K1 和 V1 转换为 K2 和 V2</span></span><br><span class="line"><span class="comment">    * K1            V1</span></span><br><span class="line"><span class="comment">    * 0         hello,world,hadoop</span></span><br><span class="line"><span class="comment">    * 18        hdfs,hello,hadoop</span></span><br><span class="line"><span class="comment">    * ---------------------------</span></span><br><span class="line"><span class="comment">    * K2           V2</span></span><br><span class="line"><span class="comment">    * hello         1</span></span><br><span class="line"><span class="comment">    * world         1</span></span><br><span class="line"><span class="comment">    * hadoop        1</span></span><br><span class="line"><span class="comment">    * hdfs          1</span></span><br><span class="line"><span class="comment">    * hello         1</span></span><br><span class="line"><span class="comment">    * hadoop        1</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Text text = <span class="keyword">new</span> Text();</span><br><span class="line">        LongWritable longWritable = <span class="keyword">new</span> LongWritable();</span><br><span class="line">        <span class="comment">// 将一行的文本数据进行拆分</span></span><br><span class="line">        String[] split = value.toString().split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">// 遍历数组，组装K2 和 V2</span></span><br><span class="line">        <span class="keyword">for</span> (String word : split) &#123;</span><br><span class="line">            text.set(word);</span><br><span class="line">            longWritable.set(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将 K2 和 V2 写入上下文</span></span><br><span class="line">            context.write(text, longWritable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WordCountReducer-java"><a href="#WordCountReducer-java" class="headerlink" title="WordCountReducer.java"></a>WordCountReducer.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 四个泛型解释：</span></span><br><span class="line"><span class="comment">* KEYIN:K2类型</span></span><br><span class="line"><span class="comment">* VALUEIN:V2类型</span></span><br><span class="line"><span class="comment">* KEYOUT：K3类型</span></span><br><span class="line"><span class="comment">* VALUEOUT：V3类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * reduce方法作用：将新的 K2 和 V2 转换为 K3 和 V3，并写入上下文</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 参数：</span></span><br><span class="line"><span class="comment">    *   key：新 K2</span></span><br><span class="line"><span class="comment">    *   values：集合 新V2</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 如何将新的 K2 和 V2 转换为 K3 和 V3</span></span><br><span class="line"><span class="comment">    * 新 K2          V2</span></span><br><span class="line"><span class="comment">    *   world       &lt;1,1,1&gt;</span></span><br><span class="line"><span class="comment">    *   hello       &lt;1,1&gt;</span></span><br><span class="line"><span class="comment">    *   hadoop      &lt;1&gt;</span></span><br><span class="line"><span class="comment">    * ---------------------</span></span><br><span class="line"><span class="comment">    *   K3          V3</span></span><br><span class="line"><span class="comment">    *   hello       2</span></span><br><span class="line"><span class="comment">    *   world       3</span></span><br><span class="line"><span class="comment">    *   hadoop      1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        LongWritable longWritable = <span class="keyword">new</span> LongWritable();</span><br><span class="line">        <span class="comment">// 遍历values集合，将集合中的数字相加得到 V3</span></span><br><span class="line">        <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 K3 和 V3 写入上下文中</span></span><br><span class="line">        longWritable.set(count);</span><br><span class="line">        context.write(key, longWritable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JobMain-java"><a href="#JobMain-java" class="headerlink" title="JobMain.java"></a>JobMain.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法用于指定一个Job任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个job任务对象</span></span><br><span class="line">        <span class="comment">// 第一个参数是一个configuration，下面的main方法调用时已经传入，存在Configured类中，通过getConf()方法获取</span></span><br><span class="line">        Job job = Job.getInstance(<span class="keyword">super</span>.getConf(), <span class="string">"wordCount"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//job.setJarByClass(JobMain.class); // 如果打包出错，则需要该行代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置job任务对象 (8个步骤)</span></span><br><span class="line">        <span class="comment">//1、指定文件的读取方式和读取路径</span></span><br><span class="line">        job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextInputFormat.addInputPath(job, <span class="keyword">new</span> Path(<span class="string">"hdfs://bigdata1:8020/wordcount"</span>));</span><br><span class="line">        <span class="comment">// 本地执行方法，执行JobMain主函数即可，提前准备好文件，该路径下的wordcount.txt</span></span><br><span class="line">        <span class="comment">//TextInputFormat.addInputPath(job, new Path("file:///D:\\mapReduce\\input"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、指定Map阶段的处理方式 和 数据类型</span></span><br><span class="line">        job.setMapperClass(WordCountMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//设置Map阶段K2的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置Map阶段 V2 的类型</span></span><br><span class="line">        job.setMapOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3，4，5，6采用默认的方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、指定Reduce阶段的处理方式和数据类型</span></span><br><span class="line">        job.setReducerClass(WordCountReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、设置输出类型</span></span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置输出路径，并判断该目录是否存在，存在则删除</span></span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">"hdfs://bigdata1:8020/wordCount_out"</span>);</span><br><span class="line">        TextOutputFormat.setOutputPath(job,path);</span><br><span class="line">        <span class="comment">//TextOutputFormat.setOutputPath(job,new Path("file:///D:\\mapReduce\\output"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断目标目录是否存在</span></span><br><span class="line">        FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.exists(path))&#123;</span><br><span class="line">            fileSystem.delete(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务结束</span></span><br><span class="line">        <span class="keyword">boolean</span> bl = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bl? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 启动 job 任务，实际就是调用上面的run方法</span></span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(configuration, <span class="keyword">new</span> JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>写好程序，有两种运行方式，一种是本地运行，在JobMain函数中注释的部分即是。然后运行主函数即可，这种方法一般用于本地的测试。</p>
<p>另一种是<strong>集群运行</strong>模式</p>
<ul>
<li><p>将MapReduce程序提交给Yarn集群，分发到很多的结点上并执行</p>
</li>
<li><p>处理的数据和输出结果应该位于HDFS文件系统</p>
</li>
<li><p>提交代码的实现步骤：将程序打成jar包并上传到虚拟机服务器上，使用hdfs命令执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar original-mapreduce-1.0-SNAPSHOT.jar(jar包名) JobMain(主函数名，函数右键copy reference)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打成jar包方式：Maven项目里的Lifecycle下的package功能，得到的包位于target目录下，会有两个jar包，体积一大一小，本质并无不同，都可使用上传。</p>
</blockquote>
</li>
</ul>
<p>本程序将结果输出到HDFS的/wordCount_out目录下，可以 <code>http://bigdata1:50070/explorer.html#/</code>下查看。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_04(HDFS_API操作)</title>
    <url>/2020/08/10/%E5%A4%A7%E6%95%B0%E6%8D%AE-04/</url>
    <content><![CDATA[<p>本篇总结HDFS在windows操作系统Java环境下的API操作。</p>
<a id="more"></a>

<hr>
<h1 id="HDFS的Java-api操作"><a href="#HDFS的Java-api操作" class="headerlink" title="HDFS的Java_api操作"></a>HDFS的Java_api操作</h1><h2 id="配置Windows下的-Hadoop环境"><a href="#配置Windows下的-Hadoop环境" class="headerlink" title="配置Windows下的 Hadoop环境"></a>配置Windows下的 Hadoop环境</h2><p>在Windows系统需要配置Hadoop运行环境，相当于Windows是一个Hadoop客户端。</p>
<p>不配置而直接运行代码会出现以下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Could not locate executable null\bin\winutils.exe <span class="keyword">in</span> the hadoop binaries</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong> 缺少winutils.exe</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Unable to load native-hadoop library <span class="keyword">for</span> your platform..using <span class="built_in">builtin</span>-Java classes <span class="built_in">where</span> applicable</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong> 缺少hadoop.dll</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><strong>1、</strong>首先下载Hadoop在Windows上的工具包，下载地址：<a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">https://github.com/steveloughran/winutils</a> 。</p>
<p><strong>2、</strong>得到后，将其解压到一个无中文无空格的目录下，并配置环境变量。</p>
<img src="/2020/08/10/%E5%A4%A7%E6%95%B0%E6%8D%AE-04/1.png" class>

<p>Path下添加：<code>%HADOOP_HOME%\bin</code></p>
<p><strong>3、</strong>将下载的包内的 <code>hadoop.dll</code> 拷贝一份到 C:\Windows\System32 目录下。</p>
<p><strong>4、</strong> 重启电脑，完成。</p>




<h2 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">minimizeJar</span>&gt;</span>true<span class="tag">&lt;/<span class="name">minimizeJar</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用URL方式访问数据（了解）"><a href="#使用URL方式访问数据（了解）" class="headerlink" title="使用URL方式访问数据（了解）"></a>使用URL方式访问数据（了解）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">urlHDFS</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 注册URL</span></span><br><span class="line">    URL.setURLStreamHandlerFactory(<span class="keyword">new</span> FsUrlStreamHandlerFactory());</span><br><span class="line">    <span class="comment">//获取hdfs文件的输入流</span></span><br><span class="line">    InputStream inputStream = <span class="keyword">new</span> URL(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>).openStream();</span><br><span class="line">    <span class="comment">// 获取本地文件的输出流</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:\\hello.txt"</span>));</span><br><span class="line">    <span class="comment">// 实现文件的拷贝</span></span><br><span class="line">    IOUtils.copy(inputStream, fileOutputStream);</span><br><span class="line">    <span class="comment">// 关流</span></span><br><span class="line">    IOUtils.closeQuietly(inputStream);</span><br><span class="line">    IOUtils.closeQuietly(fileOutputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用文件系统方式访问数据（掌握）"><a href="#使用文件系统方式访问数据（掌握）" class="headerlink" title="使用文件系统方式访问数据（掌握）"></a>使用文件系统方式访问数据（掌握）</h2><h3 id="涉及的主要类"><a href="#涉及的主要类" class="headerlink" title="涉及的主要类"></a>涉及的主要类</h3><p>在Java中操作HDFS，主要涉及以下Class：</p>
<ul>
<li><p><code>Configuration</code>：该类的对象封装了客户端或者服务器的配置</p>
</li>
<li><p><code>FileSystem</code>：该类的对象是一个文件系统对象，可以用该对象的一些方法来对文件进行操作，通过FileSystem的静态方法 get 获得该对象</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">FileSystem fs = FileSystem.get(conf) # 就是Configuration类的对象</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get</code> 方法从 <code>conf</code> 中的一个参数 <code>fs.defaultFS</code> 的配置值判断具体是什么类型的文件系统</li>
<li>如果我们的代码中没有指定<code>fs.defaultFS</code>，并且工程ClassPath下也没有给定相应的配置，<code>conf</code>中的默认值来自于Hadoop的Jar包中的<code>core-default.xml</code></li>
<li>默认值为<code>file:///</code>，则获取的不是一个DistributedFileSystem的实例，而是一个本地文件系统的客户端对象</li>
</ul>
</li>
</ul>
<h3 id="获取FileSystem的四种方式"><a href="#获取FileSystem的四种方式" class="headerlink" title="获取FileSystem的四种方式"></a>获取FileSystem的四种方式</h3><ul>
<li><p>第一种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFileSystem1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Configuration对象，封装</span></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// 设置文件系统类型</span></span><br><span class="line">    configuration.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://bigdata1:8020"</span>);</span><br><span class="line">    <span class="comment">// 获取指定的文件系统</span></span><br><span class="line">    FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">    <span class="comment">// 输出 DFS[DFSClient[clientName=DFSClient_NONMAPREDUCE_373282607_1, ugi=11655 (auth:SIMPLE)]]</span></span><br><span class="line">    System.out.println(fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFileSystem2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    System.out.println(fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFileSystem3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Configuration对象</span></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// 设置文件系统类型</span></span><br><span class="line">    configuration.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://bigdata1:8020"</span>);</span><br><span class="line">    <span class="comment">// 获取指定的文件系统</span></span><br><span class="line">    FileSystem fileSystem = FileSystem.newInstance(configuration);</span><br><span class="line">    <span class="comment">// 输出 DFS[DFSClient[clientName=DFSClient_NONMAPREDUCE_373282607_1, ugi=11655 (auth:SIMPLE)]]</span></span><br><span class="line">    System.out.println(fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFileSystem4</span><span class="params">()</span> <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">    FileSystem fileSystem = FileSystem.newInstance(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    System.out.println(fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：1、3比较相似，2、4比较相似，主要是get方法和 newInstance方法的使用</p>
</blockquote>
<p>这里对Configuration参数对象的加载机制作出解释：</p>
<ol>
<li>首先构造时会加载jar包的默认配置，如：xxx-default.xml</li>
<li>再加载用户配置的文件（必须放在resources资源目录下），如自定义的hdfs-site.xml</li>
<li>最后可以手动设置，覆盖之前的相同有关配置：configuration.set(“dfs.blocksize”, “64m”);</li>
</ol>
<h3 id="遍历HDFS所有文件信息"><a href="#遍历HDFS所有文件信息" class="headerlink" title="遍历HDFS所有文件信息"></a>遍历HDFS所有文件信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取FileSystem实例</span></span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="comment">// 调用方法listFiles 获取一个目录下的文件信息，为一个迭代器对象</span></span><br><span class="line">    <span class="comment">// 第一个参数：指定目录</span></span><br><span class="line">    <span class="comment">// 第二个参数，是否迭代获取</span></span><br><span class="line">    RemoteIterator&lt;LocatedFileStatus&gt; iterator = fileSystem.listFiles(<span class="keyword">new</span> Path(<span class="string">"/"</span>), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//遍历迭代器，获取文件的详细信息</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        LocatedFileStatus fileStatus = iterator.next();</span><br><span class="line">        <span class="comment">// 获取文件的绝对路径："hdfs://bigdata1:8020/xxx"</span></span><br><span class="line">        System.out.println(fileStatus.getPath() + <span class="string">"  ---  "</span> + fileStatus.getPath().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件的Block信息</span></span><br><span class="line">        BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">        System.out.println(<span class="string">"Block数："</span> + blockLocations.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HDFS创建文件夹"><a href="#HDFS创建文件夹" class="headerlink" title="HDFS创建文件夹"></a>HDFS创建文件夹</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="comment">// 创建文件夹</span></span><br><span class="line">    <span class="keyword">boolean</span> bl = fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">"/aaa/bbb/ccc"</span>));</span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    fileSystem.create(<span class="keyword">new</span> Path(<span class="string">"/aaa/aaa.txt"</span>));</span><br><span class="line">    <span class="comment">// 两个创建方法都为递归创建</span></span><br><span class="line">    System.out.println(bl);</span><br><span class="line">    fileSystem.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取FileSystem</span></span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hdfs的输入流 </span></span><br><span class="line">    FSDataInputStream inputStream = fileSystem.open(<span class="keyword">new</span> Path(<span class="string">"/a.txt"</span>));</span><br><span class="line">    <span class="comment">// 获取本地路径的输出流 </span></span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://a.txt"</span>);</span><br><span class="line">    <span class="comment">// 文件的拷贝 </span></span><br><span class="line">    IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    <span class="comment">// 关闭流 </span></span><br><span class="line">    IOUtils.closeQuietly(inputStream); </span><br><span class="line">    IOUtils.closeQuietly(outputStream); </span><br><span class="line">    fileSystem.close(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现文件的下载 2</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadFile2</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    fileSystem.copyToLocalFile(<span class="keyword">new</span> Path(<span class="string">"/a.txt"</span>), <span class="keyword">new</span> Path(<span class="string">"D://a.txt"</span>));</span><br><span class="line">    fileSystem.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    fileSystem.copyFromLocalFile(<span class="keyword">new</span> Path(<span class="string">"D://b.txt"</span>),<span class="keyword">new</span> Path(<span class="string">"/"</span>));</span><br><span class="line">    fileSystem.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HDFS的权限访问控制"><a href="#HDFS的权限访问控制" class="headerlink" title="HDFS的权限访问控制"></a>HDFS的权限访问控制</h3><p>首先进入Hadoop的安装目录下的/etc/hadoop/hdfs-site.xml，修改permission为true，代表启动权限。启动后通过命令行的权限修改才能生效，修改配置文件需要重启才能生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -chmod 000 /a.txt</span><br></pre></td></tr></table></figure>

<p>数字代表权限等级，当开启权限控制时，文件会有其对应的Owner，不是相应的Owner仍然无法访问资源。这时我们可以在get方法内指定伪装用户对资源进行访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration(), <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="小文件合并"><a href="#小文件合并" class="headerlink" title="小文件合并"></a>小文件合并</h3><p>由于Hadoop擅长存储大文件，因为大文件的元数据信息比较少。如果集群中有大量的小文件，则需要维护大量的元数据，增大内存压力。所以有必要将小文件合并成大文件一起处理。</p>
<p>在HDFS的Shell命令下，可以用如下命令讲很多HDFS文件合并成一个大文件下载到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers</span><br><span class="line">hdfs dfs -getmerge /config/*.xml ./hello.xml # 表示合并文件，下载到当前目录下的hello.xml</span><br></pre></td></tr></table></figure>

<p>同样也可以在上传时将小文件合并到一个大文件里面去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeFile</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取FileSystem</span></span><br><span class="line">    FileSystem fileSystem = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://bigdata1:8020/a.txt"</span>), <span class="keyword">new</span> Configuration(), <span class="string">"root"</span>);</span><br><span class="line">    <span class="comment">// 获取hdfs大文件的输出流，创建一个承载所有内容的大文件</span></span><br><span class="line">    FSDataOutputStream outputStream = fileSystem.create(<span class="keyword">new</span> Path(<span class="string">"/big.txt"</span>));</span><br><span class="line">    <span class="comment">// 获取一个本地文件系统</span></span><br><span class="line">    LocalFileSystem localFileSystem = FileSystem.getLocal(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="comment">// 获取本地文件夹下所有文件的详情,input是提前准备的文件夹，里面有一些小文件</span></span><br><span class="line">    FileStatus[] fileStatuses = localFileSystem.listStatus(<span class="keyword">new</span> Path(<span class="string">"D:\\input"</span>));</span><br><span class="line">    <span class="comment">// 遍历每个文件，获得每个文件的输入流</span></span><br><span class="line">    <span class="keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;</span><br><span class="line">        FSDataInputStream inputStream = localFileSystem.open(fileStatus.getPath());</span><br><span class="line">        <span class="comment">// 将小文件的数据复制到大文件</span></span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">        IOUtils.closeQuietly(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    IOUtils.closeQuietly(outputStream);</span><br><span class="line">    localFileSystem.close();</span><br><span class="line">    fileSystem.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDFS的高可用机制"><a href="#HDFS的高可用机制" class="headerlink" title="HDFS的高可用机制"></a>HDFS的高可用机制</h1><p>在Hadoop2.X之前，Namenode是HDFS集群中可能发生单点故障的节点，每个HDFS集群只有一个namenode，一旦这个节点不可用，则整个HDFS集群将处于不可用状态。<br>HDFS高可用（HA）方案就是为了解决上述问题而产生的，在HA HDFS集群中会同时运行两个Namenode，一个作为活动的Namenode（Active），一个作为备份的Namenode（Standby）。备份的Namenode的命名空间与活动的Namenode是实时同步的，所以当活动的Namenode发生故障而停止服务时，备份Namenode可以立即切换为活动状态，而不影响HDFS集群服务。</p>
<p>详情：<a href="https://blog.csdn.net/u012736748/article/details/79534019" target="_blank" rel="noopener">https://blog.csdn.net/u012736748/article/details/79534019</a></p>
<h1 id="Hadoop联邦机制"><a href="#Hadoop联邦机制" class="headerlink" title="Hadoop联邦机制"></a>Hadoop联邦机制</h1>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_03(HDFS基础)</title>
    <url>/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/</url>
    <content><![CDATA[<p>本篇开始学习大数据Hadoop技术中的<strong>核心</strong>之一 —— HDFS。</p>
<a id="more"></a>

<hr>
<h1 id="HDFS概述"><a href="#HDFS概述" class="headerlink" title="HDFS概述"></a>HDFS概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HDFS （Hadoop Distributed File System）是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p>
<h2 id="HDFS设计原则"><a href="#HDFS设计原则" class="headerlink" title="HDFS设计原则"></a>HDFS设计原则</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul>
<li><strong>存储非常大的文件</strong>：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考<a href="https://wiki.apache.org/hadoop/PoweredBy" target="_blank" rel="noopener">Hadoop官网</a>.</li>
<li><strong>采用流式的数据访问方式</strong>: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作<br>分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。</li>
<li><strong>运行于商业硬件上</strong>: Hadoop不需要特别贵的、reliable的（可靠的）机器，可运行于普通商用机器（可以从多家供应商采购） ，商用机器不代表低端机器。在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。</li>
</ul>
<h3 id="HDFS不适合的应用类型"><a href="#HDFS不适合的应用类型" class="headerlink" title="HDFS不适合的应用类型"></a>HDFS不适合的应用类型</h3><p>有些场景不适合使用HDFS来存储数据。下面列举几个：</p>
<p>1） <strong>低延时的数据访问</strong><br>对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。</p>
<p>2）<strong>大量小文件</strong><br>文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。<br>经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。</p>
<p>3）<strong>多方读写，需要任意的文件修改</strong><br>HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。</p>
<h1 id="HDFS的架构"><a href="#HDFS的架构" class="headerlink" title="HDFS的架构"></a>HDFS的架构</h1><p>HDFS是一个 主 / 从（Master / Slave）体系结构。</p>
<p>HDFS由四部分组成，HDFS Client、NameNode，DataNode 和 Secondary NameNode。</p>
<h2 id="1、Client：就是客户端"><a href="#1、Client：就是客户端" class="headerlink" title="1、Client：就是客户端"></a>1、Client：就是客户端</h2><ul>
<li>文件切片。文件上传到HDFS时，Client将文件切分成一个一个的 Block进行存储。</li>
<li>与NameNode交互，获取文件的位置信息。</li>
<li>与DataNode交互，读取或者写入数据。</li>
<li>Client提供一些命令来管理和访问HDFS，比如启动或关闭HDFS。</li>
</ul>
<h2 id="2、NameNode：就是Master，是一个主管、管理者"><a href="#2、NameNode：就是Master，是一个主管、管理者" class="headerlink" title="2、NameNode：就是Master，是一个主管、管理者"></a>2、NameNode：就是Master，是一个主管、管理者</h2><ul>
<li>管理HDFS的名称空间 和 文件数据块（Block）的映射信息，整个HDFS可存储的文件数受限于NameNode的内存大小。在内存中加载文件系统中每个文件和每个数据块的引用关系（文件、Block 和 DataNode之间的映射关系），数据会定期保存在本地磁盘（fsImage 镜像 文件 和 edits 日志 文件）。</li>
<li>配置副本策略：文件数据块到底存放到那些DataNode上，是由NameNode决定的，它根据全局情况做出放置副本的决定。</li>
<li>处理客户端读写请求。数据流不经过NameNode，会询问它与那个DataNode联系</li>
<li>NameNode心跳机制：DataNode定期发给NameNode一个个包，称为心跳机制。若NameNode没有收到，则认为相应的DataNode已经宕机，这时候NN准备要把DN上的数据块进行重新复制</li>
</ul>
<h2 id="3、DataNode-：就是Slave。"><a href="#3、DataNode-：就是Slave。" class="headerlink" title="3、DataNode ：就是Slave。"></a>3、DataNode ：就是Slave。</h2><p>Name Node下达命令，DataNode执行</p>
<ul>
<li>存储实际的数据块</li>
<li>执行数据的 读/写 操作</li>
<li>周期性的向NameNode汇报心跳信息、数据块信息 和 缓存数据块信息</li>
</ul>
<h2 id="4、Secondary-NameNode"><a href="#4、Secondary-NameNode" class="headerlink" title="4、Secondary NameNode"></a>4、Secondary NameNode</h2><p>并非NameNode的热备。当NameNode挂掉时，它并不能马上替换NameNode并提供服务。</p>
<ul>
<li>辅助NameNode，分担其工作量。</li>
<li>定期合并fsimage 和 fsedits，并推送给NameNode。</li>
</ul>
<img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/1.gif" class>

<h1 id="HDFS的副本机制和机架感知"><a href="#HDFS的副本机制和机架感知" class="headerlink" title="HDFS的副本机制和机架感知"></a>HDFS的副本机制和机架感知</h1><h2 id="HDFS文件副本机制"><a href="#HDFS文件副本机制" class="headerlink" title="HDFS文件副本机制"></a>HDFS文件副本机制</h2><p>所有文件都是以 Block 块的方式存放在HDFS文件系统中，作用如下：</p>
<ol>
<li>一个文件可能大于集群中任意一个磁盘，引入块机制分布存储可以解决该问题。</li>
<li>使用块作为文件存储的逻辑单位可以简化存储子系统</li>
<li>块非常适用于数据备份进而提供数据容错能力</li>
</ol>
<p>Block的块大小可以通过hdfs-site.xml当中的配置文件进行指定，默认128M。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.block.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>块大小 以字节为单位<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="机架感知"><a href="#机架感知" class="headerlink" title="机架感知"></a>机架感知</h2><p>HDFS分布式文件系统的内部有一个副本存放策略：以默认的副本数 = 3 为例：</p>
<p>1、第一个副本块存本机</p>
<p>2、第二个副本块跟本机同机架内的其他服务器结点</p>
<p>3、第三个副本块存不同机架的一个服务器结点上</p>
<h1 id="HDFS的命令行使用"><a href="#HDFS的命令行使用" class="headerlink" title="HDFS的命令行使用"></a>HDFS的命令行使用</h1><p>首先是服务的启动关闭命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭所有服务</span></span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure>

<p>hdfs命令是操作HDFS文件系统上的资源，只要打开了HDFS服务，就可使用命令行操作，与当前所在的Linux目录无关。</p>
<p><code>ls</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式：hdfs dfs -ls URI</span><br><span class="line">作用：类似于Linux的ls命令，显示文件列表</span><br><span class="line"></span><br><span class="line">hdfs dfs -ls /</span><br></pre></td></tr></table></figure>

<p><code>ls -R</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -ls -R URI</span><br><span class="line">作用 ： 在整个目录下递归执行ls，与UNIX中的ls-R类似</span><br><span class="line"></span><br><span class="line">hdfs dfs -ls -R /</span><br></pre></td></tr></table></figure>

<p><code>mkdir</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs [-p] -mkdir &lt;paths&gt;</span><br><span class="line">作用 ： 以&lt;paths&gt;中的URI作为参数，创建目录。使用-p参数可以递归创建目录</span><br><span class="line"></span><br><span class="line">hdfs dfs -mkdir /TestDir1</span><br><span class="line">hdfs dfs -mkdir -p /TestDir2/test</span><br></pre></td></tr></table></figure>

<p>在hdfs文件系统中，可以通过50070端口查看文件系统的结构。</p>
<img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/2.png" class>

<p><code>put</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -put &lt;localsrc&gt; ... &lt;dst&gt;</span><br><span class="line">作用 ： 将单个的源文件src或者多个源文件srcs从本地文件系统拷贝到目标文件系统中（&lt;dst&gt;对应的目录）。也可以从标准输入中读取输入，写入目标文件系统中。</span><br><span class="line"></span><br><span class="line">hdfs dfs -put  /home/a.txt  /TestDir1</span><br></pre></td></tr></table></figure>

<p><code>moveFromLocal</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -moveFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line">作用 ： 和put命令类似，但put相当于复制，此命令相当于将本地文件 剪切 到hdfs中。</span><br><span class="line"></span><br><span class="line">hdfs dfs -moveFromLocal a.txt /TestDir2</span><br></pre></td></tr></table></figure>

<p><code>get</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -get [-ignorecrc] [-crc] &lt;src&gt; &lt;localhost&gt;</span><br><span class="line">作用 ： 将文件拷贝到本地文件系统，CRC 校验失败的文件通过-ignorecrc选项进行忽略 拷贝。</span><br><span class="line"></span><br><span class="line">hdfs dfs -get /TestDir2/a.txt ./</span><br></pre></td></tr></table></figure>

<p><code>mv</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -mv URI &lt;dst&gt;</span><br><span class="line">作用 ： 将hdfs上的文件从原路径移动到目标路径（移动之后文件删除），该命令不能跨文件系统</span><br><span class="line"></span><br><span class="line">hdfs dfs -mv /TestDir2/a.txt /TestDir1</span><br></pre></td></tr></table></figure>

<p><code>rm</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -rm [-r] [skipTrash] URI [URI...]</span><br><span class="line">作用 ： 删除参数指定的文件，参数可以有多个。 -r 表示删除目录 ， -skipTrash 表示删除后不放入回收站</span><br><span class="line"></span><br><span class="line">hdfs dfs -rm /TestDir1/a.txt</span><br><span class="line">hdfs dfs -rm -r /TestDir1</span><br></pre></td></tr></table></figure>

<img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/3.png" class>

<p><code>cp</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -cp URI [URI ...] &lt;dest&gt;</span><br><span class="line">作用 ： 将文件拷贝到目标路径中，如果&lt;dest&gt;为目录的话，可以将多个文件拷贝到该目录下</span><br><span class="line">-f : 选项将覆盖目标，如果他已经存在。</span><br><span class="line">-p : 选项将保留文件属性(时间戳，所有权，许可，ACL，XAttr)</span><br><span class="line"></span><br><span class="line">hdfs dfs -cp /TestDir1/a.txt /TestDir2/b.txt</span><br></pre></td></tr></table></figure>

<p><code>cat</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -cat URI [uri...]</span><br><span class="line">作用 ： 将参数所指示的文件内容输出到控制台</span><br><span class="line"></span><br><span class="line">hdfs dfs -cat /TestDir1/a.txt</span><br></pre></td></tr></table></figure>

<p><code>chmod</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -chmod [-R] URI[URI...]</span><br><span class="line">作用 ： 改变文件权限。如果使用 -R 选项，则对整个目录有效递归执行。使用这一命令的用户必须是文件的所属用户，或者超级用户。</span><br><span class="line"></span><br><span class="line">hdfs dfs -chmod -R 777 /TestDir1</span><br></pre></td></tr></table></figure>

<p><code>chown</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -chmod [-R] URI[URI...]</span><br><span class="line">作用 ： 改变文件的所属用户和用户组。如果使用 -R 选项，则对整个目录有效递归执行。使用这一命令必须是文件的所属用户或者超级管理员。</span><br><span class="line"></span><br><span class="line">hdfs dfs -chown hadoop:hadoop /TestDir2/test</span><br></pre></td></tr></table></figure>

<p><code>appendToFile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式 ： hdfs dfs -appendToFile &lt;localsrc&gt; ... &lt;dest&gt;</span><br><span class="line">作用 ： 追加一个或者多个文件到hdfs指定文件中。也可以从命令行读取输入</span><br><span class="line"></span><br><span class="line">hdfs dfs -appendToFile a.xml b.xml /TestDir2/big.xml</span><br><span class="line">将本地的a b文件合并一起，存为TestDir2下的 big.xml</span><br></pre></td></tr></table></figure>

<h1 id="HDFS的高级使用命令"><a href="#HDFS的高级使用命令" class="headerlink" title="HDFS的高级使用命令"></a>HDFS的高级使用命令</h1><h2 id="HDFS文件限额配置"><a href="#HDFS文件限额配置" class="headerlink" title="HDFS文件限额配置"></a>HDFS文件限额配置</h2><p>在多人共用HDFS的 环境下，配置设置非常重要。特别是在Hadoop处理大量资料的环境，如果没有配额管理，很容易把所有空间用完造成别人无法存取。HDFS的配额设定是针对目录而不是账号，可以让每个账号仅操作某一个目录，然后对目录设置配置。</p>
<p>HDFS文件的限额配置允许我们以文件个数，或者文件大小来限制我们在某个目录上传的 文件数量或者文件内容总量，以便达到我们类似网盘等限制每个用户允许上传的最大的文件的量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir /user/root/dir</span><br><span class="line"></span><br><span class="line">hdfs dfs -count -q -h dir # 查看某个目录是否具有限额配置</span><br><span class="line">其中路径可以用绝对路径/user/root/dir，相对路径则直接写dir，因为HDFS默认即在user/root/目录下</span><br></pre></td></tr></table></figure>

<h3 id="数量限额"><a href="#数量限额" class="headerlink" title="数量限额"></a>数量限额</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -setQuota 2 dir # 设置该文件下最多只能上传两个文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：设置为2，但只能上传 1 个文件，设置为 n，上传 n - 1</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -clrQuota dir # 清除文件数量限额</span><br></pre></td></tr></table></figure>

<h3 id="空间大小限额"><a href="#空间大小限额" class="headerlink" title="空间大小限额"></a>空间大小限额</h3><p>在设置空间配额时，设置的 空间至少是Block_size * 3（128 * 3 = 384M）大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -setSpaceQuota 4k /user/root/dir # 限制空间大小4KB，报错，至少384M</span><br><span class="line"></span><br><span class="line">hdfs dfsadmin -clrSpaceQuota dir # 清除空间限额配置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成任意大小的文件命令：</span></span><br><span class="line">dd if=/dev/zero of=1.txt bs=129M count=1 # bs * count 便是想要文件的大小</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：129M需要被分为两个Block（128M 和 1M），空间限额至少为 2 * 3 * Block_size = 768M。</p>
</blockquote>
<h2 id="HDFS的安全模式"><a href="#HDFS的安全模式" class="headerlink" title="HDFS的安全模式"></a>HDFS的安全模式</h2><p>安全模式是Hadoop的一种保护机制，用于保证集群中的数据块的安全性。当集群启动时，会首先进入安全模式。当系统出于安全模式时会检查数据块的完整性。</p>
<p>假设我们设置的副本数（即参数dfs.replication）是 3，那么在DataNode上就应该有 3 个副本，若只存在 2 个副本，那么比例就是 2 / 3 , HDFS默认的副本率为0.999，小于副本率，系统会自动的复制副本到其他DataNode。若系统超过我们设定的副本数，那么系统也会删除多余的副本。</p>
<p>在安全模式下，文件系统只接受<strong>读</strong>数据请求，而不接受删除、修改等变更请求。当整个系统达到安全标准时，HDFS会自动离开安全模式。</p>
<p><strong>安全模式操作命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -safemode get		# 查看安全模式状态</span><br><span class="line">hdfs dfsadmin -safemode enter	# 进入安全模式</span><br><span class="line">hdfs dfsadmin -safemode leave	# 离开安全模式</span><br></pre></td></tr></table></figure>

<h2 id="HDFS基准测试"><a href="#HDFS基准测试" class="headerlink" title="HDFS基准测试"></a>HDFS基准测试</h2><p>实际生产环境中，Hadoop环境搭建完成后，第一件事情就是进行压力测试，测试我们的集群的读取和写入速度，测试我们的网络带宽是否满足一些测试基准</p>
<h3 id="测试写入速度"><a href="#测试写入速度" class="headerlink" title="测试写入速度"></a>测试写入速度</h3><p>向HDFS文件系统中写入数据，10文件，每个文件 10M ，文件存放的地点：／benchmarks/TestDFSIO中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/ # 测试会生成结果文件，放到该目录下</span><br><span class="line">hadoop jar /export/servers/hadoop-2.7.7/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.7.7.jar TestDFSIO -write -nrFiles 10 -fileSize 10MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TestDFSIO：测试DFS的IO</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -write：测试写</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nrFiles：写入文件数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fileSize：每个文件的大小</span></span><br></pre></td></tr></table></figure>

<p>命令执行完，该目录下生成测试结果的文件<code>TestDFSIO_results.log</code>，可以通过vi命令查看。</p>
<img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/4.png" class>

<p>也可通过命令查看写入速度结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -text /benchmarks/TestDFSIO/io_write/part-00000</span><br></pre></td></tr></table></figure>

<h3 id="测试读取速度"><a href="#测试读取速度" class="headerlink" title="测试读取速度"></a>测试读取速度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /export/servers/hadoop-2.7.7/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.7.7.jar TestDFSIO -read -nrFiles 10 -fileSize 10MB</span><br></pre></td></tr></table></figure>

<p>只需把 write 改为 read即可，其他文件查看等与上步一致。</p>
<h3 id="清除测试数据"><a href="#清除测试数据" class="headerlink" title="清除测试数据"></a>清除测试数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /export/servers/hadoop-2.7.7/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.7.7.jar TestDFSIO clean</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：清除的是测试文件，但benchmarks还在，里面的数据清空；同样，TestDFSIO_results.log 也在。</p>
</blockquote>
<h1 id="HDFS的写入和读取过程"><a href="#HDFS的写入和读取过程" class="headerlink" title="HDFS的写入和读取过程"></a>HDFS的写入和读取过程</h1><h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/5.png" class>

<h2 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h2><img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/6.png" class>

<h1 id="HDFS的元数据辅助管理"><a href="#HDFS的元数据辅助管理" class="headerlink" title="HDFS的元数据辅助管理"></a>HDFS的元数据辅助管理</h1><p>当Hadoop的集群中，NameNode的所有元数据信息都保存在了FsImage 与 Edits 文件当中。元数据信息的 保存目录配置在了hdfs-site.xml当中。</p>
<h2 id="FsImage-和-Edits-详解"><a href="#FsImage-和-Edits-详解" class="headerlink" title="FsImage 和 Edits 详解"></a>FsImage 和 Edits 详解</h2><h3 id="edits"><a href="#edits" class="headerlink" title="edits"></a>edits</h3><ul>
<li>edits 存放了客户端最近一段时间的操作日志</li>
<li>客户端对HDFS进行写文件时会首先被记录在edits文件中</li>
<li>edits修改时元数据也会更新</li>
</ul>
<h3 id="fsimage"><a href="#fsimage" class="headerlink" title="fsimage"></a>fsimage</h3><ul>
<li>NameNode中关于元数据的镜像，一般称为检查点，fsimage存放了一份比较完整的元数据信息</li>
<li>因为fsimage是NameNode的完整镜像，如果每次都加载进就非常损耗内存和CPU，所以一般开始时对NameNode的操作都放在edits中</li>
<li>随着edits内容增大，就需要在一定时间点和fsimage合并</li>
</ul>
<h2 id="fsimage中的文件信息查看"><a href="#fsimage中的文件信息查看" class="headerlink" title="fsimage中的文件信息查看"></a>fsimage中的文件信息查看</h2><p>使用命令 <code>hdfs oiv</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/hadoop-2.7.7/hadoopDatas/namenodeDatas/current</span><br><span class="line">hdfs oiv -i fsimage_0000000000000000165 -p XML -o Test.xml</span><br><span class="line">vi Test.xml</span><br></pre></td></tr></table></figure>

<h2 id="edits文件信息查看"><a href="#edits文件信息查看" class="headerlink" title="edits文件信息查看"></a>edits文件信息查看</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/hadoop-2.7.7/hadoopDatas/nn/edits/current/</span><br><span class="line">hdfs oev -i edits_0000000000000000166-0000000000000000234 -p XML -o myEdits.xml</span><br><span class="line"> vi myEdits.xml</span><br></pre></td></tr></table></figure>

<h2 id="SecondaryNameNode如何辅助管理fsimage和-edits文件？"><a href="#SecondaryNameNode如何辅助管理fsimage和-edits文件？" class="headerlink" title="SecondaryNameNode如何辅助管理fsimage和 edits文件？"></a>SecondaryNameNode如何辅助管理fsimage和 edits文件？</h2><p>只有在NameNode重启时，edit logs才会合并到fsimage文件中，从而得到一个文件系统的最新快照。但是在产品集群中NameNode是很少重启的，这也意味着当NameNode运行了很长时间后，edit logs文件会变得很大。在这种情况下就会出现下面一些问题：</p>
<ol>
<li>edit logs文件会变的很大，怎么去管理这个文件是一个挑战。</li>
<li>NameNode的重启会花费很长时间，因为有很多改动[笔者注:在edit logs中]要合并到fsimage文件上。</li>
<li>如果NameNode挂掉了，那我们就丢失了很多改动因为此时的fsimage文件非常旧。[笔者注: 笔者认为在这个情况下丢失的改动不会很多, 因为丢失的改动应该是还在内存中但是没有写到edit logs的这部分。]</li>
</ol>
<p>现在我们明白了NameNode的功能和所面临的挑战 - 保持文件系统最新的元数据。那么，这些跟Secondary NameNode又有什么关系呢？</p>
<p>SecondaryNameNode就是来帮助解决上述问题的。SecondaryNameNode定期合并fsimage 和 edits，把 edits 控制在一个范围内。</p>
<img src="/2020/08/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-03/7.png" class>

<p>上面的图片展示了Secondary NameNode是<strong>怎么工作</strong>的。</p>
<ol>
<li>首先，它定时到NameNode去获取edit logs，并更新到fsimage上。[笔者注：Secondary NameNode自己的fsimage]</li>
<li>一旦它有了新的fsimage文件，它将其拷贝回NameNode中。</li>
<li>NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间。</li>
</ol>
<p>Secondary NameNode的整个目的是在HDFS中提供一个检查点。它只是NameNode的一个助手节点。这也是它在社区内被认为是检查点节点的原因。</p>
<p>现在，我们明白了Secondary NameNode所做的不过是在文件系统中设置一个检查点来帮助NameNode更好的工作。它不是要取代掉NameNode也不是NameNode的备份。所以从现在起，让我们养成一个习惯，称呼它为<strong>检查点节点</strong>吧。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_02(Hadoop概述与安装)</title>
    <url>/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/</url>
    <content><![CDATA[<p>本篇为大数据的Hadoop技术入门，主要是环境的安装和Hadoop的编译。</p>
<a id="more"></a>

<hr>
<h1 id="Hadoop介绍"><a href="#Hadoop介绍" class="headerlink" title="Hadoop介绍"></a>Hadoop介绍</h1><p><strong>狭义上</strong>，Hadoop就是指Hadoop这个软件，它包括：</p>
<ul>
<li>HDFS：分布式文件系统</li>
<li>MapReduce：分布式计算系统</li>
<li>Yarn：集群资源管理系统</li>
</ul>
<p><strong>广义上</strong>，Hadoop指代大数据的一个生态圈，包括很多其他软件。</p>
<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/1.png" class>

<h1 id="Hadoop的安装"><a href="#Hadoop的安装" class="headerlink" title="Hadoop的安装"></a>Hadoop的安装</h1><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><table>
<thead>
<tr>
<th>服务器IP</th>
<th>主机名</th>
<th>NameNode</th>
<th>SecondaryNameNode</th>
<th>dataNode</th>
<th>ResourceManager</th>
<th>NodeManger</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.2.128</td>
<td>bigdata1</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>192.168.2.129</td>
<td>bigdata2</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>192.168.2.130</td>
<td>bigdata3</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li><p>NameNode ：是HDFS的主节点。</p>
</li>
<li><p>SecondaryNameNode：对 NameNode 做一个辅助管理。</p>
</li>
<li><p>dataNode：从结点。</p>
</li>
<li><p>ResourceManager：分布式计算MapReduce的主节点。</p>
</li>
<li><p>NodeManger：分布式计算MapReduce的从结点。</p>
</li>
</ul>
<h2 id="编译配置过程"><a href="#编译配置过程" class="headerlink" title="编译配置过程"></a>编译配置过程</h2><p>主要是根据 <a href="https://www.bilibili.com/video/BV1JT4y1g7nM?p=45" target="_blank" rel="noopener">B站视频</a> 和 <a href="https://blog.csdn.net/weixin_37490221/article/details/77650388" target="_blank" rel="noopener">一篇博客</a> 完成的。过程较为麻烦，但自己尝试几乎没有踩坑，需要细心细致的编译源码，并进行后面的配置文件的仔细修改。</p>
<p>这里使用的各个软件的版本号，主机名，目录名等都与教程有些出入，需要自己做出合适修改。</p>
<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/2.png" class>

<h1 id="Hadoop集群的启动"><a href="#Hadoop集群的启动" class="headerlink" title="Hadoop集群的启动"></a>Hadoop集群的启动</h1><p>只需在bigdata1上启动即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/hadoop-2.7.7</span><br><span class="line">./bin/hdfs namenode -format</span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br><span class="line">./sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>

<p>可以通过查看界面完成是否配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://bigdata1:50070/explorer.html#/</span><br><span class="line">http://bigdata1:8088/cluster</span><br><span class="line">http://bigdata1:19888/jobhistory</span><br></pre></td></tr></table></figure>

<p>成功页面：</p>
<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/3.png" class>

<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/4.png" class>

<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/5.png" class>

<p>进程列表：</p>
<img src="/2020/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE-02/6.png" class>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据_01(Zookeeper)</title>
    <url>/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/</url>
    <content><![CDATA[<p>ZooKeeper是一个<a href="https://baike.baidu.com/item/分布式/19276232" target="_blank" rel="noopener">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/分布式应用程序/9854429" target="_blank" rel="noopener">分布式应用程序</a>协调服务，是<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>的Chubby一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的实现，是Hadoop和Hbase的重要组件。重点内容记录如下。</p>
<a id="more"></a>

<hr>
<h1 id="Zookeeper的介绍和安装"><a href="#Zookeeper的介绍和安装" class="headerlink" title="Zookeeper的介绍和安装"></a>Zookeeper的介绍和安装</h1><h2 id="Zookeeper概述"><a href="#Zookeeper概述" class="headerlink" title="Zookeeper概述"></a>Zookeeper概述</h2><p>Zookeeper是一个开源的分布式协调服务框架，主要用来解决分布式集群中应用系统的一致性问题和数据管理问题。</p>
<p>zookeeper是一个集群，可以分布在多台主机上，每台主机都可以看做成一个小型的文件系统，则这个整体就可看作一个分布式文件系统。</p>
<p>关于存储，zookeeper将这个整体看成一个树形结构，每一个结点都是一个Znode。</p>
<ul>
<li>Znode是有路径的，例如：/app2/data.conf，这个路径可以理解为是Znode的Name</li>
<li>Znode可以携带数据，即 既可表示文件目录，也可表示文件。</li>
</ul>
<p>正因为Znode的特性，所以Zookeeper可以对外提供一个类似于文件系统的试图，可以通过操作文件系统的方式操作Zookeeper</p>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/1.png" class>

<h2 id="Zookeeper的架构"><a href="#Zookeeper的架构" class="headerlink" title="Zookeeper的架构"></a>Zookeeper的架构</h2><p>zookeeper集群是一个基于主从架构的高可用集群，可以24小时不间断工作。</p>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/2.png" class>

<blockquote>
<p>其中，客户机发出读取数据的非事务请求 和 写数据的事务性请求，写操作一般由从主机转发给主主机</p>
</blockquote>
<p>每个服务器承担如下三种角色中的一种</p>
<ul>
<li><strong>Leader</strong>：一个zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护各Follower及Observer的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其他服务器。</li>
<li><strong>Follower</strong>：一个zookeeper集群可能有多个Followers，它会影响Leader的心跳。Follower可直接处理并返回客户端的读请求，同时将请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。</li>
<li><strong>Observer</strong>：Observer和Follower类似，但无投票权。</li>
</ul>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/3.png" class>

<h2 id="Zookeeper的安装和开启"><a href="#Zookeeper的安装和开启" class="headerlink" title="Zookeeper的安装和开启"></a>Zookeeper的安装和开启</h2><p>下载zookeeper的压缩包，网址：<a href="http://archive.apache.org/dist/" target="_blank" rel="noopener">http://archive.apache.org/dist/</a></p>
<p>找到zookeeper软件包，下载的是3.4.9版本，下载好.tar.gz压缩包后，传到虚拟机上然后解压到自己定义的安装目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/softwares</span><br><span class="line">tar -xvf zookeeper-3.4.9.tar.gz -C ../servers</span><br></pre></td></tr></table></figure>

<p>解压好后，修改配置文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /export/servers/zookeeper-3.4.9/conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">mkdir -p /export/servers/zookeeper-3.4.9/zkdatas/  # 创建zkdatas文件.里面存入数据</span><br></pre></td></tr></table></figure>

<p>然后对复制的 <code>zoo.cfg</code> 配置文件进行配置。</p>
<p><code>vi zoo.cfg</code>，修改内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dataDir=/export/servers/zookeeper-3.4.9/zkdatas/ # 上面创建的zkdatas目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保留多少个快照</span></span><br><span class="line">autopurge.snapRetainCount=3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志多少小时清理一次</span></span><br><span class="line">autopurge.purgeInterval=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群服务器设置</span></span><br><span class="line">server.1=bigdata1:2888:3888</span><br><span class="line">server.2=bigdata2:2888:3888</span><br><span class="line">server.3=bigdata3:2888:3888</span><br></pre></td></tr></table></figure>

<p>接下来添加myid配置</p>
<p>在第一台虚拟机上，在上面创建的zkdatas文件夹下创建myid文件，内容为 1 。</p>
<p>然后，把配置好的安装包分发给另外两台虚拟机，并且修改它们的myid，分别设置为 2 和 3 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /export/servers/zookeeper-3.4.9/ bigdata2:/export/servers</span><br><span class="line"></span><br><span class="line">scp -r /export/servers/zookeeper-3.4.9/ bigdata3:/export/servers</span><br></pre></td></tr></table></figure>

<p>启动zookeeper访问</p>
<p>进入到bin目录，使用命令 <code>./zkServer.sh start</code>启动服务。（启动时需要注意，命令使用规范）</p>
<p>然后验证是否启动成功可以使用命令 <code>jps</code>。</p>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/4.png" class>

<p>出现 QuorumPeerMain 表示启动成功。若未启动成功，可能的原因就是上面的zoo.cfg未配置正确。</p>
<p>然后我们可以用命令 <code>./zkServer.sh status</code> 查看状态（注意：一定要启动主节点，即bigdata2，可以提前把三个结点的zookeeper都启动）。可以发现，虚拟机2为 Leader，1 和 3 为 Follower。</p>
<p>至此，一个zookeeper集群搭建完成。</p>
<h1 id="Zookeeper内部结构"><a href="#Zookeeper内部结构" class="headerlink" title="Zookeeper内部结构"></a>Zookeeper内部结构</h1><h2 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h2><ul>
<li><p>zookeeper的数据模型，在结构上和标准文件系统非常相似，都是采用树形层次结构。</p>
</li>
<li><p>zookeeper树中的每个结点被称为一个Znode。</p>
</li>
</ul>
<p>不同之处：</p>
<ol>
<li>Znode<strong>兼具</strong>文件和目录两种特点。</li>
<li>Znode存数据大小有限制，以KB为单位，主要存储状态信息、配置信息。</li>
<li>Znode通过路径引用。路径必须是绝对的，因此他们必须由斜杠字符来开头（根节点为 / ）。其中 “ /zookeeper ”为系统默认创建的Znode，用以保存管理信息。</li>
<li>每个Znode由3部分组成：<ol>
<li>stat：此为状态信息，描述该Znode的版本，权限等信息。</li>
<li>data：与该Znode关联的数据</li>
<li>children：该Znode下的子节点</li>
</ol>
</li>
</ol>
<h2 id="Znode的结点类型"><a href="#Znode的结点类型" class="headerlink" title="Znode的结点类型"></a>Znode的结点类型</h2><p>1、Znode结点有两种，分别为 <strong>临时节点</strong> 和 <strong>永久结点</strong> 。结点的类型在创建时即被确定，并且不能改变。</p>
<ul>
<li>临时结点：该节点的生命周期依赖于创建它们的会话。会话结束就会被自动删除。临时结点不允许拥有子节点。。</li>
<li>永久节点：该节点的生命周期不依赖于会话。</li>
</ul>
<p>2、Znode还有序列化的特性，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。它的格式为 “ %10d ”（10位数字，没有数值的数位用 0 补充，例如“0000000001”）</p>
<p>3、这样便会存在四种类型的Znode结点，分别对应：</p>
<ul>
<li>PERSISTENT：永久结点</li>
<li>EPHEMERAL：临时结点</li>
<li>PERSISTENT_SEQUENTIAL：永久结点、序列化</li>
<li>EPHEMERAL_SEQUENTIAL：临时结点、序列化</li>
</ul>
<h1 id="Zookeeper的Shell客户端操作"><a href="#Zookeeper的Shell客户端操作" class="headerlink" title="Zookeeper的Shell客户端操作"></a>Zookeeper的Shell客户端操作</h1><h2 id="1、登录Zookeeper客户端"><a href="#1、登录Zookeeper客户端" class="headerlink" title="1、登录Zookeeper客户端"></a>1、登录Zookeeper客户端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkCli.sh -server 主机名:2181</span><br></pre></td></tr></table></figure>

<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/5.png" class>

<p>表示登录成功。</p>
<p>退出命令 quit。登录时，省略-server及之后的命令，代表登录本主机的客户端。</p>
<h2 id="2、Zookeeper的常用命令"><a href="#2、Zookeeper的常用命令" class="headerlink" title="2、Zookeeper的常用命令"></a>2、Zookeeper的常用命令</h2><img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/6.png" class>

<p><strong>注意</strong>：create命令：如果不加参数，创建永久性结点；如果加参数 - s，创建永久性序列化结点；如果只用 - e，创建临时结点；都加上代表临时性序列化结点。</p>
<p><strong>操作实例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">列出Path下的所有Znode</span><br><span class="line">ls /</span><br><span class="line">创建永久结点</span><br><span class="line">create /hello world</span><br><span class="line">创建临时结点</span><br><span class="line">create -e /abc 123</span><br><span class="line">创建永久序列化结点</span><br><span class="line">create -s /zhangsan boy</span><br><span class="line">创建临时序列化结点</span><br><span class="line">create -e -s /list boy</span><br><span class="line">获取数据</span><br><span class="line">get /hello</span><br><span class="line">修改结点数据</span><br><span class="line">set /hello data</span><br><span class="line">删除结点，如果要删除的结点有子Znode则无法删除</span><br><span class="line">delete /hello</span><br><span class="line">删除结点，如果有子Znode则递归删除</span><br><span class="line">rmr /abc</span><br><span class="line">列出历史记录</span><br><span class="line">history</span><br></pre></td></tr></table></figure>

<h2 id="3、Znode结点属性"><a href="#3、Znode结点属性" class="headerlink" title="3、Znode结点属性"></a>3、Znode结点属性</h2><p>每个Znode都包含了一系列的属性，通过命令get，可以获得结点的属性。</p>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/7.png" class>

<p>首先第一行是该节点携带的信息。</p>
<p>dataVersion：数据版本号。每次对结点进行set操作，该值都会增1。</p>
<p>cversion：子节点的版本号。当Znode的子节点有变化时，cversion的值就会增1。</p>
<p>aclVersion：ACL的版本号。</p>
<p>cZxid：Znode创建事务的ID。</p>
<p>mZxid：Znode被修改的事务ID，即每次对Znode的修改都会更新mZxid。</p>
<p>ctime：结点创建时的时间戳。</p>
<p>mtime：最近一次更新的时间。</p>
<p>ephemeralOwner：如果该节点为临时结点，该值表示与该节点绑定的session id，如果不是，值为 0。</p>
<h1 id="Zookeeper的watch机制"><a href="#Zookeeper的watch机制" class="headerlink" title="Zookeeper的watch机制"></a>Zookeeper的watch机制</h1><p>类似于数据库中的触发器，对某个Znode设置 <code>Watcher</code>，当Znode发生变化时，<code>WatchManager</code>会调用对应的Watcher。</p>
<p>当Znode发生删除，修改，创建，子节点的修改时，对应的Watcher会得到通知。</p>
<p>Watcher的特点</p>
<ul>
<li>一次性触发：一个Watcher只会被触发一次，如果需要继续监听，则需要再次添加Watcher。</li>
<li>事件封装：Watcher得到的事件是被封装过的，包括三个内容 <code>KeeperState</code> ， <code>eventType</code> ， <code>path</code></li>
</ul>
<img src="/2020/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE-01/8.png" class>

<p><strong>主要作用</strong>：</p>
<p>1、发布和订阅</p>
<p>2、监听集群中主机的存活状态</p>
<h1 id="Zookeeper的JavaAPI操作"><a href="#Zookeeper的JavaAPI操作" class="headerlink" title="Zookeeper的JavaAPI操作"></a>Zookeeper的JavaAPI操作</h1><p>这里操作Zookeeper的JavaAPI使用的是一套zookeeper客户端框架Curator，解决了很多Zookeeper客户端非常底层的细节开发工作。</p>
<p>Curator包含了几个包：</p>
<ul>
<li>curator-framework：对zookeeper的底层api的一些封装</li>
<li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器等。</li>
</ul>
<p>Maven依赖（使用curator的版本：2.12.0，对应zookeeper的3.4.x版本，如果不对应，可能有兼容性问题，很可能导致结点操作失败）</p>
<p><strong>实例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.zookeeper_api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.ChildData;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateZnode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1：定制一个重试策略</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * param1：重试的间隔时间，单位ms</span></span><br><span class="line"><span class="comment">        * param2：重试的最大次数</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2：获取一个客户端对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * param1：要连接的Zookeeper服务器列表</span></span><br><span class="line"><span class="comment">        * param2:会话的超时时间</span></span><br><span class="line"><span class="comment">        * param3：连接的超时时间</span></span><br><span class="line"><span class="comment">        * param4：重试策略</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        String connStr = <span class="string">"bigdata1:2181,bigdata2:2181,bigdata3:2181"</span>; <span class="comment">// 有多个主机时，每个主机之间用逗号连接，并且注意：不要为美观而乱加空格！</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(connStr, <span class="number">3000</span>, <span class="number">3000</span>, retryPolicy);</span><br><span class="line">        <span class="comment">//3：开启客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//4：创建结点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 客户端创建结点，creatingParentsIfNeeded表示：创建hello，但也会创建父节点Test</span></span><br><span class="line"><span class="comment">        * withMode表示类型，有四种</span></span><br><span class="line"><span class="comment">        * forPath表示结点路径和携带的数据，第二个参数为byte类型</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建永久结点</span></span><br><span class="line">        client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/Test/hello4"</span>, <span class="string">"JavaApiTest"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时性结点</span></span><br><span class="line">        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/Test/tmp"</span>, <span class="string">"临时"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为临时结点只在会话时有效，为保证看到效果，使程序休眠10s</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改结点数据</span></span><br><span class="line">        client.setData().forPath(<span class="string">"/Test/hello"</span>, <span class="string">"被修改"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结点数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = client.getData().forPath(<span class="string">"/hello"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5：关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 结点的watch机制</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchZnode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>,<span class="number">1</span>);</span><br><span class="line">        String connStr = <span class="string">"bigdata1:2181,bigdata2:2181,bigdata3:2181"</span>;</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(connStr, <span class="number">8000</span>, <span class="number">8000</span>, retryPolicy);</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个TreeCache对象，指定要监控的结点路径</span></span><br><span class="line">        TreeCache treeCache = <span class="keyword">new</span> TreeCache(client, <span class="string">"/hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义监听器</span></span><br><span class="line">        treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, TreeCacheEvent treeCacheEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChildData data = treeCacheEvent.getData();</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">switch</span> (treeCacheEvent.getType())&#123; <span class="comment">//获取事件的触发类型</span></span><br><span class="line">                        <span class="keyword">case</span> NODE_ADDED: <span class="comment">// 表示新增结点触发的watch</span></span><br><span class="line">                            System.out.println(<span class="string">"NODE_ADDED"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NODE_REMOVED:</span><br><span class="line">                            System.out.println(<span class="string">"NODE_REMOVED"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NODE_UPDATED:</span><br><span class="line">                            System.out.println(<span class="string">"NODE_UPDATED"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            System.out.println(<span class="string">"default"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始监听</span></span><br><span class="line">        treeCache.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 之后运行程序，在zookeeper中对指定的结点进行操作时，控制台便会打印相应信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell基础命令</title>
    <url>/2020/08/03/Shell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>总结Linux中的shell命令</p>
<a id="more"></a>

<hr>
<h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><p>使用vi编辑器新建一个文件 hello.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash			<span class="comment"># 开头固定</span></span></span><br><span class="line">echo "Hello world!"</span><br></pre></td></tr></table></figure>

<h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><ol>
<li><p><code>sh hello.sh</code></p>
</li>
<li><pre><code class="shell">chmod +x ./hello.sh    # 使脚本具有执行权限
./hello.sh            # 执行脚本
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3、变量</span><br><span class="line"></span><br><span class="line">### 局部变量</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">str&#x3D;&quot;hello&quot;</span><br><span class="line">echo $&#123;str&#125;world	# helloworld</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo $HOME</span><br></pre></td></tr></table></figure>

<p>若想查看所有的环境变量，使用命令：<code>env</code></p>
<p>编辑环境变量，在/etc/profile 中，通过 export 关键字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MYENV=/root/myenv</span><br></pre></td></tr></table></figure>

<h2 id="4、特殊字符"><a href="#4、特殊字符" class="headerlink" title="4、特殊字符"></a>4、特殊字符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到将本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个但字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0表示没有错误，其他任何值表示有错误</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "第一个参数为： $1"</span><br><span class="line">echo "参数个数为：$#"</span><br><span class="line">echo "传递的参数作为一个字符串显示：$*"</span><br></pre></td></tr></table></figure>

<p>执行：./test.sh 1 2 3</p>
<h2 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h2><p>以加法 + 为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">echo `expr $a + $b`;</span><br><span class="line">echo $((a+b));</span><br><span class="line">echo $[a+b];</span><br></pre></td></tr></table></figure>

<h2 id="6、if语句"><a href="#6、if语句" class="headerlink" title="6、if语句"></a>6、if语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "Please input your name:" NAME # read命令用于从控制台读取输入的数据，然后存入NAME变量</span><br><span class="line">if [ $NAME = root ]</span><br><span class="line">	then</span><br><span class="line">		echo "hello $&#123;NAME&#125;"</span><br><span class="line">elif [ $NAME = dongao ]</span><br><span class="line">	then</span><br><span class="line">		echo "hello $&#123;NAME&#125;"</span><br><span class="line">else</span><br><span class="line">	echo "Get out"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="7、for语句"><a href="#7、for语句" class="headerlink" title="7、for语句"></a>7、for语句</h2><p>方式1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for N in 1 2 3</span><br><span class="line">do</span><br><span class="line">	echo $N</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for ((i = 0; i &lt;= 5; i++))</span><br><span class="line">do</span><br><span class="line">	echo "$i"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="8、函数"><a href="#8、函数" class="headerlink" title="8、函数"></a>8、函数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">	echo "输入第一个字"</span><br><span class="line">	read aNum</span><br><span class="line">	echo "输入第二个字"</span><br><span class="line">	read bNum</span><br><span class="line">	return $(($aNum+$bNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn         # 调用函数</span><br><span class="line">echo "输入的两个数字之和为 $? " # $? 提取上一个返回值</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析_01</title>
    <url>/2020/07/27/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01/</url>
    <content><![CDATA[<p>本篇开始学习python中重要的数据分析技术，它是python数据科学的技术，是机器学习课程的基础。</p>
<a id="more"></a>

<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是数据分析"><a href="#什么是数据分析" class="headerlink" title="什么是数据分析"></a>什么是数据分析</h2><p>数据分析是用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当行动。</p>
<h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><p>提出问题 –&gt; 准备数据 –&gt; <strong>分析数据</strong> –&gt; 获得结论 –&gt; 成果可视化</p>
<h2 id="两个工具环境的安装"><a href="#两个工具环境的安装" class="headerlink" title="两个工具环境的安装"></a>两个工具环境的安装</h2><h3 id="CONDA环境安装"><a href="#CONDA环境安装" class="headerlink" title="CONDA环境安装"></a>CONDA环境安装</h3><p>里面有大量的安装包等内容，几乎可以解决pip下载失败的所有问题。</p>
<h3 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h3><p>是一款编程/文档/笔记/展示软件。</p>
<img src="/2020/07/27/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01/1.png" class>

<h1 id="认识-matplotlib"><a href="#认识-matplotlib" class="headerlink" title="认识 matplotlib"></a>认识 matplotlib</h1><h2 id="为什么学习matplotlib？"><a href="#为什么学习matplotlib？" class="headerlink" title="为什么学习matplotlib？"></a>为什么学习matplotlib？</h2><ol>
<li>能够将数据进行可视化，更直观的呈现</li>
<li>使数据更加客观，更具说服力</li>
</ol>
<h2 id="什么是matplotlib？"><a href="#什么是matplotlib？" class="headerlink" title="什么是matplotlib？"></a>什么是matplotlib？</h2><p>最流行的python底层绘图库，主要做数据可视化图表，名字取材于matlab。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_09(CrawlSpider)</title>
    <url>/2020/07/09/Python%E7%88%AC%E8%99%AB-09/</url>
    <content><![CDATA[<p>本篇是python中 <strong>CrawlSpider</strong> 的介绍，还有<strong>Scrapy Shell</strong>、<strong>request 和 response</strong> 对象、<strong>发送POST请求</strong> 等。</p>
<a id="more"></a>

<hr>
<h1 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h1><p>在之前的爬虫中定义了新的功能，可以定义爬取url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的<code>yield Request</code>。</p>
<h2 id="创建CrawlSpider"><a href="#创建CrawlSpider" class="headerlink" title="创建CrawlSpider"></a>创建CrawlSpider</h2><p>之前创建爬虫的方式是通过 <code>scrapy genspider [爬虫名] [域名]</code> 的方式创建的。如果想要创建<code>CrawlSpider</code>爬虫，则通过以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy genspider -t crawl [爬虫名] [域名]</span><br></pre></td></tr></table></figure>

<h2 id="LinkExtractors链接提取器"><a href="#LinkExtractors链接提取器" class="headerlink" title="LinkExtractors链接提取器"></a>LinkExtractors链接提取器</h2><p>使用<code>LinkExtractors</code> 可以不用我们手动提取想要的URL，然后发送请求。这些工作可以交给<code>LinkExtractors</code> ，它会在所有爬的页面中找到满足规则的URL，实现自动爬取。下面是简单介绍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scrapy</span>.<span class="title">linkextractors</span>.<span class="title">LinkExtractor</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">    allow = <span class="params">()</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    deny = <span class="params">()</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    allow_domains = <span class="params">()</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    deny_domains = <span class="params">()</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    deny_extensions = None,</span></span></span><br><span class="line"><span class="class"><span class="params">    restrict_xpaths = <span class="params">()</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    tags = <span class="params">(<span class="string">'a'</span>, <span class="string">'area'</span>)</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    attrs = <span class="params">(<span class="string">'href'</span>)</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    canonicalize = True,</span></span></span><br><span class="line"><span class="class"><span class="params">    unique = True,</span></span></span><br><span class="line"><span class="class"><span class="params">    process_value = None</span></span></span><br><span class="line"><span class="class"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p>主要参数讲解：</p>
<ul>
<li>allow：允许的URL，所有满足里面正则表达式的URL都会被提取</li>
<li>allow_domains：允许的域名，只有这里指定的域名的URL才会被提取</li>
</ul>
<h2 id="Rule规则类"><a href="#Rule规则类" class="headerlink" title="Rule规则类"></a>Rule规则类</h2><p>定义爬虫的规则类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scrapy</span>.<span class="title">spiders</span>.<span class="title">Rule</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">    link_extractor,</span></span></span><br><span class="line"><span class="class"><span class="params">    callback = None,</span></span></span><br><span class="line"><span class="class"><span class="params">    cb_kwargs = None,</span></span></span><br><span class="line"><span class="class"><span class="params">    follow = None,</span></span></span><br><span class="line"><span class="class"><span class="params">    process_links = None,</span></span></span><br><span class="line"><span class="class"><span class="params">    process_request = None</span></span></span><br><span class="line"><span class="class"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p>主要参数讲解：</p>
<ul>
<li>link_extractor：一个<code>LinkExtractor</code>对象，用于定义爬取规则。</li>
<li>callback：满足规则的URL，应该执行哪个回调函数。</li>
<li>follow：根据该规则，指定response中提取的链接是否需要跟进。</li>
<li>process_links：从link_extractor中获取的链接会传递给这个函数，用来过滤不需要爬取的链接。</li>
</ul>
<h1 id="Scrapy-Shell"><a href="#Scrapy-Shell" class="headerlink" title="Scrapy Shell"></a>Scrapy Shell</h1><p>可以简单的运行Xpath、BeautifulSoup、正则表达式或CSS选择器等，来判断我们的提取规则是否正确。</p>
<p>在 cmd（或pycharm的Terminal）进入scrapy爬虫的工程目录（可以读取对应项目里的配置信息，若不进入，则只能运行一些通用测试，平常使用足够），运行下述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy shell 域名</span><br></pre></td></tr></table></figure>

<h1 id="scrapy-中的-request-和-response-对象"><a href="#scrapy-中的-request-和-response-对象" class="headerlink" title="scrapy 中的 request 和 response 对象"></a>scrapy 中的 request 和 response 对象</h1><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><p>request对象在我们写爬虫，爬取一页的数据，需要重新发送一个请求的时候调用。这个类需要传递一些参数，其中比较常用的参数有：</p>
<ul>
<li>url：发送请求的url</li>
<li>callback：在下载器完成相应的下载任务后执行的回调函数</li>
<li>method：默认为GET方法</li>
<li>headers：请求头，固定部分放入setting.py 中，需要改变的再可在发送时指定</li>
<li>meta：比较常用，用于在不同的请求之间传递数据</li>
<li>encoding：默认utf-8</li>
<li>dot_filter：表示不由调度器过滤，在执行多次重复的请求时用的比较多</li>
<li>errback：在发生错误时执行的函数</li>
</ul>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>Response对象一般是由scrapy自动生成的，因此我们只需关系如何使用。它有很多属性，主要用来提取数据，依次介绍：</p>
<ul>
<li><p>meta：从请求穿过来的meta属性，可以用来保持多个请求之间的数据连接</p>
</li>
<li><p>encoding：返回字符串编码和解码格式</p>
</li>
<li><p>text：将返回来的数据作为Unicode字符串返回</p>
</li>
<li><p>body：将返回来的数据作为Bytes字符串返回</p>
</li>
<li><p>xpath：xpath选择器</p>
</li>
<li><p>css：css选择器</p>
</li>
</ul>
<h1 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h1><p>有时我们想要在请求数据的时候发送POST请求，那么这时候需要使用 <code>Request</code> 的子类 <code>FormRequest</code> 来实现（专门为表单提交设计的类）。如果想要在爬虫一开始的时候就发送POST请求，那么需要在爬虫类中重写 <code>start_requests(self)</code> 方法，并且不再调用 <code>start_url</code> 里的URL。</p>
<h2 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h2><h3 id="案例一：模拟人人网登录"><a href="#案例一：模拟人人网登录" class="headerlink" title="案例一：模拟人人网登录"></a>案例一：模拟人人网登录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenrenSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'renren'</span></span><br><span class="line">    allowed_domains = [<span class="string">'renren.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://renren.com/'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟登录，重写该方法(因为在父类中，该方法默认发送GET请求)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">'http://www.renren.com/PLogin.do'</span></span><br><span class="line">        data = &#123;<span class="string">'email'</span>:<span class="string">'13287857692'</span>, <span class="string">'password'</span>:<span class="string">'dongao123'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 专门发送POST请求，并且携带表单数据</span></span><br><span class="line">        request = scrapy.FormRequest(url, formdata = data, callback = self.parse_page)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># with open ('renren.html', 'w', encoding='utf-8') as f:</span></span><br><span class="line">        <span class="comment">#     f.write(response.text)</span></span><br><span class="line">        <span class="comment"># 请求只有登录才能访问的个人主页</span></span><br><span class="line">        request = scrapy.Request(url=<span class="string">'http://www.renren.com/974726184/profile'</span>,callback=self.parse_profile)</span><br><span class="line">        <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_profile</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'myprofile.html'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f :</span><br><span class="line">            f.write(response.text)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>The College Entrance Examination in Despair</title>
    <url>/2020/07/07/%E7%BB%9D%E5%A2%83%E9%87%8C%E7%9A%84%E9%AB%98%E8%80%83/</url>
    <content><![CDATA[<p>2020年7月7日~2020年7月8日高考。</p>
<a id="more"></a>

<hr>
<p>今年真是命运多舛的一年，就在今天下午，本应所有高三考生紧张答题的时候，却传来了南方载有考生的大巴车出事，21人死亡。真是令人心痛，最美的年纪，可命运对他们并不公平。</p>
<blockquote>
<p>那会难受的想跳河，不过我使劲儿的控制住自己了。</p>
</blockquote>
<p>每个人都在努力过好自己的生活，但有些时候，真的很难。</p>
<p>除了生老病死，其他都是小事。</p>
<p>生活很难，但请务必坚持。</p>
<p>有人欢喜有人悲，黑马很多，但考砸的也不会少。</p>
<blockquote>
<p>别急着崩溃，以后让你崩溃的事多着呢</p>
<p>真的崩溃不叫崩溃，那叫绝望。</p>
</blockquote>
<p>失常只是正常的一部分，平常心。</p>
<blockquote>
<p>试卷，答案往往只有一个，如果没有找到它，那就是不及格。</p>
<p>但是啊，人生不一样，人生有很多正确答案</p>
<p>读大学是，不读也是</p>
<p>读好的是，读所谓的不好的，也是</p>
<p>热爱运动是，喜欢音乐是，做你想做的事，更是</p>
<p>不要畏惧，不管这次如何，都不要否定自己的可能性</p>
<p>挺起胸膛，理直气壮</p>
<p>人生是一场马拉松，起跑落后一点</p>
<p>又怎样</p>
</blockquote>
<p>罗翔：</p>
<blockquote>
<p> 古希腊哲学家<strong>埃比克泰德</strong> 曾经说过的一句话：我们登上并非我们所选择的舞台，演出并非我们所选择的剧本。</p>
</blockquote>
<p>各位同学有谁是自愿来到这个世界上的，有谁来到这个世界上父母征求过你的意见？没有征求。我们登上并非我们所选择的舞台，各位同学有谁的人生剧本是你选择的？大家是不是很羡慕别人的剧本，但是没有办法，你的剧本不是你选择的。你只有努力的把自己的剧本给演好。虽然很痛苦，但是只要努力演好你的剧本，在痛苦中也有精彩。每个人的人生剧本都是独特的，每个人的人生剧本都是精彩的。不要去羡慕别人，因为你没有可以羡慕的。人生中绝大多数，说实话都不是我们所能决定的。人生中95%的东西是我们决定不了的。我们的出生，我们的智商，我们一生的机遇，其实都不是我们所能决定的。这就是为什么如果你真的取得了成就你应该感谢谁，是感谢你自己，还是感谢你自己以外的力量。其实不应该感谢你自己，因为你能决定的东西很少。这就是为什么，如果你真正取得了成就，你要积极的回报这个社会，因为给你的不一定真正属于你。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_08(糗事百科Scrapy爬虫)</title>
    <url>/2020/07/05/Python%E7%88%AC%E8%99%AB-08/</url>
    <content><![CDATA[<p>本篇是python实例编写：<strong>糗事百科</strong>，目的是介绍最基础的scrapy框架的写法和运行过程。</p>
<a id="more"></a>

<hr>
<h1 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h1><p>目标：获取 糗事百科 所所有信息的作者，url和内容，需要爬取多个页面，/page/1~/page/13。 </p>
<p>输出：保存到文件中（json格式）</p>
<h1 id="编写步骤"><a href="#编写步骤" class="headerlink" title="编写步骤"></a>编写步骤</h1><p>编写<strong>spider</strong>处理链接爬取和页面解析，编写<strong>pipelines</strong>处理信息存储</p>
<h2 id="步骤1：建立工程和Spider模板"><a href="#步骤1：建立工程和Spider模板" class="headerlink" title="步骤1：建立工程和Spider模板"></a>步骤1：建立工程和Spider模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\&gt;scrapy startproject qsbk</span><br><span class="line">\&gt;cd BaiduStocks</span><br><span class="line">\&gt;scrapy genspider qsbk_spider qiushibaike.com</span><br></pre></td></tr></table></figure>

<h2 id="步骤2：编写Spider"><a href="#步骤2：编写Spider" class="headerlink" title="步骤2：编写Spider"></a>步骤2：编写Spider</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> qsbk.items <span class="keyword">import</span> QsbkItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkSpiderSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'qsbk_spider'</span></span><br><span class="line">    allowed_domains = [<span class="string">'qiushibaike.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://qiushibaike.com/text/page/1/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># selectorList 类型</span></span><br><span class="line">        duanziDivs = response.xpath(<span class="string">"//div[@class='col1 old-style-col1']/div"</span>)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> duanziDivs:</span><br><span class="line">            <span class="comment"># div: Selector类型</span></span><br><span class="line">            <span class="comment"># div.xpath()：selectorList类型</span></span><br><span class="line">            author = div.xpath(<span class="string">".//h2/text()"</span>).get().strip()</span><br><span class="line">            <span class="comment"># get()函数，取到第一个结果（str类型）, get()&lt;=&gt;extract_first()</span></span><br><span class="line">            <span class="comment"># extract(): 提取所有结果组成列表，每个元素是str类型</span></span><br><span class="line">            <span class="comment"># strip(): 去掉前后的空格</span></span><br><span class="line"></span><br><span class="line">            href = div.xpath(<span class="string">'./a/@href'</span>).get() <span class="comment"># 获取a标签内的href的属性值</span></span><br><span class="line">            url = urljoin(self.start_urls[<span class="number">0</span>],href) <span class="comment"># 跳转到详情页</span></span><br><span class="line"></span><br><span class="line">            content = div.xpath(<span class="string">".//div[@class='content']//text()"</span>).extract()</span><br><span class="line">            <span class="comment"># html中该div下有span标签，span中才是内容，//text()直接提取该内容</span></span><br><span class="line"></span><br><span class="line">            content = <span class="string">''</span>.join(content).strip()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># tplt = "&#123;0:&#123;2&#125;&lt;20&#125;\t&#123;1:^50&#125;"</span></span><br><span class="line">            <span class="comment"># print(tplt.format(author,url,chr(12288)))</span></span><br><span class="line">            <span class="comment"># print(content)</span></span><br><span class="line">            <span class="comment"># print('=' * 100)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># duanzi = &#123;'author':author,'content':content&#125; # 即为一个个的存储项，item，写法如下 ⬇</span></span><br><span class="line">            item = QsbkItem(author=author, content=content)</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'生成器调用：'</span>,i)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># yield duanzi</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若不使用生成器，即注释上面的yield item，可使用以下方法</span></span><br><span class="line">            <span class="comment"># items = []</span></span><br><span class="line">            <span class="comment"># items.append(item)</span></span><br><span class="line">            <span class="comment"># return items</span></span><br><span class="line">            <span class="comment"># 返回所有的items=，在pipelines中也可以被解析</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试该函数可以注释最后的生成器步骤，取消注释前面的打印函数。</p>
</blockquote>
<h3 id="对setting-py的设置"><a href="#对setting-py的设置" class="headerlink" title="对setting.py的设置"></a>对setting.py的设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user-agent = <span class="string">'Mozilla/5.0'</span> <span class="comment"># 设置头信息</span></span><br><span class="line"></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span> <span class="comment"># 不遵循robots协议</span></span><br><span class="line"></span><br><span class="line">LOG_LEVEL = <span class="string">"WARN"</span> <span class="comment"># 取消warning以下的提示信息，使控制台更干净</span></span><br></pre></td></tr></table></figure>

<h2 id="步骤3：编写ITEM-Pipelines"><a href="#步骤3：编写ITEM-Pipelines" class="headerlink" title="步骤3：编写ITEM Pipelines"></a>步骤3：编写ITEM Pipelines</h2><p>注意该文件中，类里的三个方法: 打开、运行、关闭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful for handling different item types with a single interface</span></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fp = open(<span class="string">'duanzi.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬虫启动时执行的函数，比如打开文件，也可写在构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫开始了... &lt;---------'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬虫运行时，即qsbk_spider.py 中的生成器依次调用, item就是yield依次传来的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="comment"># item_json = json.dumps(item,ensure_ascii=False) # 第一次，未指定item</span></span><br><span class="line">        item_json = json.dumps(dict(item),ensure_ascii=<span class="literal">False</span>) <span class="comment"># 第二次，指定items.py中的类，此处用dict()函数将其转换为字典</span></span><br><span class="line">        self.fp.write(item_json + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'pipelines调用'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬虫结束时执行的函数，关闭文件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.fp.close()</span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫结束了... &lt;---------'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="items-py编写"><a href="#items-py编写" class="headerlink" title="items.py编写"></a>items.py编写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://docs.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    </span><br><span class="line">    author = scrapy.Field() <span class="comment"># 选择需要输出结果的属性</span></span><br><span class="line">    content = scrapy.Field()</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>若要使用ITEM Pipelines，需要在setting.py中开启。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'qsbk.pipelines.QsbkPipeline'</span>: <span class="number">300</span>, <span class="comment"># 当有多个pipelines，后面的值越小代表越优先执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化数据存储的方式"><a href="#优化数据存储的方式" class="headerlink" title="优化数据存储的方式"></a>优化数据存储的方式</h2><h3 id="方法一：使用JsonItemExporter"><a href="#方法一：使用JsonItemExporter" class="headerlink" title="方法一：使用JsonItemExporter"></a>方法一：使用<code>JsonItemExporter</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonItemExporter <span class="comment"># scrapy框架里的JSON导出器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fp = open(<span class="string">'duanzi.json'</span>, <span class="string">'wb'</span>) <span class="comment"># 二进制方法打开 , 不能指定 encoding = 'utf-8'</span></span><br><span class="line">        self.exporter = JsonItemExporter(self.fp, ensure_ascii = <span class="literal">False</span>, encoding = <span class="string">'utf-8'</span>)</span><br><span class="line">        self.exporter.start_exporting() <span class="comment"># 开始</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫开始了... &lt;---------'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line">        print(<span class="string">'pipelines调用'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.exporter.finish_exporting() <span class="comment"># 该方法是把所有的item存为一个列表，每个元素是一个item</span></span><br><span class="line">        self.fp.close()</span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫结束了... &lt;---------'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：所有item存在一个列表中，一起写入文件，较消耗内存。</p>
<p>​            需要 开始 和 结束 。</p>
<p>但整体满足格式要求，一个大列表，每个元素是一个item的json格式数据。</p>
</blockquote>
<h3 id="方法二：使用JsonLinesItemExporter"><a href="#方法二：使用JsonLinesItemExporter" class="headerlink" title="方法二：使用JsonLinesItemExporter"></a>方法二：使用<code>JsonLinesItemExporter</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonLinesItemExporter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fp = open(<span class="string">'duanzi.json'</span>, <span class="string">'wb'</span>) </span><br><span class="line">        self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii = <span class="literal">False</span>, encoding = <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫开始了... &lt;---------'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line">        print(<span class="string">'pipelines调用'</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.fp.close()</span><br><span class="line">        print(<span class="string">'--------&gt; 爬虫结束了... &lt;---------'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此方法把每个item作为一个单独的字典类型存入文件。</p>
<p>不需要 开始 和 结束 。</p>
<p>缺点：每行数据为一个字典（json格式），但整个文件并不满足json格式。</p>
</blockquote>
<h2 id="抓取多个页面"><a href="#抓取多个页面" class="headerlink" title="抓取多个页面"></a>抓取多个页面</h2><p>主要是最后几行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> qsbk.items <span class="keyword">import</span> QsbkItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkSpiderSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'qsbk_spider'</span></span><br><span class="line">    allowed_domains = [<span class="string">'qiushibaike.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://qiushibaike.com/text/page/1/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        duanziDivs = response.xpath(<span class="string">"//div[@class='col1 old-style-col1']/div"</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> duanziDivs:</span><br><span class="line">            author = div.xpath(<span class="string">".//h2/text()"</span>).get().strip()</span><br><span class="line">            href = div.xpath(<span class="string">'./a/@href'</span>).get() <span class="comment"># 获取a标签内的href的属性值</span></span><br><span class="line">            url = urljoin(self.start_urls[<span class="number">0</span>],href) <span class="comment"># 跳转到详情页</span></span><br><span class="line">            content = div.xpath(<span class="string">".//div[@class='content']//text()"</span>).extract()</span><br><span class="line">            content = <span class="string">''</span>.join(content).strip()</span><br><span class="line">            item = QsbkItem(author=author, content=content)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'生成器调用：'</span>,i)</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        next_path = response.xpath(<span class="string">"//ul[@class='pagination']/li[last()]/a/@href"</span>).get() <span class="comment"># 底部显示页面的最后一个li标签，‘下一页’</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_path: <span class="comment"># 如果没有下一页</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_url = urljoin(self.start_urls[<span class="number">0</span>], next_path)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_url, callback=self.parse) <span class="comment"># 利用当前页的url，执行上面的parse解析函数</span></span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Planan_03(7.6~7.12)</title>
    <url>/2020/07/04/Plan-02-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<p>第三周开始了，高考也将至，时间飞逝啊。</p>
<a id="more"></a>

<hr>
<p>本周目标：</p>
<ul>
<li><p>Scrapy框架学习，尝试独立完成一个爬取实例。</p>
</li>
<li><p>学习小组确定主题，尝试开始或者一起学习，（Github Page搭建官网？）。</p>
</li>
<li><p>APP小组尝试开始。</p>
</li>
<li><p>python Web？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_07(Scrapy初步使用)</title>
    <url>/2020/07/03/python%E7%88%AC%E8%99%AB-07/</url>
    <content><![CDATA[<p>本篇是python<strong>框架Scrapy</strong>的初步使用。</p>
<a id="more"></a>

<hr>
<h1 id="创建Scrapy爬虫工程"><a href="#创建Scrapy爬虫工程" class="headerlink" title="创建Scrapy爬虫工程"></a>创建Scrapy爬虫工程</h1><p>演示HTML页面地址：<a href="http://python123.io/ws/demo.html" target="_blank" rel="noopener">http://python123.io/ws/demo.html</a></p>
<p>文件名称：demo.html</p>
<h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><p>应用Scrapy爬虫框架主要是编写<strong>配置型代码</strong>.</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><strong>建立一个Scrapy爬虫工程</strong>。选取一个目录，cmd打开命令行运行下述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy startproject python123demo   <span class="comment"># python123demo为工程名</span></span><br></pre></td></tr></table></figure>

<p><strong>生成的工程目录</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/1.png" class>

<ol>
<li>item.py：用来存储爬虫爬取下来的数据模型。</li>
<li>middlewares.py：用来存放各种中间件的文件。</li>
<li>pipelines.py：用来将items模型存储到本地磁盘中。</li>
<li>settings.py：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）</li>
<li>scrapy.cfg：项目的 配置文件。</li>
<li>spider文件夹：所有的爬虫代码文件。</li>
</ol>
<p>其中spiders/ 目录下的内容为：（后续生成的demo.py便在此文件下）</p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/2.png" class>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p><strong>在工程中产生一个Scrapy爬虫</strong>。进入工程目录（\python123demo目录下），然后执行如下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy genspider demo python123.io</span><br></pre></td></tr></table></figure>

<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/3.png" class>

<p>该命令作用：</p>
<p>(1) 生成一个名称为demo的spider（不能与项目名一致）</p>
<p>(2) 爬取网站的url为 python123.io</p>
<p>(3) 在spiders目录下增加代码文件demo.py</p>
<blockquote>
<p>该命令仅用于生成demo.py，该文件也可以手工生成.</p>
</blockquote>
<p><strong>demo.py文件</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/4.png" class>

<blockquote>
<p>类名为DemoSpider（demo为自己命名的demo文件），且继承自 <code>scrapy.Spider</code></p>
<p>name = “Demo”，当前爬虫名为Demo</p>
<p>allowed_domains: 是最开始在命令行中写入的域名，表示只能爬取该域名以下的相关链接</p>
<p>start_urls: 爬虫启动时最开始的url链接。是包含一个或多个url 的列表</p>
<p>parse：一个解析页面的空方法</p>
</blockquote>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>设置<code>settings.py</code>，设置了两个地方，第一是不遵守robots.txt协议（设为False）；第二是设置请求头，添加了user-agent选项。</p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/17.png" class>

<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p><strong>配置产生的spider爬虫</strong>。主要是对<code>demo.py</code>文件的编写修改。（这里的案例以爬取相关网址，获得html，并存储在文件中作为演示）</p>
<p>配置：（1）初始URL地址 （2）获取页面后的解析方式</p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/5.png" class>

<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>运行爬虫，获取网页</p>
<p>在命令行下，执行如下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy crawl demo</span><br></pre></td></tr></table></figure>

<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/6.png" class>

<p>parse方法中：</p>
<ul>
<li><code>fname = response.url.split(&#39;/&#39;)[-1]</code>，意为：从response响应中提取url，把最后的名字（即 ‘/’ 后的名字）作为待存储的本地文件名。</li>
<li></li>
</ul>
<p>demo爬虫被执行，捕获页面存储在demo.html</p>
<h2 id="demo-py代码的完整版本"><a href="#demo-py代码的完整版本" class="headerlink" title="demo.py代码的完整版本"></a>demo.py代码的完整版本</h2><img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/7.png" class>

<p><strong>demo.py两个等价版本的区别</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/8.png" class>

<h1 id="yield关键字的使用"><a href="#yield关键字的使用" class="headerlink" title="yield关键字的使用"></a>yield关键字的使用</h1><img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/9.png" class>

<p>生成器每调用一次在yield位置产生一个值，直到函数执行结束.</p>
<h2 id="为何要有生成器？"><a href="#为何要有生成器？" class="headerlink" title="为何要有生成器？"></a>为何要有生成器？</h2><img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/10.png" class>

<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/11.png" class>

<p><strong>demo.py</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/12.png" class>

<h1 id="Scrapy爬虫的基本使用"><a href="#Scrapy爬虫的基本使用" class="headerlink" title="Scrapy爬虫的基本使用"></a>Scrapy爬虫的基本使用</h1><h2 id="Scrapy爬虫的使用步骤"><a href="#Scrapy爬虫的使用步骤" class="headerlink" title="Scrapy爬虫的使用步骤"></a>Scrapy爬虫的使用步骤</h2><p>步骤1：创建一个工程和Spider模板</p>
<p>步骤2：编写Spider</p>
<p>步骤3：编写Item Pipeline：对Spider提取信息的后续处理做相关的定义</p>
<p>步骤4：优化配置策略</p>
<h2 id="Scrapy爬虫的数据类型"><a href="#Scrapy爬虫的数据类型" class="headerlink" title="Scrapy爬虫的数据类型"></a>Scrapy爬虫的数据类型</h2><p>注意：这里的request类和response类是Scrapy库的，和requests库的不是完全一致，但几乎相同。</p>
<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><p><code>class scrapy.http.Request()</code></p>
<p>Request对象表示一个HTTP请求，由Spider生成，由Downloader执行。</p>
<p><strong>属性和方法</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/13.png" class>

<h3 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h3><p><code>class scrapy.http.Response()</code></p>
<p>Response对象表示一个HTTP响应，由Downloader生成，由Spider处理。</p>
<p><strong>属性和方法</strong></p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/14.png" class>

<h3 id="Item类"><a href="#Item类" class="headerlink" title="Item类"></a>Item类</h3><p><code>class scrapy.item.Item()</code></p>
<p>Item对象表示一个从HTML页面中提取的信息内容</p>
<p>由Spider生成，由Item Pipeline处理</p>
<p>Item类似字典类型，可以按照字典类型操作</p>
<blockquote>
<p>在scrapy爬虫中，Spider爬取网页，得到的信息以键值对的形式封装成字典，这种字典就是<code>Item</code>类</p>
</blockquote>
<h2 id="Scrapy爬虫提取信息的方法"><a href="#Scrapy爬虫提取信息的方法" class="headerlink" title="Scrapy爬虫提取信息的方法"></a>Scrapy爬虫提取信息的方法</h2><img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/15.png" class>

<p>重点介绍<strong>CSS Selector</strong>的基本使用。</p>
<img src="/2020/07/03/python%E7%88%AC%E8%99%AB-07/16.png" class>

<blockquote>
<p>该方法在scrapy框架中十分常见，比较简单，需要掌握。</p>
</blockquote>
<h1 id="补充：Xpath"><a href="#补充：Xpath" class="headerlink" title="补充：Xpath"></a>补充：Xpath</h1><p>Xpath在Scrapy框架中常用。</p>
<h2 id="Xpath语法"><a href="#Xpath语法" class="headerlink" title="Xpath语法"></a>Xpath语法</h2><p>其实只分为3类</p>
<ul>
<li>层级：<code>/</code>直接子级，<code>//</code>跳级</li>
<li>属性：<code>@</code> 属性访问</li>
<li>函数：<code>contains()</code>、<code>text()</code>等。<ul>
<li>contains()：检测某个属性并不是完全等于某个值，而是<strong>包含</strong>某个值。</li>
<li>text()：对标签内的文字结点进行提取。</li>
</ul>
</li>
</ul>
<h2 id="在Scrapy中的应用"><a href="#在Scrapy中的应用" class="headerlink" title="在Scrapy中的应用"></a>在Scrapy中的应用</h2><p>scrapy中支持Xpath的使用，<code>response.xpath()</code>直接调用即可。</p>
<p><strong>案例</strong>：糗事百科，提取作者、文章详情页的url，和文章内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkSpiderSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'qsbk_spider'</span></span><br><span class="line">    allowed_domains = [<span class="string">'qiushibaike.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://qiushibaike.com/text/page/1/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># selectorList 类型</span></span><br><span class="line">        duanziDivs = response.xpath(<span class="string">"//div[@class='col1 old-style-col1']/div"</span>)</span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> duanziDivs:</span><br><span class="line">            <span class="comment"># div: Selector类型</span></span><br><span class="line">            <span class="comment"># div.xpath()：selectorList类型</span></span><br><span class="line">            author = div.xpath(<span class="string">".//h2/text()"</span>).get().strip()</span><br><span class="line">            <span class="comment"># get()函数，取到第一个结果（str类型）, get()&lt;=&gt;extract_first()</span></span><br><span class="line">            <span class="comment"># extract(): 提取所有结果组成列表，每个元素是str类型</span></span><br><span class="line">            <span class="comment"># strip(): 去掉前后的空格</span></span><br><span class="line"></span><br><span class="line">            href = div.xpath(<span class="string">'./a/@href'</span>).get() <span class="comment"># 获取a标签内的href的属性值</span></span><br><span class="line">            url = urljoin(self.start_urls[<span class="number">0</span>],href) <span class="comment"># 跳转到详情页</span></span><br><span class="line"></span><br><span class="line">            content = div.xpath(<span class="string">".//div[@class='content']//text()"</span>).extract()</span><br><span class="line">            <span class="comment"># html中该div下有span标签，span中才是内容，//text()直接提取该内容</span></span><br><span class="line"></span><br><span class="line">            content = <span class="string">''</span>.join(content).strip()</span><br><span class="line"></span><br><span class="line">            tplt = <span class="string">"&#123;0:&#123;2&#125;&lt;20&#125;\t&#123;1:^50&#125;"</span></span><br><span class="line">            print(tplt.format(author,url,chr(<span class="number">12288</span>)))</span><br><span class="line">            print(content)</span><br><span class="line">            print(<span class="string">'='</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_06(Scrapy介绍)</title>
    <url>/2020/07/02/Python%E7%88%AC%E8%99%AB-06/</url>
    <content><![CDATA[<p>本篇总结python爬虫的重要<strong>框架</strong>——<strong>Scrapy</strong>。</p>
<a id="more"></a>

<hr>
<h1 id="Scrapy爬虫框架介绍"><a href="#Scrapy爬虫框架介绍" class="headerlink" title="Scrapy爬虫框架介绍"></a>Scrapy爬虫框架介绍</h1><p>Scrapy是一个快速功能强大的网络爬虫框架。</p>
<h2 id="Scrapy的安装"><a href="#Scrapy的安装" class="headerlink" title="Scrapy的安装"></a>Scrapy的安装</h2><p>以管理员身份运行Scrapy平台，输入以下命令即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure>

<h2 id="Scrapy爬虫框架结构"><a href="#Scrapy爬虫框架结构" class="headerlink" title="Scrapy爬虫框架结构"></a>Scrapy爬虫框架结构</h2><p>Scrapy不是一个函数功能库，而是一个爬虫框架。</p>
<h3 id="什么是爬虫框架？"><a href="#什么是爬虫框架？" class="headerlink" title="什么是爬虫框架？"></a>什么是爬虫框架？</h3><ul>
<li>爬虫框架是实现爬虫功能的一个软件结构和功能组件集合。 </li>
<li>爬虫框架是一个半成品，能够帮助用户实现专业网络爬虫。</li>
</ul>
<h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5+2 结构"></a>5+2 结构</h3><img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/1.png" class>

<h3 id="数据流的三种路径"><a href="#数据流的三种路径" class="headerlink" title="数据流的三种路径"></a>数据流的三种路径</h3><img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/2.png" class>

<img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/3.png" class>

<img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/4.png" class>

<h3 id="数据流的出入口"><a href="#数据流的出入口" class="headerlink" title="数据流的出入口"></a>数据流的出入口</h3><img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/5.png" class>

<p>需要注意的是：scrapy的五个模块中，DOWNLOADER、SCHEDULER和ENGINE三个已经实现，用户只需编写配置SPIDERS和ITEM PIPELINES两个模块即可。</p>
<h1 id="Scrapy爬虫框架解析"><a href="#Scrapy爬虫框架解析" class="headerlink" title="Scrapy爬虫框架解析"></a>Scrapy爬虫框架解析</h1><p>主要是对五个模块和两个中间键。</p>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><p>(1) 控制所有模块之间的数据流</p>
<p>(2) 根据条件触发事件 </p>
<p>不需要用户修改</p>
<h2 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h2><p>根据请求下载网页 不需要用户修改</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>对所有爬取请求进行调度管理 不需要用户修改</p>
<h2 id="Downloader-Middleware"><a href="#Downloader-Middleware" class="headerlink" title="Downloader Middleware"></a>Downloader Middleware</h2><p><strong>目的</strong>：实施Engine、Scheduler和Downloader 之间进行用户可配置的控制 </p>
<p><strong>功能</strong>：修改、丢弃、新增请求或响应 </p>
<p>用户可以编写配置代码</p>
<h2 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h2><p>(1) 解析Downloader返回的响应（Response）</p>
<p>(2) 产生爬取项（scraped item） </p>
<p>(3) 产生额外的爬取请求（Request） </p>
<p>需要用户编写配置代码</p>
<h2 id="Item-Pipelines"><a href="#Item-Pipelines" class="headerlink" title="Item Pipelines"></a>Item Pipelines</h2><p>(1) 以流水线方式处理Spider产生的爬取项 </p>
<p>(2) 由一组操作顺序组成，类似流水线，每个操 作是一个Item Pipeline类型 </p>
<p>(3) 可能操作包括：清理、检验和查重爬取项中 的HTML数据、将数据存储到数据库 </p>
<p>需要用户编写配置代码</p>
<h2 id="Spider-Middleware"><a href="#Spider-Middleware" class="headerlink" title="Spider Middleware"></a>Spider Middleware</h2><p><strong>目的</strong>：对请求和爬取项的再处理 </p>
<p><strong>功能</strong>：修改、丢弃、新增请求或爬取项 </p>
<p>用户可以编写配置代码</p>
<h1 id="requests库和Scrapy爬虫的比较"><a href="#requests库和Scrapy爬虫的比较" class="headerlink" title="requests库和Scrapy爬虫的比较"></a>requests库和Scrapy爬虫的比较</h1><h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><ul>
<li><p>两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线 </p>
</li>
<li><p>两者可用性都好，文档丰富，入门简单 </p>
</li>
<li><p>两者都没有处理js、提交表单、应对验证码等功能（可扩展）</p>
</li>
</ul>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/6.png" class>

<h2 id="如何选择呢？"><a href="#如何选择呢？" class="headerlink" title="如何选择呢？"></a>如何选择呢？</h2><p>面临一个爬取需求，我们该选用requests库还是Scrapy库呢？</p>
<ul>
<li>非常小的需求，requests库 </li>
<li>不太小的需求，Scrapy框架 </li>
<li>定制程度很高的需求（不考虑规模），自搭框架，requests &gt; Scrapy</li>
</ul>
<h1 id="Scrapy爬虫的常用命令"><a href="#Scrapy爬虫的常用命令" class="headerlink" title="Scrapy爬虫的常用命令"></a>Scrapy爬虫的常用命令</h1><p>Scrapy是为持续运行设计的专业爬虫框架，提供操作的Scrapy命令行，主要通过cmd命令行实现。</p>
<h2 id="Scrapy命令行格式"><a href="#Scrapy命令行格式" class="headerlink" title="Scrapy命令行格式"></a>Scrapy命令行格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;scrapy &lt;command&gt; [options] [args]</span><br></pre></td></tr></table></figure>

<h2 id="Scrapy常用命令"><a href="#Scrapy常用命令" class="headerlink" title="Scrapy常用命令"></a>Scrapy常用命令</h2><img src="/2020/07/02/Python%E7%88%AC%E8%99%AB-06/7.png" class>

<h2 id="为什么Scrapy采用命令行创建和运行爬虫？"><a href="#为什么Scrapy采用命令行创建和运行爬虫？" class="headerlink" title="为什么Scrapy采用命令行创建和运行爬虫？"></a>为什么Scrapy采用命令行创建和运行爬虫？</h2><ul>
<li><p>命令行（不是图形界面）更容易自动化，适合脚本控制</p>
</li>
<li><p>本质上，Scrapy是给程序员用的，功能（而不是界面）更重要</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_05(正则表达式)</title>
    <url>/2020/07/01/Python%E7%88%AC%E8%99%AB-05/</url>
    <content><![CDATA[<p>本篇总结 <strong>正则</strong> 在python爬虫中的应用。</p>
<a id="more"></a>

<hr>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>之前有过总结，不再赘述，也可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>。</p>
<p>这里做一些概要的总结，供以后使用时参阅。</p>
<h2 id="正则表达式的常用操作符"><a href="#正则表达式的常用操作符" class="headerlink" title="正则表达式的常用操作符"></a>正则表达式的常用操作符</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/1.png" class>

<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/2.png" class>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/3.png" class>

<h3 id="IP地址的匹配"><a href="#IP地址的匹配" class="headerlink" title="IP地址的匹配"></a>IP地址的匹配</h3><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/4.png" class>

<h1 id="Re库"><a href="#Re库" class="headerlink" title="Re库"></a>Re库</h1><p>Re库是python的标准库，主要用于字符串匹配。调用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式的表示类型"><a href="#正则表达式的表示类型" class="headerlink" title="正则表达式的表示类型"></a>正则表达式的表示类型</h2><p>采用<code>raw string</code>类型（原生字符串类型），表示为<code>r&#39;text&#39;</code>，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r'[1-9]\d&#123;5&#125;'</span> <span class="comment"># 六位邮政编码</span></span><br><span class="line"><span class="string">r'\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;'</span></span><br></pre></td></tr></table></figure>

<p><code>raw string</code>是不包含<strong>转义符</strong>的字符串</p>
<p>正则表达式也可以用string类型，但较为繁琐，因为<code>\</code>会被理解为转义符。</p>
<h2 id="Re库的主要功能函数"><a href="#Re库的主要功能函数" class="headerlink" title="Re库的主要功能函数"></a>Re库的主要功能函数</h2><p>主要有六个功能函数。</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/5.png" class>

<p>下面依次介绍。</p>
<h3 id="1、re-search-pattern-string-flags-0"><a href="#1、re-search-pattern-string-flags-0" class="headerlink" title="1、re.search(pattern, string, flags=0)"></a>1、re.search(<strong>pattern</strong>, <strong>string</strong>, <strong>flags=0</strong>)</h3><p>在一个字符串中搜索匹配正则表达式的第一个位置，返回<strong>match</strong>对象。</p>
<p>参数：</p>
<ul>
<li><p><strong>pattern</strong> : 正则表达式的字符串或原生字符串表示。</p>
</li>
<li><p><strong>string</strong> : 待匹配字符串</p>
</li>
<li><p><strong>flags</strong> : 正则表达式使用时的控制标记</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/6.png" class>

</li>
</ul>
<h3 id="2、re-match-pattern-string-flags-0"><a href="#2、re-match-pattern-string-flags-0" class="headerlink" title="2、re.match(pattern, string, flags=0)"></a>2、re.match(<strong>pattern</strong>, <strong>string</strong>, <strong>flags=0</strong>)</h3><p>从一个字符串的开始位置起匹配正则表达式，返回<strong>match</strong>对象</p>
<p>参数同上。</p>
<p>但需要<strong>注意</strong>，这是从待匹配字符串的第一个位置开始，即第一个字符不符合匹配条件，就得不到结果。</p>
<h3 id="3、re-findall-pattern-string-flags-0"><a href="#3、re-findall-pattern-string-flags-0" class="headerlink" title="3、re.findall(pattern, string, flags=0)"></a>3、re.findall(<strong>pattern</strong>, <strong>string</strong>, <strong>flags=0</strong>)</h3><p>搜索字符串，以列表类型返回全部能匹配的子串</p>
<p>参数同上。</p>
<p><strong>注意</strong>：返回的是列表形式，每个元素为匹配成功的字符串。</p>
<h3 id="4、re-split-pattern-string-maxsplit-0-flags-0"><a href="#4、re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="4、re.split(pattern, string, maxsplit=0, flags=0)"></a>4、re.split(<strong>pattern</strong>, <strong>string</strong>, <strong>maxsplit=0</strong>, <strong>flags=0</strong>)</h3><p>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</p>
<p>参数：</p>
<ul>
<li><strong>maxsplit</strong>: 最大分割数，剩余部分作为最后一个元素输出</li>
</ul>
<p><strong>举例</strong>：</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/7.png" class>

<h3 id="5、re-finditer-pattern-string-flags-0"><a href="#5、re-finditer-pattern-string-flags-0" class="headerlink" title="5、re.finditer(pattern, string, flags=0)"></a>5、re.finditer(<strong>pattern</strong>, <strong>string</strong>, <strong>flags=0</strong>)</h3><p>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</p>
<h3 id="6、re-sub-pattern-repl-string-count-0-flags-0"><a href="#6、re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="6、re.sub(pattern, repl, string, count=0, flags=0)"></a>6、re.sub(<strong>pattern</strong>, <strong>repl</strong>, <strong>string</strong>, <strong>count=0</strong>, <strong>flags=0</strong>)</h3><p>在一个字符串中替换所有匹配正则表达式的子串返回替换后的字符串</p>
<p>参数：</p>
<ul>
<li><strong>repl</strong> : 替换匹配字符串的字符串</li>
<li><strong>count</strong> : 匹配的最大替换次数</li>
</ul>
<p><strong>举例</strong></p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/8.png" class>

<h2 id="Re库的另一种等价用法"><a href="#Re库的另一种等价用法" class="headerlink" title="Re库的另一种等价用法"></a>Re库的另一种等价用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数式用法：一次性操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst = re.search(<span class="string">r'[1‐9]\d&#123;5&#125;'</span>, <span class="string">'BIT 100081'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上下两种方法等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向对象用法：编译后的多次操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">r'[1‐9]\d&#123;5&#125;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst = pat.search(<span class="string">'BIT 100081'</span>)</span><br></pre></td></tr></table></figure>

<p>为此介绍如下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regex = re.compile(pattern, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>将正则表达式的字符串形式编译成正则表达式对象 <code>regex</code>。</p>
<p>然后结合相应的六种方法。</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/9.png" class>

<h1 id="Re库的Match对象"><a href="#Re库的Match对象" class="headerlink" title="Re库的Match对象"></a>Re库的Match对象</h1><p>Match对象是一次匹配的结果，包含匹配的很多信息</p>
<h2 id="Match对象的属性"><a href="#Match对象的属性" class="headerlink" title="Match对象的属性"></a>Match对象的属性</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/10.png" class>

<h2 id="Match对象的方法"><a href="#Match对象的方法" class="headerlink" title="Match对象的方法"></a>Match对象的方法</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/11.png" class>

<p><strong>实例：</strong></p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/12.png" class>

<h1 id="Re库的贪婪匹配和最小匹配"><a href="#Re库的贪婪匹配和最小匹配" class="headerlink" title="Re库的贪婪匹配和最小匹配"></a>Re库的贪婪匹配和最小匹配</h1><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>同时匹配长短不同的多项，返回哪一个呢？</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/13.png" class>

<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>match = re.search(<span class="string">r'PY.*N'</span>, <span class="string">'PYANBNCNDN'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">'PYANBNCNDN'</span></span><br></pre></td></tr></table></figure>

<p>Re库默认采用贪婪匹配，即输出匹配最长的子串</p>
<h2 id="最小匹配"><a href="#最小匹配" class="headerlink" title="最小匹配"></a>最小匹配</h2><p>加操作符<code>?</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>match = re.search(<span class="string">r'PY.*?N'</span>, <span class="string">'PYANBNCNDN'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">'PYAN'</span></span><br></pre></td></tr></table></figure>

<h2 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/14.png" class>

<p>只要长度输出可能不同的，都可以通过在操作符后增加<code>?</code>变成最小匹配</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-05/15.png" class>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_04(信息提取)</title>
    <url>/2020/07/01/Python%E7%88%AC%E8%99%AB-04/</url>
    <content><![CDATA[<p>本篇总结爬取时 <strong>信息标记</strong> 和 <strong>提取方法</strong> 。</p>
<a id="more"></a>

<hr>
<h1 id="信息标记的三种形式"><a href="#信息标记的三种形式" class="headerlink" title="信息标记的三种形式"></a>信息标记的三种形式</h1><ul>
<li><p>标记后的信息可形成信息组织结构，增加了信息维度 </p>
</li>
<li><p>标记的结构与信息一样具有重要价值 </p>
</li>
<li><p>标记后的信息可用于通信、存储或展示 </p>
</li>
<li><p>标记后的信息更利于程序理解和运用</p>
</li>
</ul>
<p>有三种形式，XML，JSON，YAML</p>
<h2 id="1、XML"><a href="#1、XML" class="headerlink" title="1、XML"></a>1、XML</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、JSON"><a href="#2、JSON" class="headerlink" title="2、JSON"></a>2、JSON</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"key":"value"</span><br><span class="line">"key":["value1","value2"]</span><br><span class="line">"key":&#123;</span><br><span class="line">    "subkey1":"subvalue1",</span><br><span class="line">    "subkey2":"subvalue2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：JSON无法表示注释内容。</p>
</blockquote>
<h2 id="3、YAML"><a href="#3、YAML" class="headerlink" title="3、YAML"></a>3、YAML</h2><p>缩进表达所属关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"><span class="attr">key :</span> <span class="comment"># comment</span></span><br><span class="line"><span class="string">-value1</span></span><br><span class="line"><span class="string">-value2</span></span><br><span class="line"><span class="attr">key :</span> </span><br><span class="line">	<span class="attr">subKey :</span> <span class="string">subvalue</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">|</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">xxx</span>			<span class="comment"># | 表达整块数据</span></span><br></pre></td></tr></table></figure>

<h1 id="信息提取的一般方法"><a href="#信息提取的一般方法" class="headerlink" title="信息提取的一般方法"></a>信息提取的一般方法</h1><h2 id="1、完整解析信息的标记形式"><a href="#1、完整解析信息的标记形式" class="headerlink" title="1、完整解析信息的标记形式"></a>1、完整解析信息的标记形式</h2><p>需要标记解析器，例如：bs4库的标签树遍历</p>
<ul>
<li>优点：信息解析准确 </li>
<li>缺点：提取过程繁琐，速度慢</li>
</ul>
<h2 id="2、无视标记形式，直接搜索关键信息"><a href="#2、无视标记形式，直接搜索关键信息" class="headerlink" title="2、无视标记形式，直接搜索关键信息"></a>2、无视标记形式，直接搜索关键信息</h2><p>对信息的文本查找函数即可。</p>
<ul>
<li>优点：提取过程简洁，速度较快 </li>
<li>缺点：提取结果准确性与信息内容相关</li>
</ul>
<h2 id="3、融合方法"><a href="#3、融合方法" class="headerlink" title="3、融合方法"></a>3、融合方法</h2><p>结合形式解析与搜索方法，提取关键信息。</p>
<p>需要标记解析器及文本查找函数。</p>
<p>主要学习下面的bs4中的<code>find_all()</code>的查找方法。</p>
<h1 id="基于bs4库的HTML内容查找方法"><a href="#基于bs4库的HTML内容查找方法" class="headerlink" title="基于bs4库的HTML内容查找方法"></a>基于bs4库的HTML内容查找方法</h1><h2 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h2><p>掌握最主要的<code>find_all()</code>方法的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;Tag&gt;.find_all(name, attrs, recursive, string, **kwargs)</span><br></pre></td></tr></table></figure>

<p>该函数的使用说明：</p>
<ol>
<li><p>返回的是<strong>列表</strong>类型，存储查找的结果</p>
</li>
<li><p>参数解释：</p>
<ol>
<li><p>name: 对标签名称的检索字符串</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/1.png" class>

<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/2.png" class>

<blockquote>
<p>这里引用了正则表达式的相关知识，首先<code>import re</code>，引入该模块，调用的方法是<code>re.compile(&#39;b&#39;)</code>，这表示：模糊查询带有’b’的字符串，例如本题，查找带有字符’b’的所有标签，得到结果为 <b>和<body></body></b></p>
</blockquote>
</li>
<li><p>attrs：对标签属性值的检索字符串，可标注属性检索</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/3.png" class>

<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/4.png" class>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find(<span class="string">'h1'</span>, attrs = [<span class="string">'class'</span>:<span class="string">'ph'</span>]) <span class="comment"># 查找h1标签，且属性值class为ph</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，BeautifulSoup库中的查询是严格的，可以引用re模块来进行模糊查询。</p>
</blockquote>
</li>
<li><p>recursive：是否对子孙全部检索，默认True</p>
</li>
<li><p>string：<code>&lt;&gt;...&lt;/&gt;</code>中字符串区域的检索字符串</p>
</li>
</ol>
</li>
</ol>
<p>查找方法的等价形式（更简便）</p>
<img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/6.png" class>

<h2 id="其他查找方法"><a href="#其他查找方法" class="headerlink" title="其他查找方法"></a>其他查找方法</h2><img src="/2020/07/01/Python%E7%88%AC%E8%99%AB-04/5.png" class>

<h1 id="实例：中国大学的排名爬虫"><a href="#实例：中国大学的排名爬虫" class="headerlink" title="实例：中国大学的排名爬虫"></a>实例：中国大学的排名爬虫</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CrawUnivRankingA.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>) <span class="comment"># r返回的是一个Response对象</span></span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text <span class="comment"># 返回的r中的内容，即html代码的字符串形式</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'连接失败'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># soup.find('tbody')返回的是bs4.element.Tag类型</span></span><br><span class="line">        <span class="comment"># soup.find('tbody').children返回的是list_iterator类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag): <span class="comment"># import bs4 库，使用标签类型</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>) <span class="comment"># 简写形式，等价于 tr.find_all('td')</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"总分"</span>,chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>],chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 20 univs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_03(BeautifulSoup库的使用)</title>
    <url>/2020/06/30/Python%E7%88%AC%E8%99%AB-03/</url>
    <content><![CDATA[<p>本篇总结 <strong>BeautifulSoup</strong> 库的安装使用（补充了<strong>Xpath</strong>）。</p>
<a id="more"></a>

<hr>
<h1 id="BeautifulSoup初步"><a href="#BeautifulSoup初步" class="headerlink" title="BeautifulSoup初步"></a>BeautifulSoup初步</h1><p>安装很容易，管理员打开命令行窗口，输入<code>pip install BeautifulSoup</code>，即可。</p>
<p>使用BeautifulSoup主要两行代码即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引用bs4库的BeautifulSoup类</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># html代码可以是requests库读取的网页代码 解析器：html的parser</span></span><br><span class="line">soup = BeautifulSoup(html代码, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可查看有代码缩进的html页面代码</span></span><br><span class="line">print(soup.prettify())</span><br></pre></td></tr></table></figure>

<h1 id="BeautifulSoup库的基本元素"><a href="#BeautifulSoup库的基本元素" class="headerlink" title="BeautifulSoup库的基本元素"></a>BeautifulSoup库的基本元素</h1><p>HTML文档、标签树和BeautifulSoup类的关系是等价的。</p>
<p>BeautifulSoup对应一个HTML/XML文档的全部内容</p>
<p>BeautifulSoup有四种解析器，其他三种需要另行安装。</p>
<h2 id="BeautifulSoup类的基本元素"><a href="#BeautifulSoup类的基本元素" class="headerlink" title="BeautifulSoup类的基本元素"></a>BeautifulSoup类的基本元素</h2><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/1.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/2.png" class>

<h3 id="1、Tag标签"><a href="#1、Tag标签" class="headerlink" title="1、Tag标签"></a>1、Tag标签</h3><p>任何存在于HTML语法中的标签都可以用<code>soup.&lt;Tag&gt;</code>访问获得 当HTML文档中存在多个相同<code>&lt;Tag&gt;</code>对应内容时，<code>soup.&lt;Tag&gt;</code>返回第一个。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.title</span><br><span class="line">&lt;title&gt;This is a title&lt;/title&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2、Tag的name"><a href="#2、Tag的name" class="headerlink" title="2、Tag的name"></a>2、Tag的name</h3><p>每个<code>&lt;Tag&gt;</code>都有自己的名字，通过<code>&lt;Tag&gt;.name</code>获取，字符串类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.name</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a.parent.name <span class="comment"># 包裹a的第一层标签为p标签</span></span><br><span class="line"><span class="string">'p'</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Tag的attrs（属性）"><a href="#3、Tag的attrs（属性）" class="headerlink" title="3、Tag的attrs（属性）"></a>3、Tag的attrs（属性）</h3><p>一个<code>&lt;Tag&gt;</code>可以有 0或多个属性，字典类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.attrs</span><br><span class="line">&#123;<span class="string">'href'</span>: <span class="string">'http://www.icourse163.org/course/BIT-268001'</span>, <span class="string">'class'</span>: [<span class="string">'py1'</span>], <span class="string">'id'</span>: <span class="string">'link1'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.attrs[<span class="string">'href'</span>]</span><br><span class="line"><span class="string">'http://www.icourse163.org/course/BIT-268001'</span></span><br></pre></td></tr></table></figure>

<h3 id="4、Tag的NavigableString"><a href="#4、Tag的NavigableString" class="headerlink" title="4、Tag的NavigableString"></a>4、Tag的NavigableString</h3><p>NavigableString可以跨越多个层次。即直接获取<code>&lt;p&gt;&lt;a&gt;xxxx&lt;/a&gt;&lt;/p&gt;</code>里的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.p</span><br><span class="line">&lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.p.string</span><br><span class="line"><span class="string">'The demo python introduces several python courses.'</span></span><br></pre></td></tr></table></figure>

<h3 id="5、Tag的Comment"><a href="#5、Tag的Comment" class="headerlink" title="5、Tag的Comment"></a>5、Tag的Comment</h3><p>提取注释部分。</p>
<h1 id="基于bs4库的HTML内容遍历方法"><a href="#基于bs4库的HTML内容遍历方法" class="headerlink" title="基于bs4库的HTML内容遍历方法"></a>基于bs4库的HTML内容遍历方法</h1><p>有三种遍历方法：下行、上行和平行遍历。</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/3.png" class>

<h2 id="1、标签树的下行遍历"><a href="#1、标签树的下行遍历" class="headerlink" title="1、标签树的下行遍历"></a>1、标签树的下行遍历</h2><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/4.png" class>

<p>BeautifulSoup类型是标签树的根节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.body.contents</span><br><span class="line">['\n', &lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;, '\n', &lt;p class="course"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:</span><br><span class="line">&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;, '\n']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(soup.body.contents)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：返回的是列表。</p>
<p><strong>遍历方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历儿子结点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    print(child)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历子孙结点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.descendants:</span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>

<h2 id="2、标签树的上行遍历"><a href="#2、标签树的上行遍历" class="headerlink" title="2、标签树的上行遍历"></a>2、标签树的上行遍历</h2><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/5.png" class>

<p><strong>实例</strong>：遍历所有先辈节点，包括soup本身，所以要区别判断</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/6.png" class>

<h2 id="3、标签树的平行遍历"><a href="#3、标签树的平行遍历" class="headerlink" title="3、标签树的平行遍历"></a>3、标签树的平行遍历</h2><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/7.png" class>

<p><strong>注意：</strong></p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/8.png" class>

<p><strong>遍历</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next_sibling:</span><br><span class="line">    print(sibling)			<span class="comment"># 遍历后续结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.previous_sibling:</span><br><span class="line">	print(sibling)			<span class="comment"># 遍历前续结点</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/9.png" class>

<h1 id="基于bs4库的HTML格式输出"><a href="#基于bs4库的HTML格式输出" class="headerlink" title="基于bs4库的HTML格式输出"></a>基于bs4库的HTML格式输出</h1><p>能否让HTML内容更加“友好”的显示？</p>
<h2 id="bs4库的prettify-方法"><a href="#bs4库的prettify-方法" class="headerlink" title="bs4库的prettify()方法"></a>bs4库的prettify()方法</h2><p>可以使读取的html内容格式化输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于文本和标签</span></span><br><span class="line">soup.prettify() </span><br><span class="line">soup.a.prettify()</span><br></pre></td></tr></table></figure>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-03/10.png" class>

<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_02(requests库实例)</title>
    <url>/2020/06/30/Python%E7%88%AC%E8%99%AB-02/</url>
    <content><![CDATA[<p>这部分是爬虫初步的 <strong>爬取实例</strong> ，涉及网站、搜索、图片等查询。</p>
<a id="more"></a>

<hr>
<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/1.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/6.png" class>

<h1 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h1><p><strong>作用</strong>：网站告知网络爬虫哪些页面可以抓取，哪些不行。</p>
<p><strong>形式：</strong>在网站根目录下的robots.txt文件</p>
<p>基本语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释，*代表所有，/代表根目录 </span></span><br><span class="line">User‐agent: * </span><br><span class="line">Disallow: /</span><br></pre></td></tr></table></figure>

<p>百度robots协议查看：<a href="https://www.baidu.com/robots.txt" target="_blank" rel="noopener">https://www.baidu.com/robots.txt</a></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="1、爬取亚马逊商品信息"><a href="#1、爬取亚马逊商品信息" class="headerlink" title="1、爬取亚马逊商品信息"></a>1、爬取亚马逊商品信息</h2><p>在我们用简单的get方法爬取时，获取状态码显示503</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/2.png" class>

<p>返回的 r 中包含 request 请求。</p>
<p>通过<code>r.request.headers</code>查看头部信息，看到User-Agent选项不是浏览器的信息，可以得知亚马逊会组织非浏览器的访问。</p>
<p><strong>方法：</strong>更改头部信息，使该爬虫模拟浏览器登录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kv = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">url = <span class="string">"https://www.amazon.cn/gp/product/B01M8L5Z3Y"</span></span><br><span class="line">r = requests.get(url, headers = kv)</span><br></pre></td></tr></table></figure>

<p>此时即可正常爬取。</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/3.png" class>

<h2 id="2、爬虫指定关键字到百度查询结果"><a href="#2、爬虫指定关键字到百度查询结果" class="headerlink" title="2、爬虫指定关键字到百度查询结果"></a>2、爬虫指定关键字到百度查询结果</h2><p>百度的关键词接口：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://www.baidu.com/s?wd=keyword</span><br></pre></td></tr></table></figure>

<p>输入keyword得到搜索引擎的搜索结果。</p>
<p>即对我们的requests库，构造这样的url即可。</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/4.png" class>

<h2 id="3、网络图片的爬取和存储"><a href="#3、网络图片的爬取和存储" class="headerlink" title="3、网络图片的爬取和存储"></a>3、网络图片的爬取和存储</h2><p>图片在网络上的存储地址以图片的后缀为结尾。</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-02/5.png" class>

<p>代码中，<code>r.content</code>是内容的二进制形式，写入目标文件可得到相应图片。</p>
<h1 id="补充（url拼接）"><a href="#补充（url拼接）" class="headerlink" title="补充（url拼接）"></a>补充（url拼接）</h1><p>如果遇到url的拼接问题，建议使用 ``urllib.parse<code>的</code>urljoin` 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.youtube.com/'</span></span><br><span class="line">path = <span class="string">'/index.html'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urljoin(url, path)</span><br><span class="line"><span class="string">'http://www.youtube.com/index.html'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url + path</span><br><span class="line"><span class="string">'http://www.youtube.com//index.html'</span></span><br></pre></td></tr></table></figure>

<p>可以解决一些url 用 + 连接符产生的问题。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫_01(requests库)</title>
    <url>/2020/06/30/Python%E7%88%AC%E8%99%AB-01/</url>
    <content><![CDATA[<p>这部分是python记录爬虫功能的笔记，刚刚入门，这篇总结 <strong>requests</strong> 库的使用。</p>
<a id="more"></a>

<hr>
<p>关于更多requests库的知识，可以查看<a href="https://requests.readthedocs.io/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">官方网站</a>。</p>
<p>request 库需要安装，比较容易，不再赘述。</p>
<p>requests库中有七个常用方法。</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/1.png" class>

<h1 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h1><p>获取一个网页最简单的方法就是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(url)</span><br></pre></td></tr></table></figure>

<p> 该方法用于构造一个向服务器请求资源的<code>Request</code>对象，该对象为requests库内部生成的。该方法返回的内容是一个包含服务器资源的<strong>Response</strong>对象，用<code>r</code>表示，代表一个Response对象。</p>
<p>get方法的完整使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.get(url [, params = <span class="literal">None</span>, **kwargs])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数含义：</p>
<ul>
<li>url：拟获取页面的url链接</li>
<li>params：url中的额外参数，字典或字节流格式，可选</li>
<li>**kwargs：12个控制访问的参数</li>
</ul>
</blockquote>
<p>通过查看requests库的源码我们可以发现，七个方法中，其他六个方法都是对get的调用，所以也可认为只有一个get()方法。</p>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>Response对象包含爬虫返回的所有内容。</p>
<h3 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h3><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/2.png" class>

<p>理解Requests库的异常</p>
<h1 id="爬取网页的通用代码框架"><a href="#爬取网页的通用代码框架" class="headerlink" title="爬取网页的通用代码框架"></a>爬取网页的通用代码框架</h1><p>网络连接有风险，异常处理很重要。</p>
<h3 id="Request对象的异常"><a href="#Request对象的异常" class="headerlink" title="Request对象的异常"></a>Request对象的异常</h3><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/3.png" class>

<h3 id="Response对象的异常"><a href="#Response对象的异常" class="headerlink" title="Response对象的异常"></a>Response对象的异常</h3><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/4.png" class>

<h2 id="爬取页面的通用代码框架"><a href="#爬取页面的通用代码框架" class="headerlink" title="爬取页面的通用代码框架"></a>爬取页面的通用代码框架</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment"># 如果状态码不是200，引发HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding <span class="comment"># 使得返回内容的解码是正确的</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'产生异常'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure>

<h1 id="HTTP协议及requests库方法"><a href="#HTTP协议及requests库方法" class="headerlink" title="HTTP协议及requests库方法"></a>HTTP协议及requests库方法</h1><img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/5.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/6.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/7.png" class>

<p><strong>一些方法的简单举例</strong></p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/8.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/9.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/10.png" class>

<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/11.png" class>

<h1 id="Requests库的主要方法解析"><a href="#Requests库的主要方法解析" class="headerlink" title="Requests库的主要方法解析"></a>Requests库的主要方法解析</h1><h2 id="1-requests-request-method-url-kwargs"><a href="#1-requests-request-method-url-kwargs" class="headerlink" title="1. requests.request(method, url, \kwargs)"></a>1. requests.request(<strong>method</strong>, <strong>url</strong>, <strong><em>\</em>kwargs</strong>)</h2><ul>
<li>method：请求方式，对应get/put/post等7种</li>
<li>url：拟获取页面的url链接</li>
<li>**kwargs：控制访问的参数，共13个</li>
</ul>
<h3 id="method的7种"><a href="#method的7种" class="headerlink" title="method的7种"></a>method的7种</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.request(<span class="string">'GET'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'HEAD'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'POST'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'PUT'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'PATCH'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'delete'</span>, url, **kwargs)</span><br><span class="line">r = requests.request(<span class="string">'OPTIONS'</span>, url, **kwargs) <span class="comment"># 不常用</span></span><br></pre></td></tr></table></figure>

<h3 id="kwargs-控制访问的参数，均为可选项"><a href="#kwargs-控制访问的参数，均为可选项" class="headerlink" title="kwargs**: 控制访问的参数，均为可选项"></a>kwargs**: 控制访问的参数，均为可选项</h3><ol>
<li><p>params : 字典或字节序列，作为参数增加到url中</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/12.png" class>
</li>
<li><p>data : 字典、字节序列或文件对象，作为Request的内容</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/13.png" class>
</li>
<li><p>json : JSON格式的数据，作为Request的内容</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/14.png" class>
</li>
<li><p>headers : 字典，HTTP定制头</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/15.png" class>
</li>
<li><p>files : 字典类型，传输文件</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/16.png" class>
</li>
<li><p>timeout : 设定超时时间，秒为单位</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/17.png" class>
</li>
<li><p>proxies : 字典类型，设定访问代理服务器，可以增加登录认证</p>
<img src="/2020/06/30/Python%E7%88%AC%E8%99%AB-01/18.png" class>
</li>
<li><p>cookies : 字典或CookieJar，Request中的cookie</p>
</li>
<li><p>auth : 元组，支持HTTP认证功能</p>
</li>
<li><p>allow_redirects：True/False，默认为True，重定向开关</p>
</li>
<li><p>stream：True/False，默认为True，获取内容立即下载开关</p>
</li>
<li><p>verify：True/False，默认为True，认证SSL证书开关</p>
</li>
<li><p>cert：本地SSL证书路径</p>
</li>
</ol>
<h2 id="2-requests-get-url-params-None-kwargs"><a href="#2-requests-get-url-params-None-kwargs" class="headerlink" title="2. requests.get(url, params=None, \kwargs)"></a>2. requests.get(<strong>url</strong>, <strong>params=None</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟获取页面的url链接</p>
<p><strong>∙</strong> <strong>params</strong> : url中的额外参数，字典或字节流格式，可选</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数</p>
<h2 id="3-requests-head-url-kwargs"><a href="#3-requests-head-url-kwargs" class="headerlink" title="3. requests.head(url, \kwargs)"></a>3. requests.head(<strong>url</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟获取页面的url链接</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数</p>
<h2 id="4-requests-post-url-data-None-json-None-kwargs"><a href="#4-requests-post-url-data-None-json-None-kwargs" class="headerlink" title="4. requests.post(url, data=None, json=None, \kwargs)"></a>4. requests.post(<strong>url</strong>, <strong>data=None</strong>, <strong>json=None</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟更新页面的url链接</p>
<p><strong>∙</strong> <strong>data</strong> : 字典、字节序列或文件，Request的内容</p>
<p><strong>∙</strong> <strong>json</strong> : JSON格式的数据，Request的内容</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数</p>
<h2 id="5-requests-put-url-data-None-kwargs"><a href="#5-requests-put-url-data-None-kwargs" class="headerlink" title="5. requests.put(url, data=None, \kwargs)"></a>5. requests.put(<strong>url</strong>, <strong>data=None</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟更新页面的url链接</p>
<p><strong>∙</strong> <strong>data</strong> : 字典、字节序列或文件，Request的内容</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数</p>
<h2 id="6-requests-patch-url-data-None-kwargs"><a href="#6-requests-patch-url-data-None-kwargs" class="headerlink" title="6. requests.patch(url, data=None, \kwargs)"></a>6. requests.patch(<strong>url</strong>, <strong>data=None</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟更新页面的url链接</p>
<p><strong>∙</strong> <strong>data</strong> : 字典、字节序列或文件，Request的内容</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数</p>
<h2 id="7-requests-delete-url-kwargs"><a href="#7-requests-delete-url-kwargs" class="headerlink" title="7. requests.delete(url, \kwargs)"></a>7. requests.delete(<strong>url</strong>, <strong><em>\</em>kwargs</strong>)</h2><p><strong>∙</strong> <strong>url</strong> : 拟删除页面的url链接</p>
<p><strong>∙</strong> **kwargs: 12个控制访问的参数 </p>
<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><h2 id="HTTP请求头常见参数"><a href="#HTTP请求头常见参数" class="headerlink" title="HTTP请求头常见参数"></a>HTTP请求头常见参数</h2><ol>
<li><code>User-Agent</code>:浏览器名称，如果我们使用爬虫发送请求，那么我们的<code>User-Agent</code>就是<code>Python</code>,很容易被反爬虫检测到；</li>
<li><code>Referer</code>:表明当前请求是从哪个URL过来的，这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。</li>
<li><code>Cookie</code>:<code>http</code>协议视无状态的，也就是从一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用<code>cookie</code>来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送<code>cookie</code>信息了。</li>
</ol>
<h2 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h2><ol>
<li><code>200</code>:请求正常，服务器正常返回数据；</li>
<li><code>301</code>:永久重定向，比如在访问<code>www.jingdong.com</code>的时候回重定向到<code>www.jd.com</code>；</li>
<li><code>302</code>:临时重定向，比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录界面；</li>
<li><code>400</code>:请求的<code>url</code>在服务器上找不到，换句话说就是请求<code>url</code>错误；</li>
<li><code>403</code>:服务器拒绝访问，权限不够；</li>
<li><code>500</code>:服务器内部错误，可能是服务器出现<code>bug</code>了。</li>
</ol>
<h2 id="Cookies和Session"><a href="#Cookies和Session" class="headerlink" title="Cookies和Session"></a>Cookies和Session</h2><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://www.baidu.com'</span>) <span class="comment"># 获取百度的cookies</span></span><br><span class="line">print(r.cookies)    <span class="comment"># &lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span></span><br><span class="line"></span><br><span class="line">print(r.cookies.get_dict()) <span class="comment"># get_dict()方法得到cookies的字典信息： &#123;'BDORZ': '27315'&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.renren.com/PLogin.do'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'email'</span>:<span class="string">'13287857692'</span>,</span><br><span class="line">    <span class="string">'password'</span>:<span class="string">'密码'</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line">session.post(url, data = data, headers = headers)</span><br><span class="line"></span><br><span class="line">response = session.get(<span class="string">'http://www.renren.com/974726184/profile'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'renrne.html'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.text)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_10(模块和包)</title>
    <url>/2020/06/28/Python-10/</url>
    <content><![CDATA[<p>基于上次的<strong>异常</strong>基本知识，本篇总结python中<strong>模块</strong>和<strong>包</strong>知识点。</p>
<a id="more"></a>

<hr>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>python模块（Module），是一个python文件，以  .py 结尾，包含了python对象定义和python语句。模块能定义函数、类和变量，里面也可以有其他可执行代码。</p>
<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><h3 id="导入模块方式"><a href="#导入模块方式" class="headerlink" title="导入模块方式"></a>导入模块方式</h3><ul>
<li>import 模块名</li>
<li>from 模块名 import 功能名</li>
<li>from 模块名 import *</li>
<li>import 模块名 as 别名</li>
<li>from 模块名 import 功能名 as 别名</li>
</ul>
<h3 id="导入方式详解"><a href="#导入方式详解" class="headerlink" title="导入方式详解"></a>导入方式详解</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>,模块名<span class="number">2.</span>.. <span class="comment"># 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用功能</span></span><br><span class="line">模块名.功能名()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="from-…-import-…"><a href="#from-…-import-…" class="headerlink" title="from … import …"></a>from … import …</h4><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名<span class="number">1</span>,功能名<span class="number">2.</span>..</span><br></pre></td></tr></table></figure>
</li>
<li><p>体验</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">print(sqrt(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="from-模块名-import"><a href="#from-模块名-import" class="headerlink" title="from 模块名 import *"></a>from 模块名 import *</h4><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
</li>
<li><p>体验</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line">print(sqrt(<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="as-定义别名"><a href="#as-定义别名" class="headerlink" title="as 定义别名"></a>as 定义别名</h4><p>如果定义了别名，只能使用别名，不可再使用模块名。</p>
<ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块定义别名</span></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能定义别名</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure>
</li>
<li><p>体验</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块别名</span></span><br><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> tt</span><br><span class="line"></span><br><span class="line">tt.sleep(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能别名</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl</span><br><span class="line">sl(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="制作模块"><a href="#制作模块" class="headerlink" title="制作模块"></a>制作模块</h2><p>在python中，每个python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块必须符合标识符命名规则。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>新建一个python文件，命名<code>my_module1.py</code>，并定义<code>testA</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a + b)</span><br></pre></td></tr></table></figure>

<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，会自行在py文件中添加一些测试信息。例如，在<code>my_module1.py</code>文件中添加测试代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a + b)</span><br><span class="line">    </span><br><span class="line">testA(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>testA</code>函数的调用，即结果2。</p>
<p>为此，解决方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a + b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 只有在当前文件调用该函数，其他导入的文件内不符合该条件，则不执行下述测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    testA(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 <code>__name__</code>：</p>
<ul>
<li><p>若在本文件内运行该函数，则为<code>__main__</code></p>
</li>
<li><p>若在其他文件，例如导入该文件模块，则为my_module（文件名）</p>
</li>
</ul>
</blockquote>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包将有联系的模块组织在一起，即放到同一个文件夹下，并且在文件夹内创建一个名字为<code>__init__.py</code>文件，那么这个文件夹就称之为<strong>包</strong>。</p>
<h2 id="制作包"><a href="#制作包" class="headerlink" title="制作包"></a>制作包</h2><p>右键 — [new] — [Python  Package] — 输入包名 — [OK] — 新建功能模块（有联系的模块）。</p>
<p>注意：新建包后，包内自动创建<code>__init__.py</code>文件，控制着包的导入行为。</p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><ol>
<li><p>新建包<code>myPackage</code></p>
</li>
<li><p>新建包内模块：<code>my_module1</code>和 <code>my_module2</code></p>
</li>
<li><p>模块内代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module1</span></span><br><span class="line">print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'my_module1'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module2</span></span><br><span class="line">print(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'my_module2'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br><span class="line"></span><br><span class="line">包名.模块名.目标</span><br></pre></td></tr></table></figure>

<h4 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myPackage.my_module1</span><br><span class="line"></span><br><span class="line">myPackage.my_module1.info_print1()</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>注意：必须在<code>__init__.py</code>文件中添加<code>__all__ = []</code>，控制允许导入的模块列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> *</span><br><span class="line">模块名.目标</span><br></pre></td></tr></table></figure>

<h4 id="体验-2"><a href="#体验-2" class="headerlink" title="体验"></a>体验</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myPackage <span class="keyword">import</span> *</span><br><span class="line">my_module1.info_print1()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_9(异常)</title>
    <url>/2020/06/27/Python-9/</url>
    <content><![CDATA[<p>基于上次的<strong>面向对象</strong>基本知识，本篇总结python中重要<strong>异常处理</strong>知识点。</p>
<a id="more"></a>

<hr>
<h1 id="异常的写法"><a href="#异常的写法" class="headerlink" title="异常的写法"></a>异常的写法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure>

<h2 id="捕获指定异常"><a href="#捕获指定异常" class="headerlink" title="捕获指定异常"></a>捕获指定异常</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span> 异常类型:</span><br><span class="line">    如果捕获到该异常类型执行的代码</span><br></pre></td></tr></table></figure>

<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num) <span class="comment"># num不存在</span></span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    print(<span class="string">'有错误'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获该异常。</li>
<li>一般try下方只放一行尝试执行的代码。</li>
</ol>
</blockquote>
<h3 id="捕获多个指定异常"><a href="#捕获多个指定异常" class="headerlink" title="捕获多个指定异常"></a>捕获多个指定异常</h3><p>当捕获多个异常时，可以把要捕获的异常类型的名字，放在except后，并使用元组的方式进行书写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError): <span class="comment"># 当不确定异常的类型时，可以选择多个。</span></span><br><span class="line">    print(<span class="string">'有错误'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常描述信息"><a href="#捕获异常描述信息" class="headerlink" title="捕获异常描述信息"></a>捕获异常描述信息</h3><p>当捕获多个异常时，可以把要捕获的异常类型的名字，放在except后，并使用元组的方式进行书写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> result:</span><br><span class="line">    print(result) <span class="comment"># 结果：division by zero</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h3><p>Exception是所有程序异常类的父类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>

<h2 id="异常的else"><a href="#异常的else" class="headerlink" title="异常的else"></a>异常的else</h2><p>else表示的是如果没有异常要执行的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="异常的finally"><a href="#异常的finally" class="headerlink" title="异常的finally"></a>异常的finally</h2><p>finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">   f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'成功打开'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h1 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'test.txt'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = f.readline()</span><br><span class="line">            <span class="keyword">if</span> len(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">           	time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(content)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 如果在读取文件的过程中，产生了异常，那么就会捕获到</span></span><br><span class="line">        <span class="comment"># 比如按下Ctrl + C</span></span><br><span class="line">        print(<span class="string">'意外终止了读取数据'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        print(<span class="string">'关闭文件'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'打开文件失败'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在python中，抛出自定义异常的语法为<code>raise 异常类对象</code>。</p>
<p>需求：密码长度不足，则报异常（输入密码少于3位，则报错，抛出自定义异常，并捕获该异常）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义异常类，继承Exception</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortInputError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, min_len)</span>:</span></span><br><span class="line">        self.length = length</span><br><span class="line">        self.min_len = min_len</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 设置抛出异常的描述信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'你输入的长度为<span class="subst">&#123;self.length&#125;</span>，不能少于<span class="subst">&#123;self.min_len&#125;</span>个字符'</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        con = input(<span class="string">'请输入密码：'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(con) &lt; <span class="number">3</span>: <span class="comment"># 即输入密码不符合要求</span></span><br><span class="line">            <span class="keyword">raise</span> ShortInputError(len(con), <span class="number">3</span>) <span class="comment"># 抛出异常 raise</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	print(<span class="string">'密码输入完成'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="with-…-as"><a href="#with-…-as" class="headerlink" title="with … as"></a>with … as</h1><p>with as 语句的<strong>结构</strong>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> variable]:</span><br><span class="line">    <span class="keyword">with</span>-block</span><br></pre></td></tr></table></figure>

<p>with…as语句<strong>执行顺序</strong>：<br>–&gt;首先执行expression里面的<code>__enter__</code>函数，它的返回值会赋给<code>as</code>后面的<code>variable</code>，想让它返回什么就返回什么，只要你知道怎么处理就可以了，如果不写<code>as variable</code>，返回值会被忽略。</p>
<p>–&gt;然后，开始执行<code>with-block</code>中的语句，不论成功失败(比如发生异常、错误，设置sys.exit() )，在<code>with-block</code>执行完成后，会执行<code>expression</code>中的<code>__exit__</code>函数。</p>
<p>这个和<code>try finally</code>函数有什么关系呢？</p>
<p>其实，这样的过程<strong>等价</strong>于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    执行 __enter__的内容  </span><br><span class="line">    执行 with_block.  </span><br><span class="line"><span class="keyword">finally</span>:  </span><br><span class="line">    执行 __exit__内容</span><br></pre></td></tr></table></figure>

<h2 id="简单形式"><a href="#简单形式" class="headerlink" title="简单形式"></a>简单形式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try：</span><br><span class="line">  f &#x3D; open(&#39;a.txt&#39;, &#39;w&#39;)</span><br><span class="line">  f.write(&#39;Hello!&#39;)</span><br><span class="line">finally:</span><br><span class="line">  f.close()</span><br></pre></td></tr></table></figure>

<p><strong>等价</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;a.txt&#39;, &#39;w&#39;) as f:</span><br><span class="line">  f.write(&#39;Hello!&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_8(面向对象)</title>
    <url>/2020/06/25/Python-8/</url>
    <content><![CDATA[<p>基于上次的<strong>文件</strong>基本知识，本篇总结python中重要<strong>面向对象</strong>知识点。</p>
<a id="more"></a>

<hr>
<h1 id="类与对象的创建"><a href="#类与对象的创建" class="headerlink" title="类与对象的创建"></a>类与对象的创建</h1><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>在不同的python解释器下，类分为两种 <strong>经典类</strong> 和 <strong>新式类</strong></p>
<ul>
<li><p>不由任意内置类型派生出的类，称为经典类（python2.0）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">()</span>:</span></span><br><span class="line">    代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>新式类（python3.0）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(object)</span>:</span> <span class="comment"># object 为 python中的顶级类</span></span><br><span class="line">    代码</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名 = 类名()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'洗衣服'</span>)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">haier = Washer() <span class="comment"># 对象名 = 类名()</span></span><br><span class="line">print(haier) <span class="comment"># 打印对象</span></span><br><span class="line">haier.wash() <span class="comment"># 使用方法</span></span><br></pre></td></tr></table></figure>

<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>self指的是调用函数的对象。</p>
<p>即上面代码中函数内打印的self和函数外打印的haier相同。</p>
<h2 id="添加和获取对象属性"><a href="#添加和获取对象属性" class="headerlink" title="添加和获取对象属性"></a>添加和获取对象属性</h2><p>属性即是特征，对象属性既可以在类外面添加和获取，也能在类里面添加和获取。</p>
<h3 id="类外面添加对象属性"><a href="#类外面添加对象属性" class="headerlink" title="类外面添加对象属性"></a>类外面添加对象属性</h3><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名 = 值</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 属性名为自定义的</span></span><br><span class="line">haier.width = <span class="number">500</span></span><br><span class="line">haier.height = <span class="number">800</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="类外面获取对象属性"><a href="#类外面获取对象属性" class="headerlink" title="类外面获取对象属性"></a>类外面获取对象属性</h3><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="类里面获取对象属性"><a href="#类里面获取对象属性" class="headerlink" title="类里面获取对象属性"></a>类里面获取对象属性</h3><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.属性名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h2><p>在python中，<code>__xx__()</code>函数叫做魔法方法，指的是与有特殊功能的函数。</p>
<h3 id="init"><a href="#init" class="headerlink" title="__init__()"></a><code>__init__()</code></h3><h4 id="体验-init"><a href="#体验-init" class="headerlink" title="体验__init__()"></a>体验<code>__init__()</code></h4><p><code>__init__()</code>方法作用：初始化对象，设置与生俱来的初始化属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义__init__()，添加实例属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#添加实例属性</span></span><br><span class="line">        self.width = <span class="number">500</span></span><br><span class="line">        self.height = <span class="number">800</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 类里面调用实例属性，注意：不用在该方法内调用`__init__()`方法</span></span><br><span class="line">        print(<span class="string">f'洗衣机的宽度为<span class="subst">&#123;self.width&#125;</span>，高度为<span class="subst">&#123;self.height&#125;</span>'</span>)</span><br><span class="line">        </span><br><span class="line">haier = Washer()</span><br><span class="line">haier.print_info() <span class="comment"># 不用传递参数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li><code>__init__()</code>方法，在创建一个对象时默认被调用。</li>
<li><code>__init__(self)</code>中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。</li>
</ul>
</blockquote>
<h4 id="带参数的-init"><a href="#带参数的-init" class="headerlink" title="带参数的__init__()"></a>带参数的<code>__init__()</code></h4><p>思考：一个类可以创建多个对象，如何对不同的对象设置不同的初始化属性呢？</p>
<p>可以使用传递参数的init方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, width, height)</span>:</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'洗衣机的宽度为<span class="subst">&#123;self.width&#125;</span>，高度为<span class="subst">&#123;self.height&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">haier1.print_info()</span><br><span class="line"></span><br><span class="line">haier2 = Washer(<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">haier2.print_info()</span><br></pre></td></tr></table></figure>

<h3 id="str"><a href="#str" class="headerlink" title="__str__()"></a><code>__str__()</code></h3><p>当我们使用print输出对象的时候，默认打印对象的内存地址，如果类定义了<code>__str__()</code>方法，那么就会打印 从这个方法中return的数据。</p>
<blockquote>
<p>该方法一般用于返回一些解释说明的语句</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, width, height)</span>:</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'这是海尔洗衣机的说明书'</span> </span><br><span class="line"></span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">print(haier1) <span class="comment"># 这是海尔洗衣机的说明书</span></span><br></pre></td></tr></table></figure>

<h3 id="del"><a href="#del" class="headerlink" title="__del__()"></a><code>__del__()</code></h3><p>当删除对象时，python解释器就会默认调用该方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, width, height)</span>:</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self&#125;</span>对象已经被销毁'</span>)</span><br><span class="line">  </span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> haier1</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong><br>我们都知道Python一切皆对象，那么Python究竟是怎么管理对象的呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 返回类内部所有属性和方法对应的字典</span></span><br><span class="line">print(A.__dict__)</span><br><span class="line"><span class="comment"># 返回实例属性和值组成的字典</span></span><br><span class="line">print(a.__dict__)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'__init__'</span>: &lt;function A.__init__ at <span class="number">0x01719610</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'A'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由此可见， 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在<strong>类<strong>dict</strong></strong>里的。</p>
</li>
<li><p><strong>对象的<strong>dict</strong></strong>中存储了一些self.xxx的一些东西</p>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_print</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span> 	<span class="comment"># 继承写法</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">result = B()</span><br><span class="line">result.info_print() <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>继承分为单继承和多继承两种。</p>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>只有一个父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>有多个父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。</p>
</blockquote>
<p><strong>拓展：</strong>查看一个类的层级继承关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(类.__mro__)</span><br></pre></td></tr></table></figure>

<h2 id="子类调用父类同名方法和属性"><a href="#子类调用父类同名方法和属性" class="headerlink" title="子类调用父类同名方法和属性"></a>子类调用父类同名方法和属性</h2><p>通过师傅徒弟案例和学校的多继承完成演示（相应含义已在注释部分说明）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 师傅类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.kongfu =  <span class="string">'经典配方'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cake</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'运用的技术：<span class="subst">&#123;self.kongfu&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学校类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.kongfu = <span class="string">'新式配方'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cake</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'运用的技术：<span class="subst">&#123;self.kongfu&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 徒弟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span><span class="params">(School, Master)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.kongfu = <span class="string">'独创配方'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cake</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 加入自己的init方法原因：如果先调用了父类的属性和方法，父类属性回覆盖子类属性</span></span><br><span class="line">        self.__init__()</span><br><span class="line">        print(<span class="string">f'运用的技术：<span class="subst">&#123;self.kongfu&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子类调用父类的同名方法和属性：即把父类的同名方法和属性再次封装</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_master_cake</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 父类名.函数</span></span><br><span class="line">        Master.__init__(self) <span class="comment"># 调用初始化的原因：这里想要调用父类的同名方法和属性，属性在父类的init方法中被初始化，所以此处再次调用</span></span><br><span class="line">        Master.make_cake(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_school_cake</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 父类名.函数</span></span><br><span class="line">        School.__init__(self)</span><br><span class="line">        School.make_cake(self)</span><br><span class="line"></span><br><span class="line">daqiu = Prentice()</span><br><span class="line">daqiu.make_master_cake()</span><br><span class="line">daqiu.make_school_cake()</span><br></pre></td></tr></table></figure>

<h2 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">super().__init__()</span><br><span class="line">super().make_cake()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用super()可以自动查找父类。调用顺序遵循<code>__mro__</code>的类属性顺序。比较适合单继承使用。</p>
</blockquote>
<h1 id="私有权限"><a href="#私有权限" class="headerlink" title="私有权限"></a>私有权限</h1><h2 id="定义私有属性和方法"><a href="#定义私有属性和方法" class="headerlink" title="定义私有属性和方法"></a>定义私有属性和方法</h2><p>设置私有权限的方法：在属性名 和 方法名 前面 加上两个下划线__。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.kongfu = <span class="string">'独创配方'</span></span><br><span class="line">    <span class="comment"># 定义私有属性</span></span><br><span class="line">    self.__money = <span class="number">200</span></span><br><span class="line"><span class="comment"># 定义私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__info_print</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self.__money)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：私有属性和私有方法只能在类里面访问和修改</p>
</blockquote>
<h2 id="获取和修改私有属性"><a href="#获取和修改私有属性" class="headerlink" title="获取和修改私有属性"></a>获取和修改私有属性</h2><p>自定义get和set方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_money</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__money</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_money</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.__money = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h1 id="保护权限"><a href="#保护权限" class="headerlink" title="保护权限"></a>保护权限</h1><p>以单下划线开头。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="面向对象的三个特性"><a href="#面向对象的三个特性" class="headerlink" title="面向对象的三个特性"></a>面向对象的三个特性</h2><ul>
<li>封装<ul>
<li>将属性和方法书写到类里的操作</li>
<li>封装可以为属性和方法添加私有权限</li>
</ul>
</li>
<li>继承<ul>
<li>默认继承父类的所有属性和方法</li>
<li>子类可以重写父类的属性和方法</li>
</ul>
</li>
<li>多态<ul>
<li>传入不同的对象，产生不同的结果</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>定义：多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArmyDog</span><span class="params">(Dog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'追击敌人'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrugDog</span><span class="params">(Dog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'追查毒品'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work_with_dog</span><span class="params">(self, dog)</span>:</span></span><br><span class="line">        dog.work()</span><br><span class="line"></span><br><span class="line">ad = ArmyDog()</span><br><span class="line">dd = DrugDog()</span><br><span class="line">person1 = Person()</span><br><span class="line"><span class="comment"># 多态调用</span></span><br><span class="line">person1.work_with_dog(ad) <span class="comment"># 追击敌人</span></span><br><span class="line">person1.work_with_dog(dd) <span class="comment"># 追查毒品</span></span><br></pre></td></tr></table></figure>

<h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><h3 id="设置和访问类属性"><a href="#设置和访问类属性" class="headerlink" title="设置和访问类属性"></a>设置和访问类属性</h3><ul>
<li>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象</strong> 所共有。</li>
<li>类属性可以使用 <strong>类对象</strong> 或 <strong>实例对象</strong> 访问。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    tooth = <span class="number">10</span> <span class="comment"># 设置类属性</span></span><br><span class="line"></span><br><span class="line">dog1 = Dog()</span><br><span class="line">dog2 = Dog()</span><br><span class="line"></span><br><span class="line">print(Dog.tooth)</span><br><span class="line">print(dog1.tooth)</span><br><span class="line">print(dog2.tooth)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类属性的优点：</p>
<ul>
<li>记录的某项数据始终保持一致，则定义类属性。</li>
<li>实例属性要求 <strong>每个对象 *<em>为其 单独开辟一份内存空间 来记录数据，而 *</em>类属性</strong> 为全人类所共有，仅占用一份内存，更加节省内存空间。</li>
</ul>
</blockquote>
<h3 id="修改类属性"><a href="#修改类属性" class="headerlink" title="修改类属性"></a>修改类属性</h3><p>类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改实例属性</span></span><br><span class="line">Dog.tooth = <span class="number">12</span></span><br><span class="line"><span class="comment"># 修改实例属性</span></span><br><span class="line">dog1.tooth = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li><p>特点</p>
<p>需要用<strong>装饰器</strong><code>@classmethod</code>；来标识其为类方法，对于类方法，第一个参数必须为类对象，一半以<code>cls</code>作为第一个参数。</p>
</li>
<li><p>使用场景</p>
<p>当方法中需要使用类对象（如访问私有类属性等）时，定义类方法</p>
<p>类方法一般和类属性配合使用</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    __touth = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_tooth</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__tooth</span><br><span class="line">    </span><br><span class="line">dog1 = Dog()</span><br><span class="line">result = dog1.get_tooth()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li><p>特点</p>
<p>需要通过装饰器 <code>@staticmethod</code>来进行修饰，静态方法既不需要传递类对象，也不需要传递实例对象（形参没有self/cls）。</p>
<p>静态方法也能通过 <strong>实例对象</strong> 和 <strong>类对象</strong> 去访问。</p>
</li>
<li><p>使用场景</p>
<p>当方法中既不需要使用实例对象，也不需要使用类对象时，定义静态方法。</p>
<p>取消不需要的参数传递，有利于 减少不必要的内存占用和性能消耗。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'该类用于创建Dog'</span>)</span><br><span class="line">    </span><br><span class="line">dog1 = Dog()</span><br><span class="line"><span class="comment"># 静态方法既可以使用对象访问，又可以使用类访问</span></span><br><span class="line">dog1.info_print()</span><br><span class="line">Dog.info_print()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_7(文件)</title>
    <url>/2020/06/24/Python-7/</url>
    <content><![CDATA[<p>基于上次的<strong>函数</strong>基本知识，本篇总结python中<strong>文件</strong>的相关操作。</p>
<a id="more"></a>

<hr>
<h1 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h1><ol>
<li>打开文件</li>
<li>读写等操作</li>
<li>关闭文件</li>
</ol>
<h2 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h2><p>在python中，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(name, mode, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>name：是要打开的目标文件名的字符串（可以包含具体路径）</li>
<li>mode：设置打开文件的模式（访问模式）：只读、只写、追加等</li>
<li>encoding：指定编码</li>
</ul>
<h2 id="打开文件模式"><a href="#打开文件模式" class="headerlink" title="打开文件模式"></a>打开文件模式</h2><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td align="left">rb</td>
<td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">rb+</td>
<td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb</td>
<td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb+</td>
<td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td align="left">ab+</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li>只要带 b 的，都是 以二进制格式打开文件</li>
<li>带 + 的，打开文件用于读写</li>
<li>a ，文件指针在结尾</li>
</ul>
</blockquote>
<img src="/2020/06/24/Python-7/1.png" class>

<blockquote>
<p> 注：</p>
<ul>
<li>Truncate：截断</li>
<li>Initial Position：初始位置</li>
</ul>
</blockquote>
<p><strong>使用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="comment"># f代表文件对象</span></span><br></pre></td></tr></table></figure>

<h2 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.write(<span class="string">'内容'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul>
<li><p><strong>read</strong>()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.read(num)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>num表示要从文件中读取的数据的长度（单位是字节），可省略</p>
</blockquote>
</li>
<li><p><strong>readlines</strong>()</p>
<p>readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每行的数据为一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'test.txt'</span>)</span><br><span class="line">content = f.readlines() <span class="comment"># ['aa\n','bb\n','cc']</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>readline</strong>()</p>
<p>一次读取一行内容</p>
</li>
</ul>
<h3 id="移动文件指针-seek"><a href="#移动文件指针-seek" class="headerlink" title="移动文件指针__seek()"></a>移动文件指针__seek()</h3><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.seek(偏移量, 起始位置)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>起始位置：</p>
<ul>
<li>0：文件开头</li>
<li>1：当前位置</li>
<li>2：文件结尾</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'test,txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line">f.seek(<span class="number">2</span>, <span class="number">0</span>) <span class="comment"># 从开头位置，偏移两个字符，即第三个字符开始读取</span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment">#  &lt;=&gt; seek(0, 0),即从文件的最开始读取</span></span><br></pre></td></tr></table></figure>

<h1 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h1><p>需求：用户输入当前目录下任意文件名，程序完成对该文件的备份功能（test[备份].txt）</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>接收用户输入的文件名</li>
<li>规划备份文件名</li>
<li>备份文件写入数据</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol>
<li><p>接受用户输入目标文件名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_name = input(<span class="string">'请输入您要备份的文件名：'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>规划备份文件名</p>
<ul>
<li>提取目标文件后缀（字符串最后的一个点才是后缀的点）</li>
<li>组织备份的文件名，xx[备份]后缀</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以sound.txt.mp3文件名为例</span></span><br><span class="line"></span><br><span class="line">index = old_name.rfind(<span class="string">'.'</span>)	<span class="comment"># 提取文件后缀名中“.”的下标   9</span></span><br><span class="line"><span class="comment"># old_name[:index]  源文件名（无后缀）   sound.txt</span></span><br><span class="line"><span class="comment"># old_name[index:]  后缀名		.mp3</span></span><br><span class="line"></span><br><span class="line">new_name = old_name[:index] + <span class="string">'[备份]'</span> + old_name[index:]</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份文件写入数据</p>
<ul>
<li>打开源文件 和 备份文件</li>
<li>将源文件数据写入备份文件</li>
<li>关闭文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_f = open(old_name, <span class="string">'rb'</span>) <span class="comment"># 以二进制的方式读写</span></span><br><span class="line">new_f = open(new_name, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    con = old_f.read(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> len(con) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">#表示读完，退出循环</span></span><br><span class="line">    new_f.write(con)</span><br><span class="line">    </span><br><span class="line">old_f.close()</span><br><span class="line">new_f.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="文件和文件夹的操作"><a href="#文件和文件夹的操作" class="headerlink" title="文件和文件夹的操作"></a>文件和文件夹的操作</h1><p>在python中文件和文件夹的操作要借助os模板里面的相关功能，具体步骤如下：</p>
<ol>
<li><p>导入os模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用os模块相关功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.函数名()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(目标文件名, 新文件名)</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(目标文件名)</span><br></pre></td></tr></table></figure>

<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(文件夹名字)</span><br></pre></td></tr></table></figure>

<h2 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir(文件夹名字)</span><br></pre></td></tr></table></figure>

<h2 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>

<h2 id="改变默认目录"><a href="#改变默认目录" class="headerlink" title="改变默认目录"></a>改变默认目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(目录)</span><br></pre></td></tr></table></figure>

<p><strong>需求</strong>：在A文件夹里创建B文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(<span class="string">'A'</span>)</span><br><span class="line">os.mkdir(<span class="string">'B'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="获取目录列表"><a href="#获取目录列表" class="headerlink" title="获取目录列表"></a>获取目录列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.listdir(目录) <span class="comment">#获取该目录下的所有文件，返回一个列表</span></span><br></pre></td></tr></table></figure>

<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(os.listdir(<span class="string">'A'</span>)) <span class="comment"># B</span></span><br></pre></td></tr></table></figure>

<h1 id="读取JSON文件"><a href="#读取JSON文件" class="headerlink" title="读取JSON文件"></a>读取JSON文件</h1><p>我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mydict = &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'张三'</span>,</span><br><span class="line">        <span class="string">'age'</span>: <span class="number">38</span>,</span><br><span class="line">        <span class="string">'qq'</span>: <span class="number">957658</span>,</span><br><span class="line">        <span class="string">'friends'</span>: [<span class="string">'王大锤'</span>, <span class="string">'白元芳'</span>],</span><br><span class="line">        <span class="string">'cars'</span>: [</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'BYD'</span>, <span class="string">'max_speed'</span>: <span class="number">180</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'Audi'</span>, <span class="string">'max_speed'</span>: <span class="number">280</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'Benz'</span>, <span class="string">'max_speed'</span>: <span class="number">320</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fs:</span><br><span class="line">            json.dump(mydict, fs)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    print(<span class="string">'保存数据完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>json模块主要有四个比较重要的函数，分别是：</p>
<ul>
<li><code>dump</code> - 将Python对象按照JSON格式序列化到文件中</li>
<li><code>dumps</code> - 将Python对象处理成JSON格式的字符串</li>
<li><code>load</code> - 将文件中的JSON数据反序列化成对象</li>
<li><code>loads</code> - 将字符串的内容反序列化成Python对象</li>
</ul>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书<a href="https://zh.wikipedia.org/" target="_blank" rel="noopener">维基百科</a>上对这两个概念是这样解释的：</p>
<ul>
<li>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。</li>
<li>与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_6(函数lambda高阶用法)</title>
    <url>/2020/06/23/Python-6/</url>
    <content><![CDATA[<p>基于上次的<strong>公共操作</strong>和简单的<strong>推导式</strong>运算，本次学习<strong>函数</strong>的相关知识。</p>
<a id="more"></a>

<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基本形式"><a href="#函数基本形式" class="headerlink" title="函数基本形式"></a>函数基本形式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    说明文档内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    代码</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment"># 调用时，help(f)查看说明文档</span></span><br></pre></td></tr></table></figure>

<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>如何在函数体内修改全局变量？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#global 关键字声明a是全局变量</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li><p>返回多个值，<code>return a,b</code>，默认是返回元组类型</p>
</li>
<li><p>return后面可以连接列表、元组或字典，以返回多个值</p>
</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>调用有参数的函数时，参数可有多种方式写入。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span><span class="params">(name, age, gender)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="string">'男'</span>)</span><br><span class="line">user_info(<span class="string">'小明'</span>, gender=<span class="string">'男'</span>, age=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a><strong>缺省参数</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span><span class="params">(name, age, gender=<span class="string">'男'</span>)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"><span class="comment">#带有缺省值的参数可以不输入</span></span><br><span class="line">user_info(<span class="string">'Tom'</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><ul>
<li>包裹位置传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">    </span><br><span class="line">user_info(<span class="string">'Tom'</span>, <span class="number">18</span>) <span class="comment"># ('Tom',18)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组（tuple）。</p>
</blockquote>
<ul>
<li>包裹关键字传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">    </span><br><span class="line">user_info(name=<span class="string">'Tom'</span>,age=<span class="number">18</span>) <span class="comment"># &#123;'name': 'Tom','age': 18&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程</p>
</blockquote>
<h2 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h2><ul>
<li><p>元组拆包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"></span><br><span class="line">num1, num2 = return_num()</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典拆包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'name'</span>: <span class="string">'Tom'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">a, b = dict1</span><br><span class="line"></span><br><span class="line"><span class="comment">#对字典进行拆包，取出来的是字典的key</span></span><br><span class="line">print(a) <span class="comment"># name</span></span><br><span class="line">print(b) <span class="comment"># age</span></span><br><span class="line"></span><br><span class="line">print(dict1[a]) <span class="comment">#Tom</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="交换变量值"><a href="#交换变量值" class="headerlink" title="交换变量值"></a>交换变量值</h2><ul>
<li><p>定义第三变量传值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span> <span class="comment"># 把1和2分别赋值给a和b</span></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在python中，值是靠引用传递的。</p>
<p>可以用方法<code>id(变量)</code> ，得到变量的地址</p>
<p>int数据类型不可变（数值改变地址改变），列表数据类型可变（数值改变地址不变）</p>
<h3 id="可变和不可变类型"><a href="#可变和不可变类型" class="headerlink" title="可变和不可变类型"></a>可变和不可变类型</h3><p>所谓可变不可变：即该数据能否直接修改，如果直接修改那么可变（不改变内存地址），否则不可变。</p>
<ul>
<li>可变类型<ul>
<li>列表</li>
<li>字典</li>
<li>集合</li>
</ul>
</li>
<li>不可变类型<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符串</li>
<li>元组</li>
</ul>
</li>
</ul>
<h1 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h1><p>如果一个函数有一个返回值，并且只有一句代码，可以使用lambda简化。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数列表 : 表达式</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li><p>lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用</p>
</li>
<li><p>lambda表达式能接受任何数量的参数但只能返回一个表达式的值</p>
</li>
</ul>
</blockquote>
<h2 id="lambda的参数形式"><a href="#lambda的参数形式" class="headerlink" title="lambda的参数形式"></a>lambda的参数形式</h2><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lambda表达式</span></span><br><span class="line">fn2 = <span class="keyword">lambda</span>: <span class="number">100</span></span><br><span class="line">print(fn2) <span class="comment"># lambda内存地址</span></span><br><span class="line">print(fn2()) <span class="comment"># 对应的函数的返回值</span></span><br></pre></td></tr></table></figure>

<h3 id="有参"><a href="#有参" class="headerlink" title="有参"></a>有参</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算a + b</span></span><br><span class="line"><span class="comment"># 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#lambda实现</span></span><br><span class="line">fn1 = <span class="keyword">lambda</span> a, b: a + b</span><br><span class="line">print(fn1(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a = <span class="number">0</span>, b = <span class="number">0</span>: a + b</span><br></pre></td></tr></table></figure>

<h3 id="可变参数：-args"><a href="#可变参数：-args" class="headerlink" title="可变参数：*args"></a>可变参数：*args</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> *args: args</span><br><span class="line">print(fn1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里的可变参数传入到lambda中，返回的类型为元组</p>
</blockquote>
<h3 id="可变参数：-kwargs"><a href="#可变参数：-kwargs" class="headerlink" title="可变参数：**kwargs"></a>可变参数：**kwargs</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> **kwargs: kwargs</span><br><span class="line">print(fn1(name = <span class="string">'python'</span>, age = <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回字典类型。</p>
</blockquote>
<p>以上与函数部分的规则完全一致。</p>
<h2 id="lambda的应用"><a href="#lambda的应用" class="headerlink" title="lambda的应用"></a>lambda的应用</h2><h3 id="带判断的lambda"><a href="#带判断的lambda" class="headerlink" title="带判断的lambda"></a>带判断的lambda</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line">print(fn1(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h3 id="列表数据按字典key的值排序"><a href="#列表数据按字典key的值排序" class="headerlink" title="列表数据按字典key的值排序"></a>列表数据按字典key的值排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'Tom'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'Rose'</span>, <span class="string">'age'</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'Jack'</span>, <span class="string">'age'</span>: <span class="number">22</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按name值升序排序</span></span><br><span class="line">students.sort(key = <span class="keyword">lambda</span> x: x[<span class="string">'name'</span>])</span><br><span class="line">print(students)</span><br><span class="line"><span class="comment"># sort函数：如果要排序的列表里数据为字典，则指定key值则可排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按name值降序排序</span></span><br><span class="line">students.sort(key = <span class="keyword">lambda</span> x: x[<span class="string">'name'</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">print(students)</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>把函数作为参数传入，这样的函数为高阶函数。高阶函数是函数式编程的体现，高度抽象的编程范式。</p>
<p><strong>示例</strong>：任意两个数字，求绝对值abs（或四舍五入 round）后进行求和。</p>
<ul>
<li><p>方法1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(a) + abs(b)</span><br><span class="line">result = add_num(<span class="number">-1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_num</span><span class="params">(a, b, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(a) + f(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#灵活性变高</span></span><br><span class="line">result = sum_num(<span class="number">-1</span>, <span class="number">2</span>, abs)</span><br><span class="line">result = sum_num(<span class="number">-1</span>, <span class="number">2</span>, round)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="内置高阶函数"><a href="#内置高阶函数" class="headerlink" title="内置高阶函数"></a>内置高阶函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map(func, lst)</code>，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的迭代器返回。</p>
<p><strong>例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">result = map(func, list1) </span><br><span class="line">print(result) <span class="comment">#为地址</span></span><br><span class="line">print(list(result)) <span class="comment"># list()，将数据转换为列表 [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>reduce(func, lst)</code>，其中func必须有<strong>两个</strong>参数。每次func计算的结果继续和序列的下一个元素做累计计算。</p>
<p><strong>例子：</strong>计算list1序列中各个数字的累加和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools <span class="comment"># 导入reduce所需的functools模块</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line">print(result) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter(func,lst)</code>函数用于过滤序列，过滤掉不符合条件的元素，返回一个filter对象，如果转换为列表类型，用<code>list()</code>来转换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">result = filter(func, list1)</span><br><span class="line"></span><br><span class="line">print(result) <span class="comment"># filter对象</span></span><br><span class="line">print(list(result)) <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_5(公共操作推导式)</title>
    <url>/2020/06/23/Python-5/</url>
    <content><![CDATA[<p>基于上次的<strong>字典</strong>和<strong>集合</strong>，本次总结python中的一些<strong>公共操作</strong>和简单的<strong>推导式</strong>运算。</p>
<a id="more"></a>

<hr>
<h1 id="一、公共操作"><a href="#一、公共操作" class="headerlink" title="一、公共操作"></a>一、公共操作</h1><h2 id="1、运算符"><a href="#1、运算符" class="headerlink" title="1、运算符"></a>1、运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>支持的容器类型</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>*</td>
<td>复制</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>in</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td>not in</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *复制运算符</span></span><br><span class="line">str = <span class="string">'hello'</span></span><br><span class="line">list = [<span class="string">'world'</span>]</span><br><span class="line">t = (<span class="string">'world'</span>,)</span><br><span class="line">print(str * <span class="number">5</span>) <span class="comment"># 'hellohellohellohellohello'</span></span><br><span class="line">print(list * <span class="number">5</span>) <span class="comment"># ['world','world','world','world','world']</span></span><br><span class="line">print(t * <span class="number">5</span>) <span class="comment"># ('world','world','world','world','world')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'h'</span> <span class="keyword">in</span> str) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="2、公共方法"><a href="#2、公共方法" class="headerlink" title="2、公共方法"></a>2、公共方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len()</td>
<td>计算容器中元素个数</td>
</tr>
<tr>
<td>del 或 del()</td>
<td>删除</td>
</tr>
<tr>
<td>max()</td>
<td>返回容器中元素最大值</td>
</tr>
<tr>
<td>min()</td>
<td>返回容器中元素最小值</td>
</tr>
<tr>
<td>range(start,end,step)</td>
<td>生成从start到end的数字（可迭代对象），步长为step，供for循环使用</td>
</tr>
<tr>
<td>enumerate()</td>
<td>函数用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标，一般在for循环当中。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'hello'</span></span><br><span class="line">list = [<span class="string">'world'</span>]</span><br><span class="line">t = (<span class="string">'world'</span>,)</span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'Tom'</span>,<span class="string">'age'</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="len-和-del"><a href="#len-和-del" class="headerlink" title="len() 和 del()"></a>len() 和 del()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">len(str) <span class="comment"># 5</span></span><br><span class="line">len(dict) <span class="comment">#2 字典的一个键值对记为长度1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span>(str)</span><br><span class="line"><span class="keyword">del</span>(dict[<span class="string">'name'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="max-和-min"><a href="#max-和-min" class="headerlink" title="max() 和 min()"></a>max() 和 min()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max(str)</span><br><span class="line">min(s)</span><br></pre></td></tr></table></figure>

<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 1 3 5 7 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：range()生成的序列不包含end数字。</p>
<p>如果不写开始，默认从0开始</p>
<p>如果不写步长，默认为1</p>
</blockquote>
<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h3><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enumerate(可遍历对象,start = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：start参数用来设置遍历数据的下标的起始值，默认为0。</p>
</blockquote>
</li>
<li><p>enumerate 返回结果是元组，元组第一个数据是原迭代对象的数据对应的下标，第二个为对应的 数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enumerate(list):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> index, char <span class="keyword">in</span> enumerate(list, start = <span class="number">1</span>):</span><br><span class="line">    print(<span class="string">f'下标是<span class="subst">&#123;index&#125;</span>，对应的字符是<span class="subst">&#123;char&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="3、容器类型转换"><a href="#3、容器类型转换" class="headerlink" title="3、容器类型转换"></a>3、容器类型转换</h2><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple()"></a>tuple()</h3><p>作用：将某个序列转换成元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">tuple(list) <span class="comment"># (1,2,3)</span></span><br></pre></td></tr></table></figure>

<h1 id="二、推导式"><a href="#二、推导式" class="headerlink" title="二、推导式"></a>二、推导式</h1><p>作用：主要为化简代码。</p>
<h2 id="1、列表推导式"><a href="#1、列表推导式" class="headerlink" title="1、列表推导式"></a>1、列表推导式</h2><p>作用：用一个表达式创建一个有规律的列表或控制一个有规律的列表。</p>
<h4 id="1、带for循环的列表推导式"><a href="#1、带for循环的列表推导式" class="headerlink" title="1、带for循环的列表推导式"></a>1、带for循环的列表推导式</h4><p>例题：创建从0~9的顺序列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure>

<h4 id="2、带if的列表推导式"><a href="#2、带if的列表推导式" class="headerlink" title="2、带if的列表推导式"></a>2、带if的列表推导式</h4><p>例题：创建从0~9的偶数列表</p>
<ul>
<li><p>方法1：range()步长实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2：if实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3、多个for循环实现列表推导式"><a href="#3、多个for循环实现列表推导式" class="headerlink" title="3、多个for循环实现列表推导式"></a>3、多个for循环实现列表推导式</h4><p>例题：创建列表如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通实现</span></span><br><span class="line">list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        list.append((i,j)) <span class="comment">#列表里添加元组</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#推导式</span></span><br><span class="line">list = [(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将普通实现的方法按照顺序写入列表方括号里，输出项提前即可</p>
</blockquote>
<h2 id="2、字典推导式"><a href="#2、字典推导式" class="headerlink" title="2、字典推导式"></a>2、字典推导式</h2><p>作用：快速合并列表为字典或提取字典中目标数据</p>
<p>案例：</p>
<p>1、创建一个字典：字典key是1-5，value是这个数的平方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;i : i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)&#125; <span class="comment">#&#123;1: 1, 2: 4, 3: 9, 4: 16&#125;</span></span><br></pre></td></tr></table></figure>

<p>2、将两个列表合并为一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'gender'</span>]</span><br><span class="line">list2 = [<span class="string">'Tom'</span>,<span class="number">20</span>,<span class="string">'男'</span>]</span><br><span class="line">dict = &#123;list1[i]: list2[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1))&#125;</span><br></pre></td></tr></table></figure>

<p>3、提取字典中的目标数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">'MBP'</span>: <span class="number">268</span>, <span class="string">'HP'</span>: <span class="number">125</span>, <span class="string">'DELL'</span>: <span class="number">201</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#需求：提取上述电脑数量大于等于200的字典数据</span></span><br><span class="line">count1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items() <span class="keyword">if</span> value &gt;= <span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、集合推导式"><a href="#3、集合推导式" class="headerlink" title="3、集合推导式"></a>3、集合推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#需求：创建一个集合，数据为下方列表的2次方</span></span><br><span class="line">set1 = &#123;<span class="number">1</span> ** <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">in</span> list1&#125; <span class="comment">#&#123;1, 4&#125; 集合的去重功能</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_4(字典元组)</title>
    <url>/2020/06/22/Python-4/</url>
    <content><![CDATA[<p>基于上次的<strong>列表</strong>和<strong>元组</strong>，这次总结<strong>字典</strong>和<strong>集合</strong>的基本操作</p>
<a id="more"></a>

<hr>
<h1 id="一、字典"><a href="#一、字典" class="headerlink" title="一、字典"></a>一、字典</h1><p>字典的数据是以键值对形式出现。</p>
<h2 id="1、创建字典"><a href="#1、创建字典" class="headerlink" title="1、创建字典"></a>1、创建字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'name'</span>:<span class="string">'Tom'</span>,<span class="string">'age'</span>:<span class="number">20</span>,<span class="string">'gender'</span>:<span class="string">'男'</span>&#125; <span class="comment">#有数据字典</span></span><br><span class="line">dict2 = &#123;&#125; <span class="comment">#空字典</span></span><br><span class="line">dict3 = dict() <span class="comment">#空字典</span></span><br></pre></td></tr></table></figure>

<h2 id="2、字典常见操作"><a href="#2、字典常见操作" class="headerlink" title="2、字典常见操作"></a>2、字典常见操作</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>写法：<code>字典序列[key] = 值</code></p>
<blockquote>
<p>注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>del() / del：删除字典或字典中指定键值对</li>
<li>clear()：清空字典</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>字典序列[key] = 值</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="key值查找"><a href="#key值查找" class="headerlink" title="key值查找"></a>key值查找</h4><p><code>dict1[&#39;name&#39;]</code></p>
<blockquote>
<p>如果key存在则返回相应值；否则报错</p>
</blockquote>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ul>
<li><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典序列.get(key, 默认值)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果当前查找的key不存在，则返回第二个参数，如果省略第二个参数，则返回None</p>
</blockquote>
</li>
</ul>
<h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p>查找字典中所有的key，返回可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(dict1.keys()) <span class="comment"># dict_keys(['name','age','gender'])</span></span><br></pre></td></tr></table></figure>

<h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><p>查找字典中所有的value，返回可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(dict1.values()) <span class="comment"># dict_values(['Tom','20','男'])</span></span><br></pre></td></tr></table></figure>

<h4 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h4><p>查找字典中所有的键值对，返回可迭代对象，里面的数据是元组，元组数据1是key，2是value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(dict1.items()) <span class="comment"># dict_items([('name','Tom'),('age',20),('gender','男')])</span></span><br></pre></td></tr></table></figure>

<h2 id="3、字典的循环遍历"><a href="#3、字典的循环遍历" class="headerlink" title="3、字典的循环遍历"></a>3、字典的循环遍历</h2><h3 id="遍历字典的key"><a href="#遍历字典的key" class="headerlink" title="遍历字典的key"></a>遍历字典的key</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    print(key)</span><br><span class="line"><span class="comment"># 结果：name age gender</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历字典的value"><a href="#遍历字典的value" class="headerlink" title="遍历字典的value"></a>遍历字典的value</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">	print(value)</span><br><span class="line"><span class="comment"># 结果 Tom 20 男</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历字典的元素"><a href="#遍历字典的元素" class="headerlink" title="遍历字典的元素"></a>遍历字典的元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line">    print(item)</span><br><span class="line">结果 (<span class="string">'name'</span>,<span class="string">'tom'</span>) (<span class="string">'age'</span>,<span class="number">20</span>) (<span class="string">'gender'</span>,<span class="string">'男'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="遍历字典的键值对-拆包"><a href="#遍历字典的键值对-拆包" class="headerlink" title="遍历字典的键值对(拆包)"></a>遍历字典的键值对(拆包)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="二、集合"><a href="#二、集合" class="headerlink" title="二、集合"></a>二、集合</h1><h2 id="1、创建集合"><a href="#1、创建集合" class="headerlink" title="1、创建集合"></a>1、创建集合</h2><p>创建集合使用<code>{}</code>或<code>set()</code>，但是如果要创建空集合只能使用set()，因为<code>{}</code>用来创建空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2 = set(<span class="string">'ads'</span>)</span><br><span class="line">s3 = set() <span class="comment"># set</span></span><br><span class="line">s4 = &#123;&#125; <span class="comment">#dict</span></span><br></pre></td></tr></table></figure>

<h2 id="2、操作"><a href="#2、操作" class="headerlink" title="2、操作"></a>2、操作</h2><h3 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h3><ul>
<li><p>add()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s1.add(<span class="number">3</span>)</span><br><span class="line">s1.add(<span class="number">1</span>) <span class="comment"># &#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>集合有去重功能，所以当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。</p>
</blockquote>
</li>
<li><p>update()：追加的数据是序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s1.update(<span class="number">3</span>) <span class="comment">#报错 </span></span><br><span class="line">s1.update([<span class="number">100</span>,<span class="number">200</span>])</span><br><span class="line">s1.update(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul>
<li>remove()：删除指定数据，如果数据不存在报错</li>
<li>discard()：删除指定数据，如果数据不存在不报错</li>
<li>pop()：随机删除某个数据，并返回该值</li>
</ul>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><ul>
<li>in</li>
<li>not in</li>
</ul>
<h2 id="3、交并补"><a href="#3、交并补" class="headerlink" title="3、交并补"></a>3、交并补</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集合的交集、并集、差集、对称差运算</span></span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line"><span class="comment"># print(set1.intersection(set2))</span></span><br><span class="line">print(set1 | set2)</span><br><span class="line"><span class="comment"># print(set1.union(set2))</span></span><br><span class="line">print(set1 - set2)</span><br><span class="line"><span class="comment"># print(set1.difference(set2))</span></span><br><span class="line">print(set1 ^ set2)</span><br><span class="line"><span class="comment"># print(set1.symmetric_difference(set2))</span></span><br><span class="line"><span class="comment"># 判断子集和超集</span></span><br><span class="line">print(set2 &lt;= set1)</span><br><span class="line"><span class="comment"># print(set2.issubset(set1))</span></span><br><span class="line">print(set3 &lt;= set1)</span><br><span class="line"><span class="comment"># print(set3.issubset(set1))</span></span><br><span class="line">print(set1 &gt;= set2)</span><br><span class="line"><span class="comment"># print(set1.issuperset(set2))</span></span><br><span class="line">print(set1 &gt;= set3)</span><br><span class="line"><span class="comment"># print(set1.issuperset(set3))</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建总结（二）</title>
    <url>/2020/06/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>前文已经利用GitHub搭建了基本的博客， 此篇总结一些服务器，Linux的知识点，为之后的部署到服务器做好准备。</p>
<a id="more"></a>

<hr>
<p>1、静态博客：hexo,hugo等框架搭建起来的博客，内部生成固定的html页面代码，每个人访问的内容都完全一致。</p>
<p>2、动态博客：wordpress，halo，有着后台应用服务的博客，需要单独应用服务器的承载，比如登录功能。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>experience</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Plan_01（6.21~6.28）</title>
    <url>/2020/06/21/Plan-01-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>这是暑假的第一周，务必不要拖延，每天进步一点。</p>
<a id="more"></a>

<hr>
<p><strong>整体计划：</strong></p>
<ol>
<li>python</li>
<li>Android</li>
<li>服务器</li>
<li>英语</li>
<li>阅读</li>
<li>知乎收藏</li>
</ol>
<p><strong>周一（6.22）计划</strong></p>
<p>四个服务器的视频看完，服务器搭建博客完成</p>
<p>python第七天视频学习完成</p>
<p><strong>本周知乎总结：</strong></p>
<ol>
<li><strong>为人处世</strong><ol>
<li>不要让自己每天的时间分散，碎片化是效率的生死大敌，少刷朋友圈，少水群，因为这只会浪费你的时间。</li>
<li>改变自己最高效的方法，就是去做你害怕的事，不作为比失败更可怕。</li>
<li>能定期和父母联系是一项很棒的能力。</li>
<li>不喜欢当下的工作，马上换，每拖一分你勇气就少一分。你多学一点本事，将来就能少开口求人一次。</li>
<li>学会果断拒绝，而不是犹豫后拒绝。</li>
<li>最短的距离是从嘴到手，最长的距离是从说到做。</li>
</ol>
</li>
<li><strong>大学学习</strong><ol>
<li>你花大量时间，重复着最容易的环节。</li>
</ol>
</li>
<li></li>
</ol>
<p><strong>人是怎么废掉的？</strong></p>
<ol>
<li><p><strong>沉溺于「轻易获得高成就感」的事情</strong>：有意无意地寻求用很小付出获得很大「回报」的偏方，哪怕回报是虚拟的。这种行为会提升自己的「兴奋阈值」，让人越来越不容易拥有成就感，从而越来越依赖虚拟的成就感，陷入恶性循环。症状轻的：<strong>沉溺游戏</strong>（在虚拟世界中加快时间流逝的速度，使得「成功」来得更快）、<strong>种马小说</strong>（意淫人能轻易获得想要的东西）；症状重甚至犯法的：<strong>赌博</strong>（轻易获得「金钱」）、<strong>吸毒</strong>（轻易获得「爽」的感觉）等。</p>
</li>
<li><p><strong>只接收「低信息密度」的信息源</strong>：只愿意接收信息密度低的信息（如无需太多动脑的视频、图片，以及深度较浅的娱乐、八卦、体育新闻等），不愿意接收信息密度高、需要思考后才能吸收的信息（如课程、知识框架、分析报告等）。由于真正有价值、能让人进步的信息大多是需要思考和消化的，所以如果完全隔离了这部分内容，基本也就隔离了进步的可能。</p>
</li>
<li><p><strong>习惯用「错位成就感」麻痹自己</strong>：有两类：① 习惯于拿自己擅长的东西和别人不擅长的东西比较，从来获得「比别人强」的错觉（如：和运动员比学习成绩，和学霸比体育）；② 习惯于拿别人做事情 A 的时间来做事情 B，来假装自己在事情 B 上做得好（如：「炫耀」自己在节假日做了比别人更多的工作，但也仅仅是在节假日才能如此）。</p>
</li>
<li><p><strong>过度依赖「既有可行路径」</strong>：在工作中，习惯了一件事情的流程后再也没想过如何改进，只会机械地重复，然后骗自己很充实。没有改进，便也没有剔除糟粕的意识，于是需要重复的东西越来越多，消耗时间也越来越长，到最后，看上去每天做了很多事情，但其实不仅一点进步都没有，还挤占了进步的空间。</p>
</li>
<li><p><strong>封闭「强化学习」的通道</strong>：在学习或接受信息中，只愿意执行最简单的第一步，却不愿意执行接下来更为复杂的巩固和应用流程，只听不说、只看不写、只学不练，还麻痹自己说学到了很多东西，而实际上，这种「浅层」的学习遗忘极快，有时还不如不学。比如，天天学英语，却从不写英语文章；再比如，天天花大量时间刷知乎，却从不写答案、写总结。</p>
</li>
</ol>
<p><strong>等自己变优秀了再去追女生还来得及吗</strong>？</p>
<p>1、喜欢就去追求，如果没有自信就放弃，不要在模糊状态长期停留，这是你生命的癌细胞，对生命的质量没有任何意义。</p>
<p>2、要么去恋爱，要么勇敢的面对失恋的痛苦，这本身就是勇气。</p>
<p>3、女孩子去买新衣服，买化妆品，花无数的时间去梳妆打扮，是希望自己讨人喜欢。你要明白这一点，并不存在没有缺点的女神。</p>
<p>4、能够吸引你的是一种类型的女孩子，如果你征服不了其中一个，那就换一个，这才是正常状态。你要拥有能够整理自己心理的能力，这是一个成年人成熟的标准。</p>
<p>5、即便你做不到去追求她，但也做不到去忘记她。你起码应该做到的是，不要因为她浪费了你过度的时间和精力，还有资源。然后时间会帮助你解决问题。不是每个女人都是善良的，不要给她养备胎的机会。</p>
<p>6、只有你去追求，去接触，你们才有真实的互相了解的可能，或许她只是绣花枕头，你接触一段时间就不喜欢了，这时候你是不是会觉得长时间的无理由的暗恋很傻呢？</p>
<p>7、你可以没有自信，没有勇气，毕竟这是一个进步的过程。但如果你没有常识，那很可能你会失去对自己的主导权。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>男儿有泪不轻弹？</title>
    <url>/2020/05/13/%E7%94%B7%E5%84%BF%E6%9C%89%E6%B3%AA%E4%B8%8D%E8%BD%BB%E5%BC%B9%EF%BC%9F/</url>
    <content><![CDATA[<p> 你记得你上一次为什么而落泪吗？</p>
<a id="more"></a>

<hr>
<p>5.13 晚20：00</p>
<p>已不记得上次为什么而落泪，可能还是童年时和父母的一次赌气？和同学的一场争执？</p>
<p>十多年过去，即将20岁的我，却再一次落泪</p>
<p>我承认我的懦弱，但这次，我觉得不一样</p>
<p>真的没想到和父母的代沟能有这么大</p>
<p>第一次感受到心痛掩盖了身体的痛</p>
<p>家真的是游子的港湾吗？</p>
<p>可能是地理上的港湾，可能是身体上的给我丰衣足食的港湾</p>
<p>却再也难已是我心灵的港湾了</p>
<p>这次不为任何而哭</p>
<p>只是为自己的孤独而哭</p>
<p>更为自己的无能而哭</p>
<p>或许，这就是庸人最后的挣扎了吧</p>
<p>但毕竟心有不甘</p>
<p>那就继续挣扎吧</p>
<p>起码感动自己</p>
<p>你说，是吧？</p>
<br>

<p>哦对，今天崴脚了，打球这几年的第一次，得好好休养几天了</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>闺女开学有感</title>
    <url>/2020/05/05/%E9%97%BA%E5%A5%B3%E5%BC%80%E5%AD%A6%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>如题</p>
<a id="more"></a>

<hr>
<p>时间过得很快，认识的两个月已经流逝，相信这最后的两个月也不会让我等太久。</p>
<p>这次分离，只能高考后再见，下次相见就长大了啊。</p>
<p>第一次开始在乎QQ的小标识。</p>
<p>是啊，真的挺悲伤</p>
<br>

<p>时间就是这样</p>
<p>又想留住 又想度过</p>
<br>

<p>相信结果一定不会差</p>
<br>

<p>我期待着</p>
<p>高考结束的那一天</p>
<p>成绩下来的那一天</p>
<p>报考志愿的那一天</p>
<p>收到录取通知书的那一天</p>
<p>步入大学的那一天</p>
<br>

<p>相信一切都是上天最好的安排</p>
<br>

<img src="/2020/05/05/%E9%97%BA%E5%A5%B3%E5%BC%80%E5%AD%A6%E6%9C%89%E6%84%9F/1.PNG">

]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑系统重装前的准备工作</title>
    <url>/2020/05/03/%E7%94%B5%E8%84%91%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>总结下次电脑系统重装需要的环境软件和操作。</p>
<a id="more"></a>

<hr>
<h2 id="电脑初始化前的操作"><a href="#电脑初始化前的操作" class="headerlink" title="电脑初始化前的操作"></a>电脑初始化前的操作</h2><p>不能着急，需要把电脑中的资料提前保存，预计是百度网盘（手机号登录），记得开会员。要保存的资料有：</p>
<ul>
<li>MyBlog</li>
<li>每个编译器存放的代码</li>
<li>Wallpaper Engine下的壁纸</li>
<li>下载的音乐</li>
<li>D盘下的小工具</li>
<li>谷歌浏览助手</li>
<li>额滴小心肝</li>
<li>chrome中Tempermonkey的插件</li>
<li>浏览器的标签</li>
</ul>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>首先是要给系统的磁盘分好类。</p>
<ol>
<li>D盘（软件盘）：一级目录为application、server、MyBlog。（把download文件夹移到E盘）<ul>
<li>application：放所有的应用文件。</li>
<li>server：放所有的环境等。<ul>
<li>编程语言环境：JDK，python，php</li>
<li>服务器：tomcat，mysql，redis</li>
<li>虚拟机和虚拟环境：VM，Genymotion，python等</li>
<li>其他：node.js、git或者工具包（SDK等）</li>
</ul>
</li>
</ul>
</li>
<li>E盘（文档盘）：包括学习资料、我的工具，同时把桌面、document等等移到此盘下（先建一个大文件夹（我的文件：注意，文件名换个英文的），然后把每一项移动进来）。</li>
<li>F盘（游戏盘）：每个公司一个文件夹。Steam，Wegame，uplay等。</li>
</ol>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Java（JDK版本仔细考虑）、PHP（php_study）、python</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h3><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>IDEA、PyCharm、PHPStorm、AS、CodeBlocks、Eclipse、VS（不装）、VSCode</p>
<p>（与Github绑定）</p>
<h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p>HBulider、Notepad++、Sublime Text</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>MySQL、Redis、SQL server（不装）、Navicat For MySQL、SQLiteStudio</p>
<p>php_study中有MySQL，了解后使用</p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>VM、Genymotion</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Xftp、Xshell</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>MatLab、RegexBuddy、Cisco Packet Tracer</p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>chrome、Firefox</p>
<p>WPS、Everything、印象笔记、bandzip、欧路翻译、</p>
<p>Iris（护眼）、百度网盘（使用微信登录）、火绒安全</p>
<p>格式工厂、PS，PR、ScreenToGif、达芬奇、PotPlayer（百度网盘中下载，<a href="https://www.zhihu.com/question/20710497/answer/1076773103" target="_blank" rel="noopener">如何使用</a>）、小蝴蝶</p>
<h3 id="娱乐类"><a href="#娱乐类" class="headerlink" title="娱乐类"></a>娱乐类</h3><p>微信、TIM、QQ、网易云音乐、腾讯视频、</p>
<p>网易加速、雷神加速、Steam、WeGame、暴雪战网（炉石官方插件）、Epic</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>VM中建立自己的Linux系统。</p>
<p>tomcat、apache、MySQL、phpMyadmin、PHP等由phpstudy提供</p>
<p>配置虚拟主机</p>
<p>Maven的安装和IDEA中Maven的配置</p>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP——数据库MySQL操作</title>
    <url>/2020/04/29/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>总结PHP中操作MySQL的相关方法与命令。</p>
<a id="more"></a>

<hr>
<h2 id="PHP连接MySQL"><a href="#PHP连接MySQL" class="headerlink" title="PHP连接MySQL"></a>PHP连接MySQL</h2><h3 id="PHP连接MySQL服务器"><a href="#PHP连接MySQL服务器" class="headerlink" title="PHP连接MySQL服务器"></a>PHP连接MySQL服务器</h3><h4 id="mysqli-connect"><a href="#mysqli-connect" class="headerlink" title="mysqli_connect()"></a>mysqli_connect()</h4><ul>
<li><p>描述：连接到MySQL服务器</p>
</li>
<li><p>语法：<code>$link = mysqli_connect([host],[username],[password],[dbName],[port])</code></p>
</li>
<li><p>返回值：连接成功，则返回MySQLi连接对象。如果失败，则返回FALSE。</p>
</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="@运算符"></a>@运算符</h4><ul>
<li>PHP支持错误抑制运算符@。</li>
<li>可以把它放在<strong>变量，函数、include调用</strong>和<strong>变量</strong>等前面。</li>
</ul>
<p>在连接数据库失败的时候，往往系统给出提示信息，会暴露电脑的相关配置，可能发生信息的不安全泄露，造成隐患。我们可以使用错误抑制符@来避免数据库连接失败的错误提示。</p>
<p>用法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$link = @ mysqli_connect([host],[username],[password],[dbName],[port]);</span><br></pre></td></tr></table></figure>

<h4 id="die-和exit"><a href="#die-和exit" class="headerlink" title="die()和exit()"></a>die()和exit()</h4><ul>
<li>输出一个消息并且退出当前脚本，作用等同。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$db_host = <span class="string">"localhost"</span>;<span class="comment">//主机号</span></span><br><span class="line">$db_port = <span class="string">"3306"</span>;	   <span class="comment">//端口号</span></span><br><span class="line">$db_user = <span class="string">"root"</span>;	   <span class="comment">//用户名</span></span><br><span class="line">$db_password = <span class="string">"root"</span>; <span class="comment">//密码</span></span><br><span class="line">$db_name = <span class="string">"mydb"</span>;	   <span class="comment">//数据库名</span></span><br><span class="line">$charset = <span class="string">"utf8"</span>;	   <span class="comment">//字符集</span></span><br><span class="line"><span class="keyword">if</span>(!$link = @ mysqli_connect($db_host.<span class="string">":"</span>.$db_port,$db_user,$db_password))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败"</span>);<span class="comment">//中止程序向下运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mysqli-connect-error"><a href="#mysqli-connect-error" class="headerlink" title="mysqli_connect_error()"></a>mysqli_connect_error()</h4><ul>
<li>返回连接失败的错误信息。</li>
</ul>
<h4 id="mysqli-close"><a href="#mysqli-close" class="headerlink" title="mysqli_close()"></a>mysqli_close()</h4><ul>
<li>关闭先前打开的数据库连接</li>
<li>语法：<code>bool mysqli_close(mysqli $link);</code></li>
</ul>
<h3 id="选择当前数据库"><a href="#选择当前数据库" class="headerlink" title="选择当前数据库"></a>选择当前数据库</h3><p>一个数据库服务器包含很多的数据库，通常需要针对某个具体的数据库操作。</p>
<p>语法：bool mysqli_select_db(mysqli $link,string $database)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!mysqli_select_db($link,$database))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"选择数据库$&#123;db_name&#125;失败"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置客户端字符集"><a href="#设置客户端字符集" class="headerlink" title="设置客户端字符集"></a>设置客户端字符集</h3><p>设置默认字符编码</p>
<p>语法：<code>bool mysqli_set_charset(mysqli $link,string $ charset)</code></p>
<h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><h4 id="mysqli-query"><a href="#mysqli-query" class="headerlink" title="mysqli_query()"></a>mysqli_query()</h4><ul>
<li>发送一条MySQL查询</li>
<li>语法：<code>resource mysqli_query(mysqli $link,string $query)</code></li>
<li>$query是查询的sql语句字符串</li>
</ul>
<p><strong>说明：</strong>mysqli_query()仅对SELECT，SHOW 或 DESCRIBE 语句返回一个mysqli_result结果集对象，如果查询不正确返回FALSE。对于其他类型的SQL语句，成功返回TRUE，失败返回FALSE。非FALSE的返回值意味着查询是合法的并能够被服务器执行。</p>
<p><strong>注意</strong>：查询字符串不应以分号结束，和命令行模式下有区别。</p>
<p>mysqli_result结果集对象：结果已经查到，但必须用特殊的方法才能取出数据。</p>
<h4 id="mysqli-free-result"><a href="#mysqli-free-result" class="headerlink" title="mysqli_free_result()"></a>mysqli_free_result()</h4><ul>
<li>释放与结果集相关联的内存</li>
<li>语法：<code>void mysqli_free_result(mysqli_result $result)</code></li>
</ul>
<p><strong>注意</strong>：是结果集对象mysqli_result，而不是bool。</p>
<h3 id="从结果集获取数据"><a href="#从结果集获取数据" class="headerlink" title="从结果集获取数据"></a>从结果集获取数据</h3><h4 id="mysqli-fetch-row"><a href="#mysqli-fetch-row" class="headerlink" title="mysqli_fetch_row()"></a>mysqli_fetch_row()</h4><ul>
<li><p>从结果集中取出一行作为枚举数组（下标为整型的是枚举数组，下标为字符串的是关联数组）</p>
</li>
<li><p>array mysqli_fetch_row(mysqli_result $result)</p>
</li>
<li><p>每调用一次，取出当前行，并把指针指向下一行，下次调用便是下一行的数据。</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>($arr = mysqli_fetch_row($result))&#123;</span><br><span class="line">    print_r($arr);<span class="comment">//取出所有数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mysqli-fetch-assoc"><a href="#mysqli-fetch-assoc" class="headerlink" title="mysqli_fetch_assoc()"></a>mysqli_fetch_assoc()</h4><ul>
<li><p>从结果集中取出一行作为关联数组</p>
</li>
<li><p>语法：<code>array mysqli_fetch_assoc(mysqli_result $result)</code></p>
</li>
<li><p>从结果集取得的行生成的关联数组，如果没有更多行则返回FALSE。</p>
</li>
</ul>
<p><strong>注意</strong>：此函数返回的字段名大小写敏感。</p>
<h4 id="mysqli-fetch-array"><a href="#mysqli-fetch-array" class="headerlink" title="mysqli_fetch_array()"></a>mysqli_fetch_array()</h4><ul>
<li><p>从结果集中取出一行作为关联数组或数字数组，或二者兼有。</p>
</li>
<li><p>语法：<code>array mysqli_fetch_array(mysqli_result $result [,int $result_type = MYSQLI_BOTH])</code></p>
</li>
<li><p>$result_type是一个常量，取值：MYSQLI_BOTH （二者兼有，默认），MYSQLI_ASSOC （关联索引），MYSQLI_NUM（数字索引） </p>
</li>
<li><p>从结果集取得的行生成的数组，如果没有更多行则返回FALSE。</p>
</li>
</ul>
<p><strong>注意</strong>：此函数返回的字段名大小写敏感。</p>
<p>二者兼有<strong>举例</strong>（一份数据在数组中存两遍，一遍枚举数组，一遍关联数组）：</p>
<img src="/2020/04/29/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E6%93%8D%E4%BD%9C/1.png" class>

<h4 id="mysqli-fetch-all"><a href="#mysqli-fetch-all" class="headerlink" title="mysqli_fetch_all()"></a>mysqli_fetch_all()</h4><p>从结果集中取出所有行作为关联数组、枚举数组或二者兼有。</p>
<p>语法：<code>mixed mysqli_fetch_all(mysqli_result $result [,int $result_type = MYSQLI_NUM])</code></p>
<p>与之前不同的是，默认为枚举数组；即第一维永远为数字，表示第几条记录，第二维字段可以改变，数字、字符串或二者兼有。</p>
<h4 id="mysqli-error"><a href="#mysqli-error" class="headerlink" title="mysqli_error()"></a>mysqli_error()</h4><ul>
<li><p>显示执行sql语句失败的错误信息</p>
</li>
<li><p>语法：<code>mysqli_error(mysqli $link)</code></p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"insert into test(id,name,age) values(null,'李四',25)"</span>;</span><br><span class="line">$result = mysqli_query($link,$sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"2、数据插入失败:"</span>.mysqli_error($link));</span><br></pre></td></tr></table></figure>

<h3 id="获取记录数"><a href="#获取记录数" class="headerlink" title="获取记录数"></a>获取记录数</h3><h4 id="mysqli-num-rows"><a href="#mysqli-num-rows" class="headerlink" title="mysqli_num_rows()"></a>mysqli_num_rows()</h4><p>取得结果集中行的数目</p>
<p>语法：<code>int mysqli_num_rows(mysqli_result $result)</code></p>
<p><strong>注意：</strong>此命令仅对SELECT语句有效。</p>
<h4 id="mysqli-affected-rows"><a href="#mysqli-affected-rows" class="headerlink" title="mysqli_affected_rows()"></a>mysqli_affected_rows()</h4><p>取得前一次MySQL操作所影响的记录行数，包括SELECT,UPDATE,INSERT或DELETE。</p>
<p>语法：<code>int mysqli_affected_rows(mysqli $link)</code></p>
<p><strong>注意：</strong>如果最近一次查询失败，函数返回-1。当使用UPDATE查询，MySQL不会将原值和新值一样的值更新，即此条记录不代表被修改。返回值不一定就是查询条件所符合的记录，只有修改过的记录数才会被返回。</p>
<p><strong>案例演示注意事项</strong></p>
<p>1、首先是表单的提交，在php中判断是否提交表单，可以在表单中设置隐藏域，值为一个随机值，判断这个随机且唯一的值是否正确即可判断表单是否提交，该方法可避免其他人提交表单修改自己数据库的不安全情况。</p>
<img src="/2020/04/29/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E6%93%8D%E4%BD%9C/2.png" class>

<p>2、然后是复选框的提交，复选框提交时会出现覆盖现象，此时在name属性后添加<code>[]</code>来表明该属性为数组属性。</p>
<p>PHP会把<code>name=&quot;hobby[]&quot;</code>看成添加一个数组元素，而HTML会把它看成一个字符串。</p>
<img src="/2020/04/29/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E6%93%8D%E4%BD%9C/3.png" class>

<p><strong>提示：</strong>将多个爱好连成一个值，并写入到数据库某个字段中，只需要一个字段来存储爱好，用到字符串的拼接。</p>
<img src="/2020/04/29/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E6%93%8D%E4%BD%9C/4.png" class>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>十天时光荒废总结</title>
    <url>/2020/04/16/%E5%8D%81%E5%A4%A9%E6%97%B6%E5%85%89%E8%8D%92%E5%BA%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>十天时光已然逝去，但万事有弊就有利，相信浪费的时光也有其宝贵的价值。</p>
<a id="more"></a>

<hr>
<p>这十天真是浑浑噩噩的十天，难以想象，现在回头看看，竟不能细想出干了些什么事，怕是每天都是重复，毫无收获吧。</p>
<p>十天状态：</p>
<p>1、课不好好上，就是不听，玩手机，心安理得，不像以前带着愧疚感玩。</p>
<p>2、没有上进，毫无作为，什么都不想干。</p>
<p>3、混吃等死？破罐子破摔？真是可怕。</p>
<p>4、张武？每天就是这么没的。</p>
<p>真的觉得世界都黑暗了，不知道该干什么，什么都干不好。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>reinvent</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Jetpack架构组件（一）</title>
    <url>/2020/04/05/Android-1/</url>
    <content><![CDATA[<p>开始学习Android Jetpack相关知识。</p>
<a id="more"></a>

<hr>
<p>首先补充一点内容。</p>
<h3 id="设置app的横屏和竖屏"><a href="#设置app的横屏和竖屏" class="headerlink" title="设置app的横屏和竖屏"></a>设置app的横屏和竖屏</h3><p>设置app某个界面的横屏和竖屏的不同显示方式。</p>
<img src="/2020/04/05/Android-1/1.png" class>

<p>即可创建当前页面的一个横屏副本。</p>
<p>app页面的横屏和竖屏转换是一个Activity的杀死重创建的过程，即界面被刷新，如果当前界面的数据没保存，则会丢失。</p>
<p>如果需要临时保存当前页面的数据，使其在反转后数据不丢失，则需要以下操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先注意onCreate(Bundle savedInstanceState)的参数，为保存当前页面的临时数据，Bundle类为key:value形式。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String s = savedInstanceState.getString(<span class="string">"KEY"</span>);</span><br><span class="line">            textView.setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                textView.setText(R.string.button);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(<span class="string">"KEY"</span>, textView.getText().toString());<span class="comment">//存入Bundle对象，便于onCreate方法取出</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Android-Jetpack"><a href="#Android-Jetpack" class="headerlink" title="Android Jetpack"></a>Android Jetpack</h2><img src="/2020/04/05/Android-1/2.png" class>

<p><strong>ViewModel</strong>：对象为特定的界面组件（如 Fragment 或 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，ViewModel 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。ViewModel 不了解界面组件，因此不受配置更改（如在旋转设备时重新创建 Activity）的影响。</p>
<p><strong>LiveData</strong>：是一种可观察的数据存储器。应用中的其他组件可以使用此存储器监控对象的更改，而无需在它们之间创建明确且严格的依赖路径。LiveData 组件还遵循应用组件（如 Activity、Fragment 和 Service）的生命周期状态，并包括清理逻辑以防止对象泄漏和过多的内存消耗。</p>
<p><strong>DataBinding</strong>：声明性地将可观察数据绑定到UI元素，其目的在于是为了脱离Controller与View之间的引用联系，很类似Butterknife库，使用也比较相似。</p>
<p><strong>Navigation</strong>：允许用户在应用程序中浏览、进入和退出不同内容的Fragment。Navigation能够实现从简单的按钮单击到更复杂的模式，如应用程序栏和导航抽屉。导航组件还通过遵循一套既定的原则来确保一致和可预测的用户体验。</p>
<p><strong>Lifecycles</strong>：Lifecycles是一个生命周期感知组件，当Activity或者Fragment的生命周期发生改变的时会，Lifecycles也会做出相应的生命周期状态的改变，它保存关于组件生命周期状态的信息(比如活动或片段)，并允许其他对象观察这种状态。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a><strong>ViewModel</strong></h3><p>刚入门，做了一个简短的案例，通过ViewModel管理UI产生的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个按钮，实现+1，+2操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//用的是ViewModelProviders，可能需要引入Gradle配置</span></span><br><span class="line">        myVideModel = ViewModelProviders.of(<span class="keyword">this</span>).get(MyVideModel<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//创建ViewModel对象</span></span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        textView.setText(String.valueOf(myVideModel.num));</span><br><span class="line">        button1 = findViewById(R.id.button);</span><br><span class="line">        button2 = findViewById(R.id.button2);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                myVideModel.num ++;</span><br><span class="line">                textView.setText(String.valueOf(myVideModel.num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                myVideModel.num += <span class="number">2</span>;</span><br><span class="line">                textView.setText(String.valueOf(myVideModel.num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//MyVideModel自定义的ViewModel类，需要继承自ViewModel类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVideModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewModel的出现主要为了解决两个问题：<br>1.当Actvitiy销毁重建过程中的数据恢复问题，虽然原来可以使用<code>onSaveInstanceState()</code>来完成，但是只支持能被序列化的数据而且是小量数据，对于大量数据则显得有点无力。<br>2.UI控制器的工作繁忙，UI控制器主要用于处理显示，交互，其他的额外操作可以委托给其他类完成，将不应该分配给UI的任务分离出来是必要的。</p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><img src="/2020/04/05/Android-1/3.png" class>

<p>LiveData是配合ViewModel使用的</p>
<p><strong>案例：</strong>实现一个点赞和踩的统计功能</p>
<p>ViewModelWithLiveData.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelWithLiveData</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; LikedNumber;<span class="comment">//创建LiveData的方式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title">getLikedNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LikedNumber == <span class="keyword">null</span>)&#123;</span><br><span class="line">            LikedNumber = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">            LikedNumber.setValue(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LikedNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLikedNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        LikedNumber.setValue(LikedNumber.getValue() + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thorine.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageButton;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ViewModelWithLiveData viewModelWithLiveData;</span><br><span class="line">    TextView textView;</span><br><span class="line">    ImageButton imageButtonLike , imageButtonDislike;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        imageButtonLike = findViewById(R.id.imageButton);</span><br><span class="line">        imageButtonDislike = findViewById(R.id.imageButton2);</span><br><span class="line"></span><br><span class="line">        viewModelWithLiveData = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>).get(ViewModelWithLiveData<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        viewModelWithLiveData.getLikedNumber().observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                textView.setText(String.valueOf(integer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        imageButtonLike.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                viewModelWithLiveData.addLikedNumber(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        imageButtonDislike.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                viewModelWithLiveData.addLikedNumber(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端</p>
<img src="/2020/04/05/Android-1/4.png" class>

<p>并使用了Android Studio中基本的矢量图创建方法。</p>
<img src="/2020/04/05/Android-1/5.png" class>

<h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>1、首先需要在gradle中添加DataBinding依赖，具体做法，在defaultConfig下添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataBinding &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>2、在xml布局中引入DataBinding，点击首行代码的小灯泡即可。</p>
<p>3、在MainActivity.java中修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setContentView(R.layout.activity_main);</span></span><br><span class="line">binding = DataBindingUtil.setContentView(<span class="keyword">this</span>,R.layout.activity_main);</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">binding.setData(myViewModel);</span><br><span class="line">binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>4、xml布局文件的<code>&lt;data&gt;</code>中添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">	&lt;variable</span><br><span class="line">		name=<span class="string">"data"</span></span><br><span class="line">		type=<span class="string">"com.thorine.databinding.MyViewModel"</span> /&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>textView中获取数值：<code>android:text=&quot;@{String.valueOf(data.number)}&quot;</code></p>
<p>Button中绑定监听事件：<code>android:onClick=&quot;@{()-&gt;data.add()}&quot;</code></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自我改造计划（综述）</title>
    <url>/2020/04/04/%E8%87%AA%E6%88%91%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92%EF%BC%88%E7%BB%BC%E8%BF%B0%EF%BC%89/</url>
    <content><![CDATA[<p>希望自己不再堕落，每天都有一点收获。</p>
<p>全文主旨：<strong>戒掉手机</strong>。</p>
<a id="more"></a>

<hr>
<p>每天什么都不想做，只想躺着呆着玩手机？</p>
<h2 id="提前透支自己的人生，体会过后的空虚"><a href="#提前透支自己的人生，体会过后的空虚" class="headerlink" title="提前透支自己的人生，体会过后的空虚"></a>提前透支自己的人生，体会过后的空虚</h2><blockquote>
<p>“大半的人在二十岁或三十岁上就死了。一过这个年龄，他们只变了自己的影子。以后的生命不过是用来模仿自己，把以前真正有人味儿的时代所说的，所做的，所想的，所喜欢的，一天天的重复，而且重复的方式越来越机械，越来越脱腔走板。”——《约翰·克里斯多夫》罗曼·罗兰</p>
</blockquote>
<h2 id="注意力被过度消散后的不专注"><a href="#注意力被过度消散后的不专注" class="headerlink" title="注意力被过度消散后的不专注"></a>注意力被过度消散后的不专注</h2><p>信息泛滥让人的专注度下降，但真正能够让你的大脑汲取到营养的，都是需要高度且长时间专注的事，比如读书。</p>
<p>一个简单的问题：<strong>你多久没有安下心来，好好的读一本书了？</strong></p>
<p>尝试先从简单的事情做起，比如听一听TED一些心理篇的演讲。</p>
<h2 id="快感刺激阈值被提高后的慵懒"><a href="#快感刺激阈值被提高后的慵懒" class="headerlink" title="快感刺激阈值被提高后的慵懒"></a>快感刺激阈值被提高后的慵懒</h2><p>我们用手机逃避自己的现状，我们也在利用玩手机来拖延、逃避眼前待解决的问题。</p>
<p>玩手机来饮鸠止渴，回光返照，越是Deadline，越玩的疯狂，恶性循环。</p>
<h2 id="耐心点去感受不同阶段的人生体会"><a href="#耐心点去感受不同阶段的人生体会" class="headerlink" title="耐心点去感受不同阶段的人生体会"></a>耐心点去感受不同阶段的人生体会</h2><p>短暂地关闭外界感知通道，离开手机，反而有助于你的思维变得更清晰，更透彻。</p>
<p>​    而且啊，其实你即使不去关注那些，也没什么影响的。</p>
<p>​    就算你每隔五秒打开一次微信，没事找你的人还是不会找你。</p>
<p>​    就算你每天都能刷出瀑布般的信息流，和你无关的事还是和你无关。</p>
<img src="/2020/04/04/%E8%87%AA%E6%88%91%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92%EF%BC%88%E7%BB%BC%E8%BF%B0%EF%BC%89/1.jpg" class>

<h2 id="直面空虚和抑郁，借助它们反思"><a href="#直面空虚和抑郁，借助它们反思" class="headerlink" title="直面空虚和抑郁，借助它们反思"></a>直面空虚和抑郁，借助它们反思</h2><blockquote>
<p>为什么别人能做好的事情我做不好？</p>
<p>为什么别人跟着建民慢慢成长，我却连队伍都跟不上？</p>
</blockquote>
<p>人只有在抑郁的时候，才愿意思考。</p>
<p>是真的，先借助负面情绪，才能摆脱掉负面情绪。</p>
<h2 id="逼自己去做点慢节奏的事"><a href="#逼自己去做点慢节奏的事" class="headerlink" title="逼自己去做点慢节奏的事"></a>逼自己去做点慢节奏的事</h2><p>不要觉得发呆是浪费时间，也不要觉得停下来就是不思进取。</p>
<p>很多时候，停下来，等一等，看看四周，反思下过往，思考下未来，你会有很多错过的新发现。</p>
<p>一个小时也没看进去两页书，这没啥不好意思的。相比起自暴自弃刷手机，往大脑里塞一个小时的抖音神曲和情绪垃圾，对着书页放空大脑都要好很多。允许自己慢慢来，你迟早可以一个小时看五页、十页、二十页……</p>
<p>关键在于，屏蔽掉外界的信息，好好感受自己思维和注意力的游荡。前期你可以不过多干涉，就让自己静静的观察，并重新审视那些不断黏着你注意力的事物，再问问自己：“它配吗？”</p>
<p><strong>找回注意力，就是找回对时间的掌控感。</strong></p>
<p><strong>把步调调慢后，其实生活中那种“疲于奔命”的感觉也消失了。</strong></p>
<p>因为只有停下来，时间的流动才变得格外明显。只有慢慢来，时间的报答才有空酝酿成熟。</p>
<p>毕竟，很多名人的slogan都是：“做时间的朋友。”</p>
<p><strong>从今天起，每天做好属于自己的事情，总结记录，每天反思，望坚持。</strong></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>revient</tag>
      </tags>
  </entry>
  <entry>
    <title>清明</title>
    <url>/2020/04/04/%E6%B8%85%E6%98%8E/</url>
    <content><![CDATA[<p>记录已经过完的四分之一个2020年。</p>
<a id="more"></a>

<hr>
<p>又是一个清明时节，但这次显然多了一层不一样的含义</p>
<p>宅家三月，似乎还没有做些什么，2020年就过了四分之一</p>
<p>但这更是与死神抢人的三个月，国内疫情稍稍好转，国外疫情却大行其道</p>
<p>我想过见证历史，但没想到，我会见证这样的历史</p>
<p>全国默哀，举国悼念</p>
<p>数不清的天使为我们保驾护航</p>
<p>那有什么英雄，不过只是在死神手里抢人的一个个普通人罢了</p>
<br>

<p>窗外狂风怒号</p>
<p>号笛拉响</p>
<p>天地动容</p>
<br>

<p>人类的赞歌是勇气的赞歌</p>
<p>人类的伟大是勇气的伟大</p>
<br>

<blockquote>
<p>愿逝者安息</p>
<p>愿生者奋发</p>
<p>愿祖国昌盛</p>
</blockquote>
<br>

<p>消逝的星星，你们永远在我心中</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识（五）</title>
    <url>/2020/03/30/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>总结展开PHP中文件加载和错误处理的具体操作。</p>
<a id="more"></a>

<hr>
<h2 id="一、文件加载"><a href="#一、文件加载" class="headerlink" title="一、文件加载"></a>一、文件加载</h2><h3 id="1、文件加载的含义"><a href="#1、文件加载的含义" class="headerlink" title="1、文件加载的含义"></a>1、文件加载的含义</h3><p>将一个别的文件包含到当前文件中，成为当前文件运行过程中的一部分。通常，一些公共的代码，在多个页面都需要用到的时候，会做成一个独立的文件。然后在不同的页面需要用到的时候，直接载入进来就可以了。</p>
<h3 id="2、文件加载的四种方式"><a href="#2、文件加载的四种方式" class="headerlink" title="2、文件加载的四种方式"></a>2、文件加载的四种方式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">include_once</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">''</span>;</span><br><span class="line"><span class="comment">#其中的参数都是加载文件的路径（相对路径或绝对路径）</span></span><br></pre></td></tr></table></figure>

<p>获取物理路径（绝对路径）的方式：</p>
<p><code>__DIR__</code>：表示当前文件所在路径，由它可以构建出绝对路径。</p>
<p><code>getcwd()</code>：表示当前正访问的网页路径（当前工作目录），由它也可以构建绝对路径。</p>
<p><strong>四种载入方式</strong>：一般来说，如果被载入的文件内容，是后续代码运行的必备前提，则应该使用require载入；如果被载入的文件内容，只需要（或只允许）出现一次，则应该使用“xxx_once”载入。include错误级别低，不会阻止代码运行。</p>
<h2 id="二、错误处理"><a href="#二、错误处理" class="headerlink" title="二、错误处理"></a>二、错误处理</h2><h3 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h3><p>语法错误：运行前出错。</p>
<p>运行时错误：语法没错，执行过程中出错。</p>
<p>逻辑错误：运行结果出错。</p>
<h3 id="常见的错误代号"><a href="#常见的错误代号" class="headerlink" title="常见的错误代号"></a>常见的错误代号</h3><p>E_NOTICE: 提示性错误，轻微，继续执行后面程序。</p>
<p>E_WARNING:警告，稍微严重，后面的程序继续执行。</p>
<p>E_ERROR:严重错误/致命错误，后面程序不继续执行。</p>
<p>E_PARSE:语法错误，直接不运行程序。</p>
<p>E_USER_NOTICE，E_USER_WARNING，E_USER_ERROR:用户自定义的提示、警告和严重错误。</p>
<p>E_ALL：它是一个代表“所有”错误的代号。</p>
<p>这些代号都是系统常量。</p>
<h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>程序本身有错时，运行时会报错提示，但如果程序没错，而不符合预期结果，就可以主动触发一个错误，也就是说主动创建一个错误，E_USER_NOTICE，E_USER_WARNING，E_USER_ERROR等，那么如何触法用户错误呢？</p>
<p>自定义错误触发语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">trigger_error(<span class="string">"自定义错误提示内容"</span>,自定义错误的代号);</span><br></pre></td></tr></table></figure>

<p><strong>案例演示</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reg_user</span><span class="params">($age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($age &gt; <span class="number">120</span> || $age &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        trigger_error(<span class="string">"年龄不符合规范"</span>,E_USER_NOTICE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"用户资料审核通过！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reg_user(<span class="number">150</span>);</span><br></pre></td></tr></table></figure>

<h3 id="错误显示"><a href="#错误显示" class="headerlink" title="错误显示"></a>错误显示</h3><p>如果有错误发生（触发了错误），默认情况下会被显示在页面（即输出的结果页面）。</p>
<ol>
<li><p>设置display_errors以决定是否显示错误</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ini_set(<span class="string">'display_errors'</span>,<span class="number">1</span>或<span class="number">0</span>);<span class="comment">//1表示显示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置error_reporting以决定显示那些错误（错误代号：E_NOTICE…）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ini_set(<span class="string">'error_reporting'</span>，错误代号<span class="number">1</span> | 错误代号<span class="number">2</span> ...)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h3><p>具体做法，分两步：</p>
<ol>
<li>声明错误发生时，由我们自己来处理——设定一个错误处理的函数名。</li>
<li>定义该函数，在函数中详细设定错误的处理情况：怎么显示，显示什么，怎么记录，记录什么。</li>
</ol>
<p><strong>注意：</strong>自定义错误只能处理“非致命错误”。</p>
<p><strong>实例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义错误</span></span><br><span class="line"><span class="comment">//set_error_handler("自定义的处理错误的函数的名字");</span></span><br><span class="line">set_error_handler(<span class="string">"my_error_handler"</span>);</span><br><span class="line"><span class="comment">//定义该函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_error_handler</span><span class="params">($errCode,$errMsg,$errFile,$errLine)</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数解释：errCode:错误代码，errMsg：错误信息，errFile：错误文件，errLine：错误行号</span></span><br><span class="line">    <span class="comment">//此形参顺序固定，而且是由系统自动调用并传入参数</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'错误代码：'</span>.$errCode.<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'错误信息：'</span>.$errMsg.<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'错误文件：'</span>.$errFile.<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'错误行号：'</span>.$errLine.<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"v1 = $v1"</span>;<span class="comment">//未定义的变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'./no-this-file.php'</span>;<span class="comment">//打开不存在的文件</span></span><br><span class="line">l1();<span class="comment">//调用未定义的函数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB课程总结（四）</title>
    <url>/2020/03/27/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章总结MATLAB程序设计，主要涉及代码文件方面。</p>
<a id="more"></a>

<hr>
<h2 id="程序的三个结构"><a href="#程序的三个结构" class="headerlink" title="程序的三个结构"></a>程序的三个结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="1、数据的输入"><a href="#1、数据的输入" class="headerlink" title="1、数据的输入"></a>1、数据的输入</h4><p>从键盘输入数据，则可以使用input函数来进行，调用格式为：</p>
<p><code>A = input(提示信息，选项);</code></p>
<p>其中提示信息为一个字符串，用于提示用户输入数据。</p>
<h4 id="2、数据的输出"><a href="#2、数据的输出" class="headerlink" title="2、数据的输出"></a>2、数据的输出</h4><p>命令窗口输出函数主要有disp函数，其调用格式为：</p>
<p><code>disp(输出项）</code></p>
<p>其中输出项既可以为字符串，也可以为矩阵。</p>
<p>若输出多个数据，并显示提示信息，则需要：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disp</span>([<span class="string">'提示信息'</span>,num2str(A)]); 	<span class="comment">%num2str函数将任何数值转换为字符</span></span><br></pre></td></tr></table></figure>

<p><strong>例题</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = input(<span class="string">'a=?'</span>);</span><br><span class="line">b = input(<span class="string">'b=?'</span>);</span><br><span class="line">c = input(<span class="string">'c=?'</span>);</span><br><span class="line">d = b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x = [(-b+<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'x1='</span>,num2str(x(<span class="number">1</span>)),<span class="string">',x2='</span>,num2str(x(<span class="number">2</span>))]);</span><br><span class="line">程序输出为：</span><br><span class="line">a=?<span class="number">4</span></span><br><span class="line">b=?<span class="number">78</span></span><br><span class="line">c=?<span class="number">54</span></span><br><span class="line">x1=<span class="number">-0.7188</span>,x2=<span class="number">-18.7812</span>			<span class="comment">%注意disp函数的用法</span></span><br></pre></td></tr></table></figure>

<h4 id="3、程序的暂停"><a href="#3、程序的暂停" class="headerlink" title="3、程序的暂停"></a>3、程序的暂停</h4><p>程序执行过程中暂停，可用pause函数，其调用格式为：</p>
<p><code>pause（延迟描述）</code></p>
<p>如果省略延迟时间，直接使用pause，则将暂停程序，直到用户按任一键后程序继续执行。</p>
<p>若要强行中止程序的运行可按Ctrl+C键。</p>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span></span><br><span class="line">	语句组 <span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span> 条件<span class="number">2</span></span><br><span class="line">	语句组 <span class="number">2</span> …</span><br><span class="line"><span class="keyword">elseif</span> 条件m</span><br><span class="line">	语句组 m</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">1</span></span><br><span class="line">		语句组<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">2</span></span><br><span class="line">		语句组<span class="number">2</span> …</span><br><span class="line">	<span class="keyword">case</span> 表达式m</span><br><span class="line">		语句组m</span><br><span class="line">	<span class="keyword">otherwise</span></span><br><span class="line">		语句组 n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>switch子句后面的表达式应为一个标量或一个字符串；case子句后面的表达式不仅可以为一个标量或一个字符</p>
<p>串，还可以为一个元胞矩阵。</p>
<h4 id="try"><a href="#try" class="headerlink" title="try"></a>try</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">	语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">	语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>try语句先试探性执行语句组1，如果在执行过程中出现错误，则将错误信息赋给保留的lasterr变量，并转去执行语句组2。</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量 =表达式<span class="number">1</span>：表达式<span class="number">2</span>：表达式<span class="number">3</span></span><br><span class="line">	循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其中表达式1的值为循环变量的初值，表达式2的值为步长，表达式3的值为循环变量的终值。步长为1时，表达式2可以省略。</p>
<p><strong>例题</strong>（注意这个例题的非循环方法）</p>
<img src="/2020/03/27/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/4.png" class>

<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>条件</span><br><span class="line">	循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h4><p>它们一般与if语句配合使用。</p>
<p>break语句用于终止循环的执行。</p>
<p>当在循环体内执行到该语句时，程序将跳出循环，继续执行循环语句的下一语句。</p>
<p>continue语句控制跳过循环体中的某些语句。</p>
<p>当在循环体内执行到该语句时，程序将跳过循环体中所有剩下的语句，继续下一次循环。</p>
<h2 id="M文件的分类"><a href="#M文件的分类" class="headerlink" title="M文件的分类"></a>M文件的分类</h2><p>除了在命令窗口直接操作，我们可以创建文件（M文件）来进行调用，使程序结构简单，编程效率高。</p>
<p>用Matlab语言编写的程序，称为M文件。</p>
<p>是由若干Matlab命令组合在一起构成的，它可以完成某些操作，也可以实现某种算法。</p>
<p>◼ M文件根据调用方式的不同分为两类：</p>
<p>​    命令文件（Script File）</p>
<p>​    函数文件（Function File） </p>
<p>◼ 它们的扩展名都是.m</p>
<h3 id="命令文件和函数文件的区别"><a href="#命令文件和函数文件的区别" class="headerlink" title="命令文件和函数文件的区别"></a><strong>命令文件和函数文件的区别</strong></h3><p>命令文件没有输入参数，也不返回输出参数；函数文件可以带输入参数，也可以返回输出参数。</p>
<p>◼ 命令文件对工作空间中的变量进行操作，文件中所有命令的执行结果也返回工作空间中；函数文件中定义的变</p>
<p>​    量为局部变量，当函数文件执行完毕时，这些变量也被清除。</p>
<p>◼ 命令文件可以直接运行；函数文件不能直接运行，要以函数调用的方式来调用它。</p>
<h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><p>函数文件是另一种形式的M文件，每一个函数文件都定义一个函数。Matlab提供的标准函数大部分是由函数文件定义的。</p>
<h4 id="函数文件的基本结构"><a href="#函数文件的基本结构" class="headerlink" title="函数文件的基本结构"></a><strong>函数文件的基本结构</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表 = 函数名（输入形参表）</span></span><br><span class="line">注释说明部分</span><br><span class="line">函数体语句</span><br></pre></td></tr></table></figure>

<p>其中，以function开头的一行为引导行，表示该M文件是一个函数文件。当输出形参多于一个时，应该用<strong>方括号</strong>括起来。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>关于函数文件名</p>
<p>函数文件名通常由函数名再加上扩展名.m组成。</p>
<p>当函数文件名与函数名不同时，Matlab将忽略函数名而确认文件名，因此调用时<strong>使用函数文件名</strong>。</p>
</li>
<li><p>关于注释说明部分</p>
<p>  注释说明包括3部分：</p>
<p>  ① 紧随引导行之后以%开头的第一注释行。</p>
<p>  这一行一般包括大写的函数文件名和函数功能简要描述，供lookfor关键词查询和help在线帮助时使用。</p>
<p>  ② 第一注释行及之后连续的注释行。</p>
<p>  通常包括函数输入/输出参数的含义及调用格式说明等信息，构成全部在线帮</p>
<p>  ③ 与在线帮助文本相隔一空行的注释行。包括函数文件编写和修改的信息，如作者和版本等。</p>
</li>
<li><p>关于return语句<br>  如果在函数文件中插入了return语句，则执行到该语句就结束函数的执行，流程转至调用该函数的位置。通常也不使用return语句。</p>
</li>
</ol>
<p><strong>例题</strong>：编写函数文件，求半径为r的圆的面积和周长。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">函数文件如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[s,p]</span> = <span class="title">fcircle</span><span class="params">(r)</span></span></span><br><span class="line"><span class="comment">% FCIRCLE calculate the area and perimeter of a circle of radii r</span></span><br><span class="line"><span class="comment">% r 圆半径</span></span><br><span class="line"><span class="comment">% s 圆面积</span></span><br><span class="line"><span class="comment">% p 圆周长</span></span><br><span class="line"><span class="comment">%2006年2月30日编</span></span><br><span class="line">s = <span class="built_in">pi</span>*r*r;</span><br><span class="line">p = <span class="number">2</span>*<span class="built_in">pi</span>*r;</span><br><span class="line"></span><br><span class="line">将以上函数文件以文件名fcircle.m保存，然后在命令窗口调用。</span><br><span class="line">[s,p] = fcircle(<span class="number">10</span>)</span><br><span class="line">输出结果是：</span><br><span class="line">s = </span><br><span class="line"><span class="number">314.1593</span></span><br><span class="line">p =</span><br><span class="line"><span class="number">62.8319</span></span><br><span class="line"></span><br><span class="line">采用help命令或lookfor命令可以显示出注释说明部分的内容。</span><br><span class="line">help fcircle</span><br><span class="line">屏幕显示</span><br><span class="line">FCIRCLE calculate the area and perimeter of a circle of radii r</span><br><span class="line">r 圆半径</span><br><span class="line">s 圆面积</span><br><span class="line">p 圆周长</span><br></pre></td></tr></table></figure>

<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用的一般格式是：</p>
<p><strong>[输出实参表] = 函数名(输入实参表）</strong></p>
<p>注意：函数调用时，各实参出现的顺序、个数，应与函数定义时相同。</p>
<p>在Matlab中，函数可以嵌套调用，即一个函数可以调用别的函数。一个函数调用自身称为函数的递归调用。</p>
<h4 id="函数参数的可调性"><a href="#函数参数的可调性" class="headerlink" title="函数参数的可调性"></a>函数参数的可调性</h4><p>Matlab在函数调用上有一个与一般高级语言不同之处：</p>
<p>函数所传递参数数目的可调性，即参数的数量可以改变。</p>
<p>在调用函数时，Matlab用两个预定义变量<strong>nargin</strong>和<strong>nargout</strong>分别记录调用该函数时的输入实参和输出实参的个数。</p>
<p><strong>例子</strong></p>
<img src="/2020/03/27/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" class>

<h4 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a><strong>全局变量与局部变量</strong></h4><p>Matlab中，函数文件中的变量是局部变量。</p>
<p>如在若干函数中，都把某一变量定义为全局变量，那么这些函数将共用这个变量。</p>
<p>全局变量的作用域是整个Matlab的工作空间，所有函数都可以对它进行存取和修改。</p>
<p>全局变量用<strong>global</strong>命令定义，格式为：</p>
<p><code>global 变量名</code></p>
<img src="/2020/03/27/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/2.png" class>]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识（四）</title>
    <url>/2020/03/27/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章总结php代码嵌套到html中所需的<strong>标签语法</strong>，还有php中<strong>函数</strong>的定义和使用。</p>
<a id="more"></a>

<hr>
<h2 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>标签语法</strong>，指当PHP代码嵌入到HTML中时，为了让PHP代码的结构更加符合HTML的规范而设定的语法结构。</p>
<ul>
<li><p>PHP标签语法不是所有的结构都存在。</p>
</li>
<li><p>PHP标签语法只提供了两种针对<code>{}</code>的解决方案。</p>
<ul>
<li>分支标签：即当分支语法出现时，可以使用标签语法代替。</li>
<li>循环标签：即当循环语法出现时，可以使用标签语法代替。</li>
</ul>
</li>
<li><p>标签语法规则</p>
<ul>
<li>当分支或循环的<code>{</code>出现时，使用冒号<code>:</code>代替。</li>
<li>当分支或循环的<code>}</code>出现时，使用相应的<code>end + 标记内容;</code>代替。</li>
</ul>
</li>
<li><p>PHP提供的标记语法</p>
<ul>
<li>IF分支</li>
<li>switch分支</li>
<li>while循环</li>
<li>for循环</li>
<li>foreach循环</li>
<li>语法格式：<ul>
<li>起始标记（if为例）：<code>if(条件表达式):</code></li>
<li>结束标记（if为例）：<code>endif;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="案例（九九乘法表）"><a href="#案例（九九乘法表）" class="headerlink" title="案例（九九乘法表）"></a><strong>案例（九九乘法表）</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;九九乘法表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;table&gt;</span><br><span class="line">		<span class="meta">&lt;?php</span> <span class="keyword">for</span> ($i=<span class="number">1</span>; $i &lt;= <span class="number">9</span>; $i++):<span class="meta">?&gt;</span></span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				<span class="meta">&lt;?php</span> <span class="keyword">for</span> ($j = <span class="number">1</span>; $j &lt; $i; $j++):<span class="meta">?&gt;</span></span><br><span class="line">					&lt;td&gt;</span><br><span class="line">						<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">"$j * $i = "</span>.$j * $i;<span class="meta">?&gt;</span></span><br><span class="line">					&lt;/td&gt;</span><br><span class="line">				<span class="meta">&lt;?php</span> <span class="keyword">endfor</span>;<span class="meta">?&gt;</span></span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">		<span class="meta">&lt;?php</span> <span class="keyword">endfor</span>;<span class="meta">?&gt;</span></span><br><span class="line">	&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">(参数)</span></span>&#123;</span><br><span class="line">    函数体(代码块);</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：<code>函数名()</code>，即可。</p>
<p>return可以返回任何类型的数据。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>如果实际传入的参数没有提供，则会使用默认值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($num1 = <span class="number">0</span>,$num2 = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的引用传递"><a href="#变量的引用传递" class="headerlink" title="变量的引用传递"></a>变量的引用传递</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($n1,&amp;$n2)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>函数允许使用时实参对于形参，只是不用而已，但实参不能少于形参。</p>
<p>下面介绍函数的一些高级用法。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="局部作用域（局部变量）"><a href="#局部作用域（局部变量）" class="headerlink" title="局部作用域（局部变量）"></a>局部作用域（局部变量）</h4><p>在其他结构（函数）内部定义的作用域。</p>
<h4 id="全局作用域（全局变量）"><a href="#全局作用域（全局变量）" class="headerlink" title="全局作用域（全局变量）"></a>全局作用域（全局变量）</h4><p>未在其他结构（函数）内部定义的作用域。</p>
<h4 id="超全局作用域（超全局变量）"><a href="#超全局作用域（超全局变量）" class="headerlink" title="超全局作用域（超全局变量）"></a>超全局作用域（超全局变量）</h4><p>即在脚本中的任意位置。</p>
<p>超全局变量：系统定义的预定义变量。</p>
<p>全局变量会自动吸纳到超全局``$GLOBALS`，可以利用超全局变量来保存数据，让数据不受作用域限制。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时是给超全局变量增加一个var元素，相当于定义了一个全局变量。</span></span><br><span class="line">$GLOBALS[<span class="string">'var'</span>] = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$v1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//echo $v1;报错</span></span><br><span class="line">    <span class="keyword">echo</span> $GLOBALS[<span class="string">'v1'</span>];<span class="comment">//在函数体内使用超全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>$GLOBALS会自动包含全局变量，同时还有以下超全局变量。</p>
<ul>
<li>$_GET：自动接收GET提交的数据</li>
<li>$_POST：自动接收POST提交的数据</li>
<li>$_COOKIE：自动接收cookie数据</li>
<li>$_FILES：自动接收文件上传的数据</li>
<li>$GLOBALS：自己包含自己</li>
</ul>
<h4 id="一个特殊的关键字global"><a href="#一个特殊的关键字global" class="headerlink" title="一个特殊的关键字global"></a>一个特殊的关键字global</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$v1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $v1;</span><br><span class="line">    <span class="keyword">echo</span> $v1;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>其含义是在函数内定义一个局部变量，并且与全局变量同名，处于“引用关系”，可以直接使用。</p>
<p><strong>总结</strong>：$GLOBALS数组（变量）和global关键字都能实现：在局部作用域使用全局变量。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>概念：在函数内部定义，可以在函数多次调用时共用的局部变量</p>
<ul>
<li>使用static关键字修饰</li>
<li>是在函数内部定义的局部变量</li>
<li>在函数加载时初始化（只初始化一次）</li>
<li>可以在同一个函数多次调用时共享数据的变化</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">#记录函数被调用了多少次</span></span><br><span class="line">    $count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> $count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> ++$count1,++$count2,<span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display();<span class="comment">#11</span></span><br><span class="line">display();<span class="comment">#12</span></span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ul>
<li>数据需要函数多次共享</li>
<li>递归存储数据的时候</li>
</ul>
<h3 id="强制类型"><a href="#强制类型" class="headerlink" title="强制类型"></a>强制类型</h3><p>PHP可以利用强类型来规范函数的输入（参数）和输出（返回值）</p>
<ul>
<li>强类型参数</li>
<li>强类型返回值</li>
</ul>
<h4 id="强类型参数"><a href="#强类型参数" class="headerlink" title="强类型参数"></a>强类型参数</h4><p>在定义函数时给形参设定类型</p>
<ul>
<li><p>类型规范是PHP的8种类型</p>
</li>
<li><p>强类型的作用</p>
<ul>
<li>实参必须是形参规定类型</li>
<li>保护函数内部运行逻辑正确</li>
<li>省区函数内部判定逻辑</li>
<li>提升解析效率</li>
</ul>
</li>
<li><p>强类型语法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">(类型 变量名)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(float $a,float $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强类型的选择</p>
<ul>
<li>PHP是弱类型语言，会自动转换类型，一般可以不用。    </li>
<li>不想在内部进行过多的逻辑判断，可以适用强类型参数进行限定。</li>
</ul>
</li>
</ul>
<h4 id="强类型返回值"><a href="#强类型返回值" class="headerlink" title="强类型返回值"></a>强类型返回值</h4><p>指在函数定义时就规定好函数的返回值类型</p>
<ul>
<li><p>强类型是PHP的8种类型</p>
</li>
<li><p>强类型规定后，函数内部的返回值必须是指定类型</p>
</li>
<li><p>想让强类型完全生效，需要提前声明</p>
<ul>
<li>declare(strict_types = 1)</li>
</ul>
</li>
<li><p>强类型返回值语法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">()</span>:返回值类型</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_int</span><span class="params">($n)</span>:<span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_integer($n))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>PHP提供了一种对于参数不固定的处理方式</p>
<ul>
<li>PHP在5.6以后提供了一种主动获取多余的实参的方式</li>
<li>可以使用<code>...</code>符号实现数组数据的拆分</li>
</ul>
<p><strong>实例：求两个（或多个）数的和</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数：多余的形参使用...$args保存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_sum</span><span class="params">($a,$b,...$args)</span></span>&#123;</span><br><span class="line">    <span class="comment">#2、$args会接受多出的参数（$a和$b为固定参数）</span></span><br><span class="line">    <span class="comment">#3、在函数内部可以使用$args访问多出的实参</span></span><br><span class="line">    $sum = $a + $b;</span><br><span class="line">    <span class="keyword">foreach</span>($args <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        $sum += $v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以将实参数组拆分构成多个数据</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_sub</span><span class="params">($a,$b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a = $b;</span><br><span class="line">&#125;</span><br><span class="line">$arr = [<span class="number">10</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">echo</span> my_sub(...$arr);<span class="comment">#输出6</span></span><br></pre></td></tr></table></figure>

<p>获取所有参数的和</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $num = func_get_args();<span class="comment">//获取参数，是一个数组变量，保存在num中</span></span><br><span class="line">    $count = count($num);<span class="comment">//计算数组个数，即参数个数</span></span><br><span class="line">    <span class="comment">//$count = func_num_args();获取参数个数</span></span><br><span class="line">    $sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>;$i&lt;$count;$i++) &#123;</span><br><span class="line">        $sum+=$num[$i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $sum;</span><br><span class="line">&#125;</span><br><span class="line">$sum = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'可变参数和：'</span>.$sum;</span><br></pre></td></tr></table></figure>

<h3 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h3><p>即一个变量所保存的值刚好是另外一个函数的名字，那么可以通过变量直接访问函数</p>
<ul>
<li>变量的值是一个函数名（字符串）</li>
<li>变量+()就可以当作函数名访问函数</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'hello world!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$var = <span class="string">'display'</span>;<span class="comment">#变量名为一个函数的名字</span></span><br><span class="line"></span><br><span class="line">$var();<span class="comment">#即调用display()函数</span></span><br></pre></td></tr></table></figure>

<p>实际运用：通常我们是将自定义的函数作为系统函数或者其他位置的回调函数（callback）使用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#取得一个数的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jdz</span><span class="params">($n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $n &lt; <span class="number">0</span> ? -$n : $n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#求两个数的绝对值的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum_jdz</span><span class="params">($a,$b,$func)</span></span>&#123;</span><br><span class="line">    <span class="comment">#利用外部的$func函数(回调函数)来实现$a和$b的绝对值求和</span></span><br><span class="line">    <span class="keyword">return</span> $func($a) + $func($b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> sum_jdz(<span class="number">-1</span>,<span class="number">-1</span>,<span class="string">'jdz'</span>);<span class="comment">#输出2</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li>简单匿名函数</li>
<li>回调匿名函数</li>
<li>匿名函数闭包</li>
</ul>
<h4 id="简单匿名函数"><a href="#简单匿名函数" class="headerlink" title="简单匿名函数"></a>简单匿名函数</h4><p>即函数没有名字，使用变量保存函数的内存地址</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">变量 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">变量();</span><br></pre></td></tr></table></figure>

<h4 id="回调匿名函数"><a href="#回调匿名函数" class="headerlink" title="回调匿名函数"></a>回调匿名函数</h4><p>指直接将匿名函数定义在函数的实参中，当作一个实参传递给形参</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#求数组元素的所有立方</span></span><br><span class="line">$arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">#定义一个函数：能够取得数组的所有立方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_cube</span><span class="params">($arr,$cube)</span></span>&#123;</span><br><span class="line">    $list = [];<span class="comment">#存储结果</span></span><br><span class="line">    <span class="keyword">foreach</span>($arr <span class="keyword">as</span> $value)&#123;</span><br><span class="line">        $list[] = $cube($value);<span class="comment">#调用计算立方的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#直接传一个匿名函数</span></span><br><span class="line">$res = my_cube($arr,<span class="function"><span class="keyword">function</span><span class="params">($num)</span></span>&#123;<span class="keyword">return</span> $num ** <span class="number">3</span>;&#125;);</span><br><span class="line">print_r($res);</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数闭包"><a href="#匿名函数闭包" class="headerlink" title="匿名函数闭包"></a>匿名函数闭包</h4><p><strong>概念</strong></p>
<p>闭包是一个定义在函数内，能都读取其他函数内部变量的函数（闭包函数）</p>
<ul>
<li>函数定义在某个函数内部</li>
<li>内部函数是匿名函数</li>
<li>内部函数访问外部函数的局部变量<ul>
<li>不能直接访问，访问需要使用use关键字</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    $inner = <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> $str;</span><br><span class="line">    &#125;;</span><br><span class="line">    $inner();</span><br><span class="line">&#125;</span><br><span class="line">outer(<span class="string">'hello world!'</span>);<span class="comment">#输出hello world!</span></span><br></pre></td></tr></table></figure>

<p>闭包函数可以返回给外部函数调用，这样可以使得闭包所占用的外部函数资源不被释放</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    $inner = <span class="function"><span class="keyword">function</span><span class="params">($s)</span> <span class="title">use</span> <span class="params">($str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> $str.$s;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> $inner;</span><br><span class="line">&#125;</span><br><span class="line">$res = outer(<span class="string">'hello'</span>);</span><br><span class="line">$res(<span class="string">'world'</span>);<span class="comment">#输出helloworld</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<ul>
<li>函数outer调用结束，没有释放内存</li>
<li>outer返回了一个内部闭包函数的引用，所以函数不会释放</li>
<li>$inner内部闭包函数引用了一个外部函数的局部变量，所以outer也不能释放$str</li>
<li>$res(‘world’)找到函数执行，并且应用了之前函数的局部变量$str，所以组合输出helloworld。</li>
</ul>
<h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><p><strong>常用的系统函数列表</strong></p>
<h3 id="1、常见输出类"><a href="#1、常见输出类" class="headerlink" title="1、常见输出类"></a>1、常见输出类</h3><ul>
<li>echo：不需要使用括号</li>
<li>print_r：输出变量的结构</li>
<li>var_dump：详细打印变量的结构和数据</li>
<li>exit/die：输出消息并终止脚本执行</li>
</ul>
<h3 id="2、常见日期类"><a href="#2、常见日期类" class="headerlink" title="2、常见日期类"></a>2、常见日期类</h3><ul>
<li><p>time：获取当前时间的时间戳（从格林威治时间1970年1月1日），精确到秒（一个整数）</p>
</li>
<li><p>date：按照指定格式输出时间，可以是当前时间也可以是指定时间戳</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> date(<span class="string">"当前时间：Y-m-d H:i:s"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>strtotime：将任何英文文本日期时间描述转换成时间戳</p>
</li>
<li><p>micotime：获取时间戳和微秒数（精度高），两个用法：</p>
<ul>
<li>micotime(true)：获取秒数，浮点型。</li>
<li>micotime(false)：获取秒数，字符串型。默认不写参数为false。</li>
</ul>
</li>
</ul>
<h3 id="3、数学类"><a href="#3、数学类" class="headerlink" title="3、数学类"></a>3、数学类</h3><ul>
<li>max：获取多个数中最大值（可以实数组）</li>
<li>min：最小值</li>
<li>floor：舍去法取整（向下取整），获取不大于当前数值的最大整数</li>
<li>cell：进一取整（向上取整），获取不小于当前数值的最小整数</li>
<li>mt_rand：获取指定区间或者0到最大数之间的一个随机整数</li>
<li>round：根据指定小数位进行四舍五入</li>
<li>abs：绝对值</li>
<li>sqrt：开方</li>
<li>pow：幂次方的运算</li>
<li>rand、mt_rand：获取两个数之间的随机整数</li>
</ul>
<h3 id="4、字符串类"><a href="#4、字符串类" class="headerlink" title="4、字符串类"></a>4、字符串类</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>print：输出一个字符串</p>
<p>print_r：输出较为详细的信息</p>
<p>var_dump：输出完整信息</p>
<h4 id="字符串去除与填充"><a href="#字符串去除与填充" class="headerlink" title="字符串去除与填充"></a>字符串去除与填充</h4><p>trim：消除字符串两端的空白字符或指定字符</p>
<p>ltrim：左边</p>
<p>rtrim：右边</p>
<p>str_pad：将一个字符串使用指定的字符填充到指定的长度</p>
<h4 id="字符串连接与分割"><a href="#字符串连接与分割" class="headerlink" title="字符串连接与分割"></a>字符串连接与分割</h4><p>implode：将一个数组的值连接起来组成一个字符串，可以指定连接的符号</p>
<p>join：同上</p>
<p>explode：将一个字符串使用指定的字符分割为一个数组</p>
<p>str_split：将一个字符串按指定的长度分割为一个数组</p>
<h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><p>substr：获取一个字符串指定位置开始的指定长度的子串</p>
<p>strstr：获取一个字符串中某个指定字符首次出现的位置起，到最后结尾处的字符</p>
<p>strrchr：获取一个字符串中某个指定字符最后出现的位置起，到最后结尾处的字符</p>
<h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>str_replace：将一个字符串中的指定字符替换为新字符。</p>
<p>substr_replace：将一个字符串中指定位置开始的指定个数的字符，替换为给定的新字符。</p>
<h4 id="字符串长度与位置"><a href="#字符串长度与位置" class="headerlink" title="字符串长度与位置"></a>字符串长度与位置</h4><p>strlen：获取字符串的字节长度。</p>
<p>strpos：获取一个字符串中某个子串首次出现的位置。</p>
<p>strrpos：获取一个字符串中某个子串最后一次出现的位置。</p>
<h4 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h4><p>strtolower:转换为小写</p>
<p>strtoupper:转换为大写</p>
<p>lcfirst:首字母小写</p>
<p>ucfirst:首字母大写</p>
<p>ucwords:所有单词的首字母大写</p>
<h4 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h4><p>nl2br：将换行符转换为“&lt;br /&gt;”标签字符</p>
<p>addslashes：将一个字符串中的特数字符进行反斜杠转义。</p>
<p>htmlspecialchars：将html中的特殊字符转换为html实体字符。</p>
<p>htmlsecialchars_decode：将实体字符转换为原本的字符。</p>
<h3 id="5、数组类"><a href="#5、数组类" class="headerlink" title="5、数组类"></a>5、数组类</h3><p>max：获取数组中的最大值。</p>
<p>min：获取数组中的最小值。</p>
<p>count：获取数组的元素个数。</p>
<p>in_array：判断以恶数据是否在指定数组中。<code>$b = in_array(数组,数据);</code>结果为布尔。</p>
<p>range：生成某个范围的连续数组。例如range(3,6)得到数组array(3,4,5,6);</p>
<p>array_keys：取出所有键并放到一个索引数组中。</p>
<p>array_values：取出所有值并放到一个索引数组中。</p>
<p>array_push：将一个或多个数据放入一个数组的末端。</p>
<p>array_pop：将数组的最后一个单元删除，并返回该单元的值。</p>
<p>array_reverse：将数组反转。</p>
<h4 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h4><p>sort：由低到高、rsort：由高到低、asort、arsort等。</p>
<h4 id="数组的查找"><a href="#数组的查找" class="headerlink" title="数组的查找"></a>数组的查找</h4><p>in_array()：在一个数组中找是否存在某个数据。</p>
<p>array_search()：在数组中搜索给定的值，如果成功则返回相应的键名。</p>
<p>array_key_exists()：检查给定的键名或索引是否存在于数组中。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/03/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式在平常的应用十分广泛，今日正式学习语法，力求好好掌握，以后能熟练使用。</p>
<a id="more"></a>

<hr>
<p>可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h4 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h4><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong><strong>*，简单的说就是表示任何字符串的意思。如果要查找字符串中的 *</strong></strong> 符号，则需要对 <strong>*** 进行转义，即在其前加一个 *<em>\: runo\</em>ob</strong> 匹配 runo*ob。</p>
<p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<table>
<thead>
<tr>
<th align="left">特别字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td align="left">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td align="left">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td align="left">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">指明两项之间的一个选择。要匹配 |，请使用 |。</td>
</tr>
</tbody></table>
<h3 id="限定符-几种重复的模式"><a href="#限定符-几种重复的模式" class="headerlink" title="限定符(几种重复的模式)"></a>限定符(几种重复的模式)</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <strong>*** 或 **+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p>
<p>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式<strong>零次或多次</strong>。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式<strong>一次或多次</strong>。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式<strong>零次或一次</strong>。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。<strong>至少匹配n 次</strong>。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">匹配除了换行符以外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配字母、数字、下划线或汉字</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配空白符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配数字</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配单词的开始或结束</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配字符串的开始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配字符串的结束</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>\b匹配单词，例如<code>\bgood\b</code>只会匹配good单词，而goodness则不会被匹配。</p>
<h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\W</td>
<td align="center">匹配不是字母、数字、下划线或汉字的字符</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配不是空白符的字符</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">匹配不是数字的字符</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td align="center">[^x]</td>
<td align="center">匹配除了x意外的所有字符</td>
</tr>
<tr>
<td align="center">[^abcd]</td>
<td align="center">匹配除了abcd以外的任意字符</td>
</tr>
</tbody></table>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><code>\.</code>、<code>\*</code>、<code>\?</code>  、<code>\(</code>、<code>\)</code>等</p>
<h3 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h3><ul>
<li>用<code>|</code>把不同的规则分隔开</li>
<li>从左到右的测试每个条件，如果满足了某个分支，就不再管其他的条件。</li>
<li><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code></li>
</ul>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul>
<li><p><code>[0-9] == \d</code></p>
</li>
<li><p><code>[a-z0-9A-Z] == \w</code></p>
</li>
<li><p><code>[&amp;?.]</code>：标点符号等。</p>
</li>
<li><p><code>[aeiou]</code></p>
</li>
<li><p><code>\(?0\d{2}[)-]?\d{8}</code></p>
</li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><p>将子表达式做成子集</p>
</li>
<li><p>使用()进行分组</p>
</li>
<li><p>方便对match的字符串进行划分</p>
</li>
<li><p>分组的命名：<code>(?&lt;groupname&gt;exp)</code></p>
</li>
<li><p><code>(?:exp)</code>：exp表达式 ，匹配exp，不捕获匹配的文本，也不给此分组分配组号。</p>
</li>
</ul>
<h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><h4 id="贪婪（尽可能多）"><a href="#贪婪（尽可能多）" class="headerlink" title="贪婪（尽可能多）"></a>贪婪（尽可能多）</h4><p><code>a.*b(aabab)</code>-&gt;<code>aabab</code></p>
<h4 id="懒惰（尽可能少）"><a href="#懒惰（尽可能少）" class="headerlink" title="懒惰（尽可能少）"></a>懒惰（尽可能少）</h4><p><code>a.*?b(aabab)</code>-&gt;<code>aab</code>、<code>ab</code></p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*?</td>
<td align="center">重复任意次，但尽可能少</td>
</tr>
<tr>
<td align="center">+?</td>
<td align="center">重复一次或多次，但尽可能少</td>
</tr>
<tr>
<td align="center">??</td>
<td align="center">重复一次或0次，但尽可能少</td>
</tr>
<tr>
<td align="center">{n,m}?</td>
<td align="center">重复n到m次，但尽可能少</td>
</tr>
<tr>
<td align="center">{n,}?</td>
<td align="center">重复n次以上，但尽可能少</td>
</tr>
</tbody></table>
<h3 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h3><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IgnoreCase</td>
<td align="center">不区分大小写</td>
</tr>
<tr>
<td align="center">Multiline</td>
<td align="center">更改^和$的含义，使其在任意一行都可匹配。<br>$的含义是匹配\n之前的位置</td>
</tr>
<tr>
<td align="center">Singleline</td>
<td align="center">更改.的含义，与每个字符匹配（包括换行符\n）</td>
</tr>
<tr>
<td align="center">IgnorePatternWhitespace</td>
<td align="center">忽略表达式中的非转义空白并启用由#标记的注释</td>
</tr>
<tr>
<td align="center">ExplicitCapture</td>
<td align="center">仅捕获已被显式命名的组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_3(列表元组)</title>
    <url>/2020/03/24/Python-3/</url>
    <content><![CDATA[<p>基于上次对<strong>选择循环</strong>结构，和<strong>字符串</strong>的基础知识介绍，这篇博客总结<strong>列表</strong>和<strong>元组</strong>的使用。</p>
<a id="more"></a>

<hr>
<h1 id="一、列表"><a href="#一、列表" class="headerlink" title="一、列表"></a>一、列表</h1><p>列表用来一次性存储多个数据。</p>
<h2 id="1、列表格式"><a href="#1、列表格式" class="headerlink" title="1、列表格式"></a>1、列表格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[数据<span class="number">1</span>, 数据<span class="number">2</span>, 数据<span class="number">3</span>, 数据<span class="number">4.</span>..];</span><br></pre></td></tr></table></figure>

<p>列表存储的多个数据可为不同类型，但为了相关操作，尽量存储相同数据类型的数据。</p>
<h2 id="2、列表的常用操作"><a href="#2、列表的常用操作" class="headerlink" title="2、列表的常用操作"></a>2、列表的常用操作</h2><p>对列表中的多个数据实现增、删、改、查等基本操作。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">'Tom'</span>,<span class="string">'Rose'</span>,<span class="string">'Lily'</span>];</span><br><span class="line">print(name_list[<span class="number">1</span>]); <span class="comment"># Rose</span></span><br><span class="line">print(name_list[<span class="number">-1</span>]);<span class="comment"># Lily</span></span><br><span class="line"></span><br><span class="line">list2 = [<span class="string">'hello'</span>] * <span class="number">3</span></span><br><span class="line">print(list2) <span class="comment"># ['hello', 'hello', 'hello']</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><p>index()：返回指定数据所在位置的下标</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.index(数据,开始位置下标,结束位置下标) <span class="comment">#如果不写开始结束下标，则代表全部</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(name_list.index(<span class="string">'Lily'</span>,<span class="number">0</span>,<span class="number">2</span>)) <span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果找不到数据则会报错</p>
</blockquote>
</li>
<li><p>count()：统计指定数据在当前列表中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(name_list.count(<span class="string">'Lily'</span>)); <span class="comment">#1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>len()：访问列表长度，即列表中数据的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(len(name_list)); <span class="comment">#3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>len()是一个公共函数，字符串、列表等都可以用该方法统计个数</p>
</blockquote>
</li>
</ul>
<h4 id="判断指定数据是否存在"><a href="#判断指定数据是否存在" class="headerlink" title="判断指定数据是否存在"></a>判断指定数据是否存在</h4><ul>
<li>in：判断指定数据存在于列表序列中，返回bool</li>
<li>not in：相反。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Tom'</span> <span class="keyword">in</span> name_list); <span class="comment">#True</span></span><br></pre></td></tr></table></figure>

<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>增加数据到列表中</p>
<ul>
<li><p>append()：列表结尾追加数据</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.append(数据)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list.append(<span class="string">'xiaoming'</span>);</span><br><span class="line">print(name_list) <span class="comment">#['Tom','Rose','Lily','xiaoming']</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变数据类型</p>
</blockquote>
</li>
<li><p>extend()：结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表中</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.extend(数据)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list.extend(<span class="string">'xiaoming'</span>); <span class="comment">#['Tom','Rose','Lily','x','i','a','o','m','i','n','g']</span></span><br><span class="line">name_list.extend([<span class="string">'xiaoming'</span>,<span class="string">'xiaoming'</span>]) <span class="comment">#['Tom','Rose','Lily','xiaoming','xiaoming']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>insert()：指定位置新增序列</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.insert(位置下标,数据)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list.insert(<span class="number">1</span>,<span class="string">'xiaoming'</span>) <span class="comment">#['Tom','xiaoming','Rose','Lily']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p>del</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 目标</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除指定数据</span></span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 删除列表</span></span><br><span class="line"><span class="keyword">del</span> name_list</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()：删除指定下标的数据（默认最后一个），并返回该数据。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.pop(下标)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">del_name = name_list.pop(<span class="number">1</span>) <span class="comment"># Rose</span></span><br><span class="line">print(name_list) <span class="comment"># ['Tom','Lily']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()：移除列表中某个数据的第一个匹配项。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.remove(数据)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list.remove(<span class="string">'Rose'</span>)  <span class="comment"># ['Tom','Lily']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>clear()：清空列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list.clear()</span><br><span class="line">print(name_list) <span class="comment"># 结果：[]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li><p>修改指定下标数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list[<span class="number">0</span>] = <span class="string">'Test'</span> <span class="comment"># ['Test','Rose','Lily']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逆置：reverse()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">num_list.reverse() <span class="comment"># [3,2,1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序：sort()</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.sort(key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：reverse表示排序规则，reverse = False 升序（默认），reverse = True 降序，</p>
</blockquote>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序，[3,2,1]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>函数：copy()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = name_list.copy()</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>和字符串一样，也可切片等。</p>
<h2 id="3、列表的循环遍历"><a href="#3、列表的循环遍历" class="headerlink" title="3、列表的循环遍历"></a>3、列表的循环遍历</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; len(name_list):</span><br><span class="line">    print(name_list[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name_list:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h2 id="4、列表嵌套"><a href="#4、列表嵌套" class="headerlink" title="4、列表嵌套"></a>4、列表嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br></pre></td></tr></table></figure>

<h1 id="二、元组"><a href="#二、元组" class="headerlink" title="二、元组"></a>二、元组</h1><p>一个元组可以存储多个数据，元组内的数据是不能修改的。</p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#定义多个数据的元组</span></span><br><span class="line">t2 = (<span class="number">1</span>,) <span class="comment">#定义单个数据元组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：一个数据的元组，后面最好跟上一个逗号，否则数据类型为唯一的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t3 = (<span class="number">1</span>,) <span class="comment">#tuple</span></span><br><span class="line">t4 = (<span class="number">1</span>) <span class="comment">#int</span></span><br><span class="line">t5 = (<span class="string">'hello'</span>) <span class="comment">#str</span></span><br></pre></td></tr></table></figure>

<h2 id="2、元组的常见操作"><a href="#2、元组的常见操作" class="headerlink" title="2、元组的常见操作"></a>2、元组的常见操作</h2><p>元组数据不支持修改，只支持查找操作，具体如下：</p>
<ul>
<li>按下标查找数据</li>
<li>index()</li>
<li>count()</li>
<li>len()</li>
</ul>
<p>与上述介绍列表查找方法基本相同。</p>
<h2 id="3、元组数据的修改"><a href="#3、元组数据的修改" class="headerlink" title="3、元组数据的修改"></a>3、元组数据的修改</h2><ul>
<li><p>元组内的直接数据如果修改则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">1</span>  <span class="comment">#报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果元组内有列表，修改列表里的数据则是支持的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple2 = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>)</span><br><span class="line">tuple2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span> <span class="comment">#支持</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>尽量不要修改元组内的数据</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB课程总结（三）</title>
    <url>/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>这篇总结MATLAB的图形基础。</p>
<a id="more"></a>

<hr>
<h1 id="二维曲线绘图的基本操作"><a href="#二维曲线绘图的基本操作" class="headerlink" title="二维曲线绘图的基本操作"></a>二维曲线绘图的基本操作</h1><h2 id="plot指令的基本调用格式"><a href="#plot指令的基本调用格式" class="headerlink" title="plot指令的基本调用格式"></a>plot指令的基本调用格式</h2><h3 id="plot-x"><a href="#plot-x" class="headerlink" title="plot(x)"></a>plot(x)</h3><p>​    ◼ x为向量时，以该元素的下标为横坐标、元素值为纵坐标绘出曲线。</p>
<p>​    ◼ x为实数二维数组时，则按列绘制每列元素值相对其下标的曲线，曲线数</p>
<p>​        等于x数组的列数。</p>
<p>​    ◼ x为复数二维数组时，则按列分别以数组的实部和虚部为横、纵坐标绘制多条曲线</p>
<h3 id="plot-x-y"><a href="#plot-x-y" class="headerlink" title="plot(x, y)"></a>plot(x, y)</h3><p>​    ◼ x、y为同维数组时，绘制以x、y元素为横纵坐标的曲线</p>
<p>​    ◼ x为向量，y为二维数组、且其列数或行数等于x的元素数时，绘制多条不同颜色的曲线</p>
<p>​    ◼ x为二维数组，y为向量时，情况与上相同，只是y仍为纵坐标。</p>
<h3 id="plot-x1-y1-x2-y2-…"><a href="#plot-x1-y1-x2-y2-…" class="headerlink" title="plot(x1, y1, x2, y2, …)"></a>plot(x1, y1, x2, y2, …)</h3><p>​    ◼ 绘制以x1为横坐标、y1为纵坐标的曲线1，以x2为横坐标、y2为纵坐标的曲线2，等等。</p>
<p>​    ◼ 其中x为横坐标，y为纵坐标，绘制y=f(x)函数曲线。</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="1、使用直角坐标系"><a href="#1、使用直角坐标系" class="headerlink" title="1、使用直角坐标系"></a>1、使用直角坐标系</h4><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/1.png" class>

<h4 id="2、使用参数方程绘制曲线"><a href="#2、使用参数方程绘制曲线" class="headerlink" title="2、使用参数方程绘制曲线"></a>2、使用参数方程绘制曲线</h4><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/2.png" class>

<h4 id="3、绘制复杂曲线"><a href="#3、绘制复杂曲线" class="headerlink" title="3、绘制复杂曲线"></a>3、绘制复杂曲线</h4><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/3.png" class>

<p>结果：</p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/4.png" class>

<h2 id="多次叠绘"><a href="#多次叠绘" class="headerlink" title="多次叠绘"></a>多次叠绘</h2><p>◼ 多次调用plot命令在一幅图上绘制多条曲线，需要hold指令的配合。</p>
<p>◼ hold on 保持当前坐标轴和图形，并可以接受下一次绘制。</p>
<p>◼ hold off 取消当前坐标轴和图形保持，这种状态下，调用plot绘制完全新的图形，不保留以前的坐标格式、曲</p>
<p>线。</p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a><strong>例题1</strong></h3><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/5.png" class>

<p><strong>结果</strong></p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/6.png" class>

<h3 id="例题2：利用hold绘制离散信号的波形"><a href="#例题2：利用hold绘制离散信号的波形" class="headerlink" title="例题2：利用hold绘制离散信号的波形"></a><strong>例题2：利用hold绘制离散信号的波形</strong></h3><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/7.png" class>

<h2 id="双纵坐标"><a href="#双纵坐标" class="headerlink" title="双纵坐标"></a>双纵坐标</h2><p>◼ plotyy指令调用格式：</p>
<p>plotyy(x1, y1, x2, y2)</p>
<p>x1-y1曲线y轴在左， x2-y2曲线y轴在右。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/8.png" class>

<h2 id="多子图"><a href="#多子图" class="headerlink" title="多子图"></a>多子图</h2><p> MATLAB允许在同一图形窗口布置几幅独立的子图。具体指令：</p>
<p>◼ subplot(m, n, k)使（mxn）幅子图中第k个子图成为当前图</p>
<p>◼ subplot(‘postion’, [left, bottom, width, height]) 在指定的位置上开辟子图，并成为当前图</p>
<p>说明：</p>
<p>➢ subplot(m, n, k)的含义：图形窗口包含（mxn）个子图，k为要指定的当前子图的编号。其编号原则： 左上方为第1子图，然后向右向下依次排序。该指令按缺省值分割子图区域。</p>
<p>➢ subplot(‘postion’, [left, bottom, width, height])用于手工指定子图位置，指定位置的四元组采用归一化的标称单位，即认为整个图形窗口绘图区域的高、宽的取值范围都是[0， 1]，而左下角为（0,0）坐标。</p>
<p>➢ 产生的子图彼此独立。所有的绘图指令均可以在子图中使用。</p>
<p><strong>示例</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=(<span class="built_in">pi</span>*(<span class="number">0</span>:<span class="number">1000</span>)/<span class="number">1000</span>)';</span><br><span class="line">y1=<span class="built_in">sin</span>(t);y2=<span class="built_in">sin</span>(<span class="number">10</span>*t);y12=<span class="built_in">sin</span>(t).*<span class="built_in">sin</span>(<span class="number">10</span>*t);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),<span class="built_in">plot</span>(t,y1);axis([<span class="number">0</span>,<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),<span class="built_in">plot</span>(t,y2);axis([<span class="number">0</span>,<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>])</span><br><span class="line">subplot(<span class="string">'position'</span>,[<span class="number">0.2</span>,<span class="number">0.05</span>,<span class="number">0.6</span>,<span class="number">0.45</span>])</span><br><span class="line"><span class="built_in">plot</span>(t,y12,<span class="string">'b-'</span>,t,[y1,-y1],<span class="string">'r:'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/9.png" class>

<h2 id="绘制曲线的辅助操作"><a href="#绘制曲线的辅助操作" class="headerlink" title="绘制曲线的辅助操作"></a>绘制曲线的辅助操作</h2><p><strong>曲线线形控制符</strong></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">-</th>
<th align="center">：</th>
<th align="center">-.</th>
<th align="center">–</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">实线</td>
<td align="center">虚线</td>
<td align="center">点划线</td>
<td align="center">双划线</td>
</tr>
</tbody></table>
<p><strong>曲线颜色控制符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>b</th>
<th>g</th>
<th>r</th>
<th>c</th>
<th>m</th>
<th>y</th>
<th>k</th>
<th>w</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>蓝</td>
<td>绿</td>
<td>红</td>
<td>青</td>
<td>品红</td>
<td>黄</td>
<td>黑</td>
<td>白</td>
</tr>
</tbody></table>
<p>；数据点型控制符</p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/10.png" class>

<p>➢曲线的线形控制符、颜色控制符、数据点形控制符可以组合使用</p>
<p>➢其先后次序不影响绘图结果</p>
<p>➢也可以单独使用</p>
<p><strong>例如</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">0</span>:<span class="number">15</span>)*<span class="number">2</span>*<span class="built_in">pi</span>/<span class="number">15</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>), <span class="built_in">plot</span>(t, y); title(<span class="string">'Lins style is default'</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>), <span class="built_in">plot</span>(t, y, <span class="string">'o'</span>); title(<span class="string">'Lins style is o'</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="built_in">plot</span>(t, y, <span class="string">'k:'</span>); title(<span class="string">'Lins style is k:'</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>), <span class="built_in">plot</span>(t, y, <span class="string">'k:*'</span>); title(<span class="string">'Lins style is k:*'</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>), <span class="built_in">plot</span>(t, y, <span class="string">'m-d'</span>); title(<span class="string">'Lins style is m-d'</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>), <span class="built_in">plot</span>(t, y, <span class="string">'r-p'</span>); title(<span class="string">'Lins style is r-p'</span>)</span><br></pre></td></tr></table></figure>

<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/11.png" class>

<h2 id="坐标、刻度和分格线控制"><a href="#坐标、刻度和分格线控制" class="headerlink" title="坐标、刻度和分格线控制"></a><strong>坐标、刻度和分格线控制</strong></h2><h3 id="axis坐标控制指令"><a href="#axis坐标控制指令" class="headerlink" title="axis坐标控制指令"></a>axis坐标控制指令</h3><p><strong>案例演示</strong></p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/12.png" class>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="number">2</span>*<span class="built_in">pi</span>/<span class="number">99</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="number">1.15</span>*<span class="built_in">cos</span>(t); y=<span class="number">3.25</span>*<span class="built_in">sin</span>(t); <span class="comment">% y为长轴，x为短轴</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); <span class="built_in">plot</span>(x, y);</span><br><span class="line">axis off</span><br><span class="line">title(<span class="string">'axis off'</span>); </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); <span class="built_in">plot</span>(x,y);</span><br><span class="line">axis image;</span><br><span class="line">title(<span class="string">'axis image'</span>); </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="built_in">plot</span>(x,y);</span><br><span class="line">axis equal;</span><br><span class="line">title(<span class="string">'axis Equal'</span>); </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); <span class="built_in">plot</span>(x,y);</span><br><span class="line">axis square;</span><br><span class="line">title(<span class="string">'axis Square'</span>);</span><br></pre></td></tr></table></figure>

<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/13.png" class>

<h3 id="刻度、分格线和坐标框"><a href="#刻度、分格线和坐标框" class="headerlink" title="刻度、分格线和坐标框"></a>刻度、分格线和坐标框</h3><h4 id="刻度设置"><a href="#刻度设置" class="headerlink" title="刻度设置"></a>刻度设置</h4><ul>
<li><p><strong>指令及格式：</strong><code>set(gca, ‘xtick’, xs, ‘ytick’, ys)</code></p>
</li>
<li><p>xs、ys可以使任何合法的实数向量，用于分别设置x、y轴的刻度。</p>
</li>
</ul>
<h4 id="分格线"><a href="#分格线" class="headerlink" title="分格线"></a>分格线</h4><p>使用grid指令</p>
<ul>
<li>grid on /grid off：画出/不画出分格线</li>
<li>MATLAB的缺省设置是不画分格线；分格线的疏密取决于坐标刻度（改变坐标刻度，可改变分格线的疏密）。</li>
</ul>
<p>坐标框</p>
<ul>
<li>box on：控制加边框线</li>
<li>box off：控制不加边框线</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=<span class="number">6</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:<span class="number">100</span>)/<span class="number">100</span>;</span><br><span class="line">y=<span class="number">1</span>-<span class="built_in">exp</span>(<span class="number">-0.3</span>*t).*<span class="built_in">cos</span>(<span class="number">0.7</span>*t);</span><br><span class="line">tt=t(<span class="built_in">find</span>(<span class="built_in">abs</span>(y<span class="number">-1</span>)&gt;<span class="number">0.05</span>)); </span><br><span class="line">ts=<span class="built_in">max</span>(tt); </span><br><span class="line"><span class="built_in">plot</span>(t,y,<span class="string">'r-'</span>);</span><br><span class="line">grid on; </span><br><span class="line">axis([<span class="number">0</span>,<span class="number">6</span>*<span class="built_in">pi</span>,<span class="number">0.6</span>,<span class="built_in">max</span>(y)]); </span><br><span class="line">title(<span class="string">'y=1-exp(-\alpha*t)*cos(\omega*t)'</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(ts,<span class="number">0.95</span>,<span class="string">'bo'</span>);</span><br><span class="line"><span class="built_in">hold</span> off; </span><br><span class="line">set(gca,<span class="string">'xtick'</span>,[<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">4</span>*<span class="built_in">pi</span>,<span class="number">6</span>*<span class="built_in">pi</span>],<span class="string">'ytick'</span>,[<span class="number">0.95</span>,<span class="number">1</span>,<span class="number">1.05</span>,<span class="built_in">max</span>(y)]); </span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/14.png" class>

<h2 id="图形标识"><a href="#图形标识" class="headerlink" title="图形标识"></a>图形标识</h2><h3 id="图形标识包括"><a href="#图形标识包括" class="headerlink" title="图形标识包括"></a>图形标识包括</h3><ul>
<li><p>图名（title）</p>
</li>
<li><p>坐标轴名（xlabel、ylabel）</p>
</li>
<li><p>图形文本注释（text）</p>
</li>
<li><p>图例（legend）</p>
</li>
</ul>
<h3 id="简捷使用格式"><a href="#简捷使用格式" class="headerlink" title="简捷使用格式"></a>简捷使用格式</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">title(s),xlabel(s),ylabel(s),text(s),<span class="built_in">legend</span>(s) <span class="comment">% s为字符串</span></span><br><span class="line">text(x,y,s) 						<span class="comment">% 指定坐标（x, y）处加注文字</span></span><br></pre></td></tr></table></figure>

<h3 id="精细指令形式"><a href="#精细指令形式" class="headerlink" title="精细指令形式"></a>精细指令形式</h3><p><strong>字体样式设置：</strong></p>
<p><code>\fontname{arg} \arg \fontsize {arg} string</code>，其中，String为要输出的字符串，其前面的均为属性控制，使用方法见下表。</p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/15.png" class> <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/16.png" class>

<h3 id="案例：在正弦曲线上标注特殊值"><a href="#案例：在正弦曲线上标注特殊值" class="headerlink" title="案例：在正弦曲线上标注特殊值"></a>案例：在正弦曲线上标注特殊值</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">0</span>:<span class="number">100</span>)/<span class="number">100</span>*<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(t, y)</span><br><span class="line">text(<span class="number">3</span>*<span class="built_in">pi</span>/<span class="number">4</span>,<span class="built_in">sin</span>(<span class="number">3</span>*<span class="built_in">pi</span>/<span class="number">4</span>), <span class="string">'\fontsize&#123;16&#125;\leftarrowsin(t) = .707 '</span>)</span><br><span class="line">text(<span class="built_in">pi</span>, <span class="built_in">sin</span>(<span class="built_in">pi</span>), <span class="string">'\fontsize&#123;16&#125;\leftarrowsin(t) = 0 '</span>)</span><br><span class="line">text(<span class="number">5</span>*<span class="built_in">pi</span>/<span class="number">4</span>, <span class="built_in">sin</span>(<span class="number">5</span>*<span class="built_in">pi</span>/<span class="number">4</span>), <span class="string">'\fontsize&#123;16&#125;sin(t) = -.707\rightarrow'</span>,...</span><br><span class="line"><span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>)</span><br></pre></td></tr></table></figure>

<p>其中，‘HorizontalAlignment’, ‘right’设置图形标识为水平右对齐.</p>
 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/17.png" class>

<h2 id="极坐标图"><a href="#极坐标图" class="headerlink" title="极坐标图"></a>极坐标图</h2><p>polar函数用来绘制极坐标图，其调用格式为：</p>
<p><code>polar(theta,rho,选项)</code></p>
<h3 id="例：绘制ρ-sin-2θ-cos-2θ-的图形"><a href="#例：绘制ρ-sin-2θ-cos-2θ-的图形" class="headerlink" title="例：绘制ρ=sin(2θ)cos(2θ)的图形"></a>例：绘制ρ=sin(2θ)cos(2θ)的图形</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">theta = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">rho = <span class="built_in">sin</span>(<span class="number">2</span>*theta).*<span class="built_in">cos</span>(<span class="number">2</span>*theta);</span><br><span class="line">polar(theta,rho,<span class="string">'k'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/18.png" class>

<h2 id="其他形式的线性直角坐标图"><a href="#其他形式的线性直角坐标图" class="headerlink" title="其他形式的线性直角坐标图"></a>其他形式的线性直角坐标图</h2><p>在线性直角坐标中，其他形式的图形有条形图、阶梯图、杆图和填充图等，所采用的函数分别为：</p>
<p>bar（x，y，选项）   选项在单引号中</p>
<p>stairs（x，y，选项）</p>
<p>stem（x，y，选项）</p>
<p>fill（x1，y1，选项1，x2，y2，选项2，…）</p>
<p>前三个函数和plot的用法相似，只是没有多输入变量形式。fill函数按向量元素下标渐增次序依次用直线段连接x，y对应元素定义的数据点。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.35</span>:<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);bar(x,y,<span class="string">'g'</span>);</span><br><span class="line"></span><br><span class="line">title(<span class="string">'bar(x,y,''g'')'</span>);axis([<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span> ,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);fill(x,y,<span class="string">'r'</span>);</span><br><span class="line"></span><br><span class="line">title(<span class="string">'fill(x,y,''r'')'</span>);axis([<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span> ,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);stairs(x,y,<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">title(<span class="string">'stairs(x,y,''b'')'</span>);axis([<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span> ,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);stem(x,y,<span class="string">'k'</span>);</span><br><span class="line"></span><br><span class="line">title(<span class="string">'stem(x,y,''k'')'</span>);axis([<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span> ,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/18.png" class>

<h2 id="折线图、柱状图、饼图"><a href="#折线图、柱状图、饼图" class="headerlink" title="折线图、柱状图、饼图"></a>折线图、柱状图、饼图</h2><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">1</span>:<span class="number">5</span>;<span class="comment">%x轴上的数据，第一个值代表数据开始，第二个值代表间隔，第三个值代表终止</span></span><br><span class="line"> a=[<span class="number">203.024</span>,<span class="number">113.857</span>,<span class="number">256.259</span>,<span class="number">244.888</span>,<span class="number">293.376</span>]; <span class="comment">%a数据y值</span></span><br><span class="line"> b=[<span class="number">334.4</span>,<span class="number">143.2</span>,<span class="number">297.4</span>,<span class="number">487.2</span>,<span class="number">596.2</span>]; <span class="comment">%b数据y值</span></span><br><span class="line"> <span class="built_in">plot</span>(x,a,<span class="string">'-*b'</span>,x,b,<span class="string">'-or'</span>); <span class="comment">%线性，颜色，标记</span></span><br><span class="line">axis([<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">700</span>])  <span class="comment">%确定x轴与y轴框图大小</span></span><br><span class="line">set(gca,<span class="string">'XTick'</span>,[<span class="number">0</span>:<span class="number">1</span>:<span class="number">6</span>]) <span class="comment">%x轴范围1-6，间隔1</span></span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0</span>:<span class="number">100</span>:<span class="number">700</span>]) <span class="comment">%y轴范围0-700，间隔100</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'Neo4j'</span>,<span class="string">'MongoDB'</span>);   <span class="comment">%右上角标注</span></span><br><span class="line">xlabel(<span class="string">'深度'</span>)  <span class="comment">%x轴坐标描述</span></span><br><span class="line">ylabel(<span class="string">'时间（ms）'</span>) <span class="comment">%y轴坐标描述</span></span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/22.png" class>

<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%图12：各模式分期收益  </span></span><br><span class="line">Y = [<span class="number">9.05</span> <span class="number">14.12</span> <span class="number">26.69</span>;<span class="number">15.29</span> <span class="number">20.32</span> <span class="number">32.40</span>;<span class="number">12.14</span> <span class="number">17.56</span> <span class="number">29.27</span>; <span class="number">10.59</span> <span class="number">15.94</span> <span class="number">28.81</span>];<span class="comment">% 二维数组，每一维有三个数，所以显示三种颜色，三列</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">bh=bar(Y);	<span class="comment">% 画柱状图</span></span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,&#123;<span class="string">'现状模式'</span>,<span class="string">'模式一'</span>,<span class="string">'模式二'</span>,<span class="string">'模式三'</span>&#125;);<span class="comment">% 设置x轴各个柱所表示的名字</span></span><br><span class="line">ylim([<span class="number">0</span>,<span class="built_in">max</span>(<span class="built_in">max</span>(Y)+<span class="number">1</span>)]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'前期'</span>,<span class="string">'中期'</span>,<span class="string">'后期'</span>);	<span class="comment">% 区分一下不同颜色分别代表什么</span></span><br><span class="line">title(<span class="string">'各模式分期收益（单位：亿元）'</span>);	<span class="comment">% 标题</span></span><br><span class="line">xlabel(<span class="string">'模式'</span>);	<span class="comment">% 设置x轴名称</span></span><br><span class="line">ylabel(<span class="string">'收益（亿元）'</span>);	<span class="comment">% 设置y轴名称</span></span><br></pre></td></tr></table></figure>

 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/23.png" class>

<h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>主要是使用pie命令，pie(Y)等。</p>
<h1 id="三维绘图的基本操作"><a href="#三维绘图的基本操作" class="headerlink" title="三维绘图的基本操作"></a>三维绘图的基本操作</h1><h2 id="三维线图指令plot3"><a href="#三维线图指令plot3" class="headerlink" title="三维线图指令plot3"></a>三维线图指令plot3</h2><p>三维绘图指令中，plot3最易于理解，它的使用格式与plot十分相似，只是对应第3 维空间的参量。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">0</span>:<span class="number">0.02</span>:<span class="number">2</span>)*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="built_in">sin</span>(t);</span><br><span class="line">y=<span class="built_in">cos</span>(t);</span><br><span class="line">z=<span class="built_in">cos</span>(<span class="number">2</span>*t);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">'b-'</span>,x,y,z,<span class="string">'bd'</span>);</span><br><span class="line">view([<span class="number">-82</span>,<span class="number">58</span>]);</span><br><span class="line">box on</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'链'</span>,<span class="string">'宝石'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
 <img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/21.png" class>

<h2 id="三维网线图（mesh）和曲面图（surf）"><a href="#三维网线图（mesh）和曲面图（surf）" class="headerlink" title="三维网线图（mesh）和曲面图（surf）"></a>三维网线图（mesh）和曲面图（surf）</h2><p>画函数z=f(x,y)所代表的三维空间曲面，需要做以下的数据准备工作：</p>
<p>◼ 确定自变量的取值范围和取值间隔。</p>
<p>➢ x=x1:dx:x2;</p>
<p>➢ y=y1:dy:y2;</p>
<p>◼ 构成x-y平面上的自变量采样“格点”矩阵。</p>
<p>➢ 利用MATLAB指令meshgrid产生“格点”矩阵</p>
<p>➢ [xa, ya]=meshgrid(x,y) ; </p>
<p>◼ 计算函数在自变量采样“格点”上的函数值，即z=f(x,y)<strong>。</strong></p>
<p><strong>示例</strong>：绘制函数z=x^2^+y^2^的曲面</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">-4</span>:<span class="number">4</span>;y=x;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y); <span class="comment">%生成 x-y 坐标“格点”矩阵</span></span><br><span class="line">z=x.^<span class="number">2</span>+y.^<span class="number">2</span>; <span class="comment">%计算格点上的函数值</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>), mesh(x,y,z); <span class="comment">%三维网格图</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>), surf(x,y,z); <span class="comment">%三维曲面图</span></span><br><span class="line">colormap(hot);</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong> </p>
<img src="/2020/03/24/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/20.png" class>

]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识（三）</title>
    <url>/2020/03/23/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章主要介绍PHP的各种运算符，和流程控制。</p>
<a id="more"></a>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<p>PHP中的运算符有很多种：</p>
<ul>
<li><p>赋值运算符：赋值操作</p>
</li>
<li><p>算术运算符：算数计算</p>
</li>
<li><p>错误抑制符：抑制错误</p>
</li>
<li><p>比较运算符：数据对比</p>
</li>
<li><p>合并运算符：真伪判定给出不同结果</p>
</li>
<li><p>逻辑运算符：逻辑结果判定</p>
</li>
<li><p>连接运算符：字符串连接</p>
</li>
<li><p>三目运算符：真伪判断给出不同结果</p>
</li>
<li><p>自操作运算符：简化操作</p>
</li>
</ul>
<h3 id="一、赋值运算符"><a href="#一、赋值运算符" class="headerlink" title="一、赋值运算符"></a>一、赋值运算符</h3><p>有以下几种：</p>
<ul>
<li><code>=</code>：普通赋值。</li>
<li><code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>：复合赋值运算（是将左侧和右侧的整体结果进行计算）。</li>
<li><code>.=</code>：先将左边的符号的结果与右边的结果进行字符串连接（<code>.</code>是字符串连接），然后赋给左边。</li>
</ul>
<h3 id="二、算数运算符"><a href="#二、算数运算符" class="headerlink" title="二、算数运算符"></a>二、算数运算符</h3><p>除了简单的加减乘除取余等，还有其他需要格外注意的运算符。</p>
<ul>
<li><code>**</code>：幂运算，底数的指数次运算。</li>
</ul>
<h3 id="三、错误抑制符"><a href="#三、错误抑制符" class="headerlink" title="三、错误抑制符"></a>三、错误抑制符</h3><p><strong>错误抑制</strong>：在可能出现错误的代码前使用错误抑制符，让错误不会报出来。</p>
<ul>
<li><p>只需要在可能出现的错误表达式之前使用即可。</p>
</li>
<li><p>错误抑制符只有一个：<code>@</code></p>
</li>
<li><p>错误抑制符只针对就近的目标，如果是针对结果，需要使用<code>()</code>。</p>
</li>
<li><p>只能抑制简单的错误（如notice，warning）。</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正常处理</span></span><br><span class="line">$r = <span class="number">10</span>/<span class="number">0</span>;	<span class="comment">#报错，除数为0</span></span><br><span class="line"><span class="comment">#错误抑制处理</span></span><br><span class="line">$r = @<span class="number">10</span>/<span class="number">0</span>; <span class="comment">#报错，出错的位置是10/0这个过程，抑制的位置是10，无意义</span></span><br><span class="line"><span class="comment">#正确处理</span></span><br><span class="line">$r = @(<span class="number">10</span>/<span class="number">0</span>); <span class="comment">#不报错，因为是过程出错</span></span><br></pre></td></tr></table></figure>

<h3 id="四、比较运算符"><a href="#四、比较运算符" class="headerlink" title="四、比较运算符"></a>四、比较运算符</h3><p>除了熟悉的<code>&gt;,&lt;,&gt;=,&lt;=,==,!=</code>等运算符，格外介绍下面的特殊运算符。</p>
<ul>
<li>&lt;=&gt;：左边大于右边返回1，相等返回0，小于右边返回-1</li>
<li>===：左边等于右边，且两边数据类型一致，返回true。</li>
<li>!==：左边等于右边，且两边数据类型一致，返回false。</li>
</ul>
<p><strong>注意</strong>：在PHP中比较运算比较特殊，通常系统会自动将类型转换成相同的然后进行比较，所以在使用<strong>==</strong>和<strong>===</strong>比较的时候，如果不够确定可以参考PHP操作手册中的类型比较表。</p>
<img src="/2020/03/23/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/1.png" class>

<img src="/2020/03/23/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/2.png" class>

<h3 id="五、合并运算"><a href="#五、合并运算" class="headerlink" title="五、合并运算"></a>五、合并运算</h3><p><strong>概念：</strong>用于简单的数据存在型判定，不存在时给出一个设定值。</p>
<ul>
<li>合并运算需要一个判定：目标。</li>
<li>合并运算需要一个设定值：目标不存在时的值。</li>
<li>合并运算符：$a ?? B<ul>
<li>$a存在，整个表达式返回$a的值。</li>
<li>$a不存在，整个表达式返回B值。</li>
</ul>
</li>
<li>合并运算是保证代码的逻辑完整性：即总是有一个结果（不会不存在）</li>
</ul>
<h3 id="六、连接运算"><a href="#六、连接运算" class="headerlink" title="六、连接运算"></a>六、连接运算</h3><p><strong>概念：</strong>专门为字符串连接操作设定的运算符。</p>
<ul>
<li>连接运算需要两个数据的参与。</li>
<li>连接运算符只有一个：<code>.</code>  英文点。</li>
<li>连接运算是将两个字符串连接成一个字符串。<ul>
<li>如果数据不是字符串，系统会自动转变为字符串。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="string">'hello'</span>;</span><br><span class="line">$b = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">echo</span>($a.<span class="string">' '</span>.$b); <span class="comment">#结果：hello world</span></span><br></pre></td></tr></table></figure>

<h3 id="七、三目运算"><a href="#七、三目运算" class="headerlink" title="七、三目运算"></a>七、三目运算</h3><p>和基本的编程语言一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表达式1?表达式2:表达式3</span><br></pre></td></tr></table></figure>

<h3 id="八、逻辑运算"><a href="#八、逻辑运算" class="headerlink" title="八、逻辑运算"></a>八、逻辑运算</h3><p>逻辑与或非 。</p>
<p>&amp;&amp;，||，！。</p>
<h3 id="九、自操作运算"><a href="#九、自操作运算" class="headerlink" title="九、自操作运算"></a>九、自操作运算</h3><p>自增自减。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="If分支"><a href="#If分支" class="headerlink" title="If分支"></a>If分支</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($a &gt; $b) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'a &gt; b'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($a == $b) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'a = b'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ($a &lt; $b) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'a &lt; b'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一点elseif和else if的一点细微区别，参见博客。<a href="https://blog.csdn.net/qq_31659985/article/details/82807153" target="_blank" rel="noopener">https://blog.csdn.net/qq_31659985/article/details/82807153</a></p>
<h4 id="Switch分支"><a href="#Switch分支" class="headerlink" title="Switch分支"></a>Switch分支</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件变量)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值:</span><br><span class="line">        代码;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    循环条件变更;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h4><p>PHP中专门进行数组遍历的循环</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(数组变量 <span class="keyword">as</span> [下标变量=&gt;] 值变量)&#123;</span><br><span class="line">    通过下标读取数组中每个元素的下标(可以没有)</span><br><span class="line">        通过值变量读取数组中每个元素的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$info = [</span><br><span class="line">    <span class="string">'name'</span> =&gt; <span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'skill'</span> =&gt; <span class="string">'study'</span>,</span><br><span class="line">    <span class="string">'age'</span> =&gt; <span class="string">'20'</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">foreach</span>($info <span class="keyword">as</span> $k =&gt; $v)&#123;</span><br><span class="line">    <span class="keyword">echo</span> $k . <span class="string">"\t"</span> . $v . <span class="string">"\n"</span>;<span class="comment">#即可依次遍历;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>foreach是根据数据指针所在的位置挨个取出元素的</p>
<ul>
<li>重置指针：执行一次。</li>
<li>判断指针有效性<ul>
<li>指针有效：取出数组元素<ul>
<li>下标赋值给下标变量（如果提供了下标变量）</li>
<li>值赋值给值变量</li>
<li>指针下移</li>
</ul>
</li>
<li>指针无效：循环结束</li>
</ul>
</li>
<li>进入循环体</li>
</ul>
<p>foreach可以不获取数组元素的下标</p>
<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p>语法基本一致。</p>
<h4 id="break，continue"><a href="#break，continue" class="headerlink" title="break，continue"></a>break，continue</h4><p>语法基本一致。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB课程总结（二）</title>
    <url>/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>本篇基于上篇文章基础，谈谈Matlab的<strong>数值运算</strong>，包括基本运算，与向量与矩阵处理的相关函数（最大值最小值，平均值，排序等）、多项式的相关函数（求根，加减乘除，导数等）等。</p>
<a id="more"></a>

<p>在Matlab中，一切数据均以矩阵的形式出现。相比其他语言，MATLAB在矩阵运算方面具有强大的功能，它提供了多种运算和函数对矩阵进行操作。MATLAB的数值运算包括两种：一种是针对整个矩阵的数学运算，称之为<strong>矩阵运算</strong>；另一种是针对矩阵的每一个元素进行运算的函数，称之为<strong>矩阵元素的运算</strong>。</p>
<hr>
<h2 id="一、基本运算功能"><a href="#一、基本运算功能" class="headerlink" title="一、基本运算功能"></a>一、基本运算功能</h2><h3 id="1、算术运算"><a href="#1、算术运算" class="headerlink" title="1、算术运算"></a>1、算术运算</h3><ul>
<li><p>MATLAB数组支持线性代数中所有的矩阵运算。</p>
</li>
<li><p>建立特有的数组运算符，如：“.*”、“./”等。</p>
</li>
</ul>
<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" class>

<h3 id="2、逻辑运算"><a href="#2、逻辑运算" class="headerlink" title="2、逻辑运算"></a>2、逻辑运算</h3><p> Matlab提供了3种逻辑运算符：&amp;（与）、|（或）、~（非）。</p>
<p><strong>逻辑运算符的运算法则：</strong></p>
<ol>
<li><p>在逻辑运算中，确认非零元素为真（1），零元素为假（0）。  </p>
</li>
<li><p>当两个维数相等的矩阵进行比较时，其相应位置的元素按标量关系进行比较，并给出结果，形成一个维数与原来相同的0、1矩阵；</p>
</li>
<li><p>当一个标量与一个矩阵比较时，该标量与矩阵的各元素进行比较，结果形成一个与矩阵维数相等的0、1矩阵；</p>
</li>
<li><p>算术运算优先级最高，逻辑运算优先级最低。</p>
</li>
</ol>
<h3 id="3、关系运算"><a href="#3、关系运算" class="headerlink" title="3、关系运算"></a>3、关系运算</h3><p>Matlab提供了6种关系运算符：&lt;、&gt;、&lt;=、&gt;=、==、~=（不等于）。</p>
<p><strong>关系运算符的运算法则：</strong></p>
<ol>
<li><p>当两个标量进行比较时，直接比较两数大小。若关系成立，结果为1，否则为0。</p>
</li>
<li><p>当两个维数相等的矩阵进行比较时，其相应位置的元素按标量关系进行比较，并给出结果，形成一个维数与原来相同的0、1矩阵。</p>
</li>
<li><p>当一个标量与一个矩阵比较时，该标量与矩阵的各元素进行比较，结果形成一个与矩阵维数相等的0、1矩阵。</p>
</li>
</ol>
<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" class>

<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" class>

<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" class>

<h2 id="二、向量与矩阵处理相关函数"><a href="#二、向量与矩阵处理相关函数" class="headerlink" title="二、向量与矩阵处理相关函数"></a>二、向量与矩阵处理相关函数</h2><h2 id="矩阵分析与处理"><a href="#矩阵分析与处理" class="headerlink" title="矩阵分析与处理"></a>矩阵分析与处理</h2><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><p>常见的特殊矩阵有零矩阵、幺矩阵、单位矩阵等，这类特殊矩阵在应用中具有通用性。</p>
<p>1、通用的特殊矩阵<br>常用的产生通用特殊矩阵的函数有：</p>
<ul>
<li><p>zeros：产生全0矩阵（零矩阵）。</p>
</li>
<li><p>ones： 产生全1矩阵（幺矩阵）。</p>
</li>
<li><p>eye： 产生单位矩阵。</p>
</li>
<li><p>rand：产生0~1间均匀分布的随机矩阵。</p>
</li>
<li><p>randn：产生均值为0，方差为1的标准正态分布随机矩阵。</p>
<ul>
<li><p>产生(0,1)区间均匀分布随机矩阵使用rand函数</p>
</li>
<li><p>产生均值为0，方差为1的标准正态分布随机矩阵使用randn函数</p>
</li>
</ul>
</li>
</ul>
<p><strong>例如：</strong><code>ones(5)</code>产生5*5的单位矩阵。</p>
<h3 id="1、矩阵变换函数"><a href="#1、矩阵变换函数" class="headerlink" title="1、矩阵变换函数"></a>1、矩阵变换函数</h3><p>包括矩阵重排、矩阵抽取以及矩阵转向等。</p>
<ol>
<li><p>矩阵重排函数：<br>reshape(A,m,n)：把矩阵A中所有元素重新排列为m*n的矩阵，矩阵总元素数必须相等。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span></span><br><span class="line">&gt;&gt; <span class="built_in">reshape</span>(a,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">5</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">6</span>     <span class="number">8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵抽取函数：<br>diag(A, k)：A为矩阵时，抽取矩阵A的第k条对角线。k可以为正整数也可以为负整数。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">A =</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">&gt;&gt; <span class="built_in">diag</span>(A)        <span class="comment">% 提取A的主对角线元素</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     <span class="number">5</span></span><br><span class="line">&gt;&gt; <span class="built_in">diag</span>(A,<span class="number">1</span>)        <span class="comment">% 提取A的第一条对角线的元素（对角线从0计数）</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>同时该函数还可构造对角矩阵</strong></p>
<p>如果V是一个m个元素的向量，diag(V)将产生一个m×m对角矩阵，其主对角线元素即为向量V的元素。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">diag</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">	<span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">	<span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">	<span class="number">0</span>  <span class="number">0</span> <span class="number">-1</span>  <span class="number">0</span></span><br><span class="line">	<span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="built_in">diag</span>(<span class="number">1</span>:<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">	<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">	<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">	<span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">	<span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵转向函数：<br>transpose(A)：求矩阵A的转置。可以用单引号（’）直接代替transpose函数。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">A =</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line">&gt;&gt; transpose(A)        <span class="comment">% 求A的转置</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">6</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2、矩阵求值函数"><a href="#2、矩阵求值函数" class="headerlink" title="2、矩阵求值函数"></a>2、矩阵求值函数</h3><ul>
<li>inv(A)：求可逆矩阵A的逆。</li>
<li>det(A)：求方阵A所对应的行列式的值。</li>
<li>rank(A)：求矩阵A的秩。</li>
<li>trace(A)：求矩阵A的迹。</li>
<li>eig(A)：求矩阵A的特征值和特征向量。</li>
</ul>
<h3 id="3、数据统计与分析中的矩阵函数："><a href="#3、数据统计与分析中的矩阵函数：" class="headerlink" title="3、数据统计与分析中的矩阵函数："></a><strong>3、数据统计与分析中的矩阵函数</strong>：</h3><h4 id="1）最大值和最小值"><a href="#1）最大值和最小值" class="headerlink" title="1）最大值和最小值"></a>1）最大值和最小值</h4><p>​      MATLAB提供的求数据序列的最大值和最小值的函数分别为max和min，两个函数的调用格式和操作过程类似。</p>
<p><strong>1、求向量的最大值和最小值</strong></p>
<p>求一个向量X的最大值的函数有两种调用格式，分别是：</p>
<p>(1) y=max(X)：返回向量X的最大值存入y，如果X中包含复数元素，则按模取最大值；</p>
<p>(2)[y,I]=max(X)：返回向量X的最大值存入y，最大值的序号存入I，如果X中包含复数元素，则按模取最大值。</p>
<p>求向量X的最小值的函数是min(X)，用法和max(X)完全相同。</p>
  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;x=[<span class="number">-43</span>,<span class="number">72</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">47</span>];</span><br><span class="line">&gt;&gt;y=<span class="built_in">max</span>(x)     <span class="comment">%求向量x中的最大值</span></span><br><span class="line">&gt;&gt;y =</span><br><span class="line">&gt;&gt;<span class="number">72</span></span><br><span class="line">&gt;&gt;[y,l]=<span class="built_in">max</span>(x) <span class="comment">%求向量x中的最大值及其该元素的位置</span></span><br><span class="line">&gt;&gt;y =</span><br><span class="line">&gt;&gt;<span class="number">72</span></span><br><span class="line">&gt;&gt;l =</span><br><span class="line">&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>2、求矩阵的最大值和最小值</strong></p>
<p>求矩阵A的最大值的函数有3种调用格式，分别是：</p>
<p>(1) max(A)：返回一个行向量，向量的第i个元素是矩阵A的第i列上的最大值；</p>
<p>(2) [Y,U]=max(A)：返回行向量Y和U，Y向量记录A的每列的最大值，U向量记录每列最大值的行号；</p>
<p>(3) max(A,[],dim)：dim取1或2。dim取1时，该函数和max(A)完全相同；dim取2时，该函数返回一个列向量，其</p>
<p>第i个元素是A矩阵的第i行上的最大值。</p>
<p>求最小值的函数是min，其用法和max完全相同。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;x=[<span class="number">-43</span>,<span class="number">72</span>,<span class="number">9</span>; <span class="number">16</span>,<span class="number">23</span>,<span class="number">47</span>];</span><br><span class="line">&gt;&gt;y=<span class="built_in">max</span>(x)     <span class="comment">%求矩阵x中每列的最大值</span></span><br><span class="line">y =</span><br><span class="line">     <span class="number">16</span>  <span class="number">72</span>  <span class="number">47</span></span><br><span class="line">&gt;&gt;[y,l]=<span class="built_in">max</span>(x) <span class="comment">%求矩阵x中每列的最大值及其该元素的位置</span></span><br><span class="line">y =</span><br><span class="line">    <span class="number">16</span>  <span class="number">72</span>  <span class="number">47</span></span><br><span class="line">l =</span><br><span class="line">     <span class="number">2</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">&gt;&gt;<span class="built_in">max</span>(x, [],<span class="number">1</span>), <span class="built_in">max</span>(x, [],<span class="number">2</span>) <span class="comment">%求矩阵中每行的最大值</span></span><br></pre></td></tr></table></figure>

<h4 id="2）求和与求积"><a href="#2）求和与求积" class="headerlink" title="2）求和与求积"></a>2）求和与求积</h4><ul>
<li><p>sum(X)：返回向量X各元素的和。</p>
</li>
<li><p>prod(X)：返回向量X各元素的乘积。</p>
</li>
<li><p>sum(A)：返回一个行向量，其第i个元素是A的第i列的元素和。</p>
</li>
<li><p>prod(A)：返回一个行向量，其第i个元素是A的第i列的元素乘积。</p>
</li>
<li><p>sum(A,dim)：当dim为1时，该函数等同于sum(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行</p>
<p>的各元素之和。</p>
</li>
<li><p>prod(A,dim)：当dim为1时，该函数等同于prod(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行的各元素乘积。</p>
</li>
</ul>
<h4 id="3）平均值与中值"><a href="#3）平均值与中值" class="headerlink" title="3）平均值与中值"></a>3）平均值与中值</h4><p>求数据序列平均值的函数是mean，求数据序列中值的函数是median。两个函数的调用格式为：</p>
<ul>
<li>mean(X)：返回向量X的算术平均值。</li>
<li>median(X)：返回向量X的中值。</li>
<li>mean(A)：返回一个行向量，其第i个元素是A的第i列的算术平均值。</li>
<li>median(A)：返回一个行向量，其第i个元素是A的第i列的中值。</li>
<li>mean(A,dim)：当dim为1时，该函数等同于mean(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行的算术平均值。</li>
<li>median(A,dim)：当dim为1时，该函数等同于median(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行的中值。</li>
</ul>
<h3 id="4、元素排序"><a href="#4、元素排序" class="headerlink" title="4、元素排序"></a>4、元素排序</h3><p> Matlab中对向量X排序的函数是sort(X), 函数返回一个对X中的元素按升序排列的新向量。</p>
<p>   sort函数也可以对矩阵A的各列（或行）重新排序，其调用格式为：</p>
<p>   <code>[Y,I] = sort(A,dim)</code></p>
<p>   dim=1,按列排序；dim=2,按行排序，Y是排序后的矩阵，I记录Y中的元素在A中的位置。</p>
<p>命令如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">-8</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">12</span>,<span class="number">6</span>;<span class="number">13</span>,<span class="number">7</span>,<span class="number">-13</span>];</span><br><span class="line"> <span class="built_in">sort</span>(A)</span><br><span class="line"> <span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">1</span>    <span class="number">-8</span>   <span class="number">-13</span></span><br><span class="line"> <span class="number">4</span>     <span class="number">7</span>     <span class="number">5</span></span><br><span class="line"><span class="number">13</span>    <span class="number">12</span>     <span class="number">6</span></span><br><span class="line">-<span class="built_in">sort</span>(-A,<span class="number">2</span>)  <span class="comment">%对A的每行按降序排列</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"><span class="number">5</span>       <span class="number">1</span>    <span class="number">-8</span></span><br><span class="line"><span class="number">12</span>     <span class="number">6</span>     <span class="number">4</span></span><br><span class="line"><span class="number">13</span>     <span class="number">7</span>   <span class="number">-13</span></span><br></pre></td></tr></table></figure>

<h3 id="5、数据插值"><a href="#5、数据插值" class="headerlink" title="5、数据插值"></a>5、数据插值</h3><p>在工程测量和科学实验中，所得到的数据通常是离散的，要得到这些离散点以外的其他点的数值，就需要根据已知的数据进行插值。</p>
<p>插值函数一般由<strong>线性函数</strong>、<strong>多项式</strong>、<strong>样条函数</strong>或这些函数的<strong>分段</strong>函数充当。</p>
<p><strong>一维数据插值：被插值函数有一个单变量。</strong></p>
<p>采用的方法有：线性方法、最近方法、三次样条和三次插值。</p>
<p>在Matlab中实现这些插值的函数是interp1，其调用格式如下：</p>
<p><code>Y1 = interp1(X,Y,X1,method)</code></p>
<p>函数根据X，Y的值，计算函数在X1处的值。</p>
<ul>
<li><p>X,Y是两个等长的已知向量，分别描述采样点和样本值；</p>
</li>
<li><p>X1是一个向量或标量，描述欲插值的点；</p>
</li>
<li><p>Y1是一个与X1等长的插值结果。</p>
</li>
<li><p>method是插值方法，允许的取值为：</p>
<p>（1）‘linear’：线性插值。默认的插值方式。它是把插值点靠近的两个数据点用直线连接，然后在直线上选取</p>
<p>对应插值点的数据。</p>
<p>（2）‘nearest’：最近点插值。根据已知插值点与已知数据点的远近程度进行插值。插值点优先选择较近的数</p>
<p>据点进行插值。</p>
<p>（3）‘cubic’：3次多项式插值。根据已知数据求出一个3次多项式，然后根据该多项式进行插值。</p>
<p>（4）‘spline’：3次样条插值。指在每个分段内构造一个3次多项式，使其满足插值条件外，在各节点处具有光</p>
<p>滑的条件。</p>
</li>
</ul>
<h2 id="三、多项式"><a href="#三、多项式" class="headerlink" title="三、多项式"></a>三、多项式</h2><h3 id="1、多项式的MATLAB表达"><a href="#1、多项式的MATLAB表达" class="headerlink" title="1、多项式的MATLAB表达"></a><strong>1、多项式的MATLAB表达</strong></h3><p>多项式由一个行向量表示：</p>
<ul>
<li>该向量元素是该多项式的系数</li>
<li>且按降幂次序排列  </li>
</ul>
<p>如：多项式x4－12x3＋25x＋116由行向量：</p>
<p>​      <code>p=[1  -12  0  25  116]</code>表示。</p>
<p><strong>注意，必须包括具有零系数的项。</strong></p>
<h3 id="2、求解多项式的根？"><a href="#2、求解多项式的根？" class="headerlink" title="2、求解多项式的根？"></a><strong>2、求解多项式的根？</strong></h3><p>roots指令。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;p=[<span class="number">1</span>  <span class="number">-12</span>  <span class="number">0</span>  <span class="number">25</span>  <span class="number">116</span>]</span><br><span class="line">p =</span><br><span class="line">     <span class="number">1</span>   <span class="number">-12</span>     <span class="number">0</span>    <span class="number">25</span>   <span class="number">116</span></span><br><span class="line">&gt;&gt;r=roots(p)</span><br><span class="line">r =</span><br><span class="line">  <span class="number">11.7473</span>          </span><br><span class="line">   <span class="number">2.7028</span>          </span><br><span class="line">  <span class="number">-1.2251</span> + <span class="number">1.4672</span><span class="built_in">i</span></span><br><span class="line">  <span class="number">-1.2251</span> - <span class="number">1.4672</span><span class="built_in">i</span></span><br></pre></td></tr></table></figure>

<p>MATLAB按惯例规定，多项式是行向量，根是列向量。</p>
<h3 id="3、已知多项式的根，求解多项式-？"><a href="#3、已知多项式的根，求解多项式-？" class="headerlink" title="3、已知多项式的根，求解多项式 ？"></a><strong>3、已知多项式的根，求解多项式 ？</strong></h3><p>使用ploy指令。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; pp=poly(r)</span><br><span class="line">pp =</span><br><span class="line">    <span class="number">1.0000</span>  <span class="number">-12.0000</span>   <span class="number">-0.0000</span>   <span class="number">25.0000</span>  <span class="number">116.0000</span></span><br></pre></td></tr></table></figure>

<p>即：x4－12x3＋25x＋116。</p>
<h3 id="4、多项式的乘法-conv指令"><a href="#4、多项式的乘法-conv指令" class="headerlink" title="4、多项式的乘法(conv指令)"></a><strong>4、多项式的乘法(conv指令)</strong></h3><p>举例：多项式 a(x)=x3＋2x2＋3x＋4 和 b(x)= x3＋4x2＋9x＋16 的乘积。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>] ;  b=[<span class="number">1</span>  <span class="number">4</span>  <span class="number">9</span>  <span class="number">16</span>];</span><br><span class="line">c=conv(a, b)</span><br><span class="line">c =</span><br><span class="line">     <span class="number">1</span>     <span class="number">6</span>    <span class="number">20</span>    <span class="number">50</span>    <span class="number">75</span>    <span class="number">84</span>    <span class="number">64</span></span><br></pre></td></tr></table></figure>

<p>两个以上的多项式的乘法需要重复使用conv. </p>
<h3 id="5、多项式加法"><a href="#5、多项式加法" class="headerlink" title="5、多项式加法"></a><strong>5、多项式加法</strong></h3><p>MATLAB没有提供进行加法运算的函数。</p>
<p>1）如果两个多项式向量大小相同，标准的数组加法有效。把多项式a(x)与上面给出的b(x)相加。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; d=a+b</span><br><span class="line">d =</span><br><span class="line">     <span class="number">2</span>     <span class="number">6</span>    <span class="number">12</span>    <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>结果: d(x)= 2x3＋6x2＋12x＋20<br>2）当两个多项式阶次不同，低阶的多项式必须用首零填补，使其与高阶多项式有同样的阶次。<br>考虑上面多项式c和d相加：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;  e=c+[<span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  d]</span><br><span class="line">e =</span><br><span class="line">     <span class="number">1</span>     <span class="number">6</span>    <span class="number">20</span>    <span class="number">52</span>    <span class="number">81</span>    <span class="number">96</span>    <span class="number">84</span></span><br></pre></td></tr></table></figure>

<p>结果: e(x)= x6+6x5+20x4+52x3+81x2+96x+84</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>问题：编写一个多项式加法运算的函数文件。</p>
<p>明确需求：</p>
<p>定义一个函数，需要有两个输入参数（比如：p1、p2），一个输出参数p_out。</p>
<p>p1、p2表示两个待计算的多项式。</p>
<p>p_out表示两个多项式的求和结果。</p>
<p>函数的内部处理：</p>
<ul>
<li><p>若p1、p2两参数大小相等，则直接相加: p_out=p1+p2</p>
</li>
<li><p>若p1、p2两参数大小不等：</p>
<ul>
<li><p>If length(p1)&gt;length(p2)</p>
<p>P2前面要补0元素，使p1、p2两参数大小相等</p>
</li>
<li><p>否则</p>
<p>P1前面要补0元素，使p1、p2两参数大小相等</p>
</li>
</ul>
</li>
</ul>
<p>函数文件的编写：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p_out</span>=<span class="title">poly_sum</span><span class="params">(p1, p2)</span></span></span><br><span class="line"><span class="comment">% calculate the sum of two polynomials </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(p1)==<span class="built_in">length</span>(p2)</span><br><span class="line">    p_out=p1+p2;</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(p1)&gt;<span class="built_in">length</span>(p2)</span><br><span class="line">    p2=[<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(p1)-<span class="built_in">length</span>(p2)), p2];</span><br><span class="line">    p_out=p1+p2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p1=[<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(p2)-<span class="built_in">length</span>(p1)), p1];</span><br><span class="line">    p_out=p1+p2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="6、多项式的除法-deconv"><a href="#6、多项式的除法-deconv" class="headerlink" title="6、多项式的除法(deconv)"></a>6、多项式的除法(deconv)</h3><p>举例说明：</p>
<p>c(x)=x6＋6x5＋20x4＋50x3＋75x2＋84x＋64 除以 b(x)= x3＋4x2＋9x＋16</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; c=[<span class="number">1</span>     <span class="number">6</span>    <span class="number">20</span>    <span class="number">50</span>    <span class="number">75</span>    <span class="number">84</span>    <span class="number">64</span>];</span><br><span class="line">&gt;&gt; b=[<span class="number">1</span>  <span class="number">4</span>  <span class="number">9</span>  <span class="number">16</span>];</span><br><span class="line">&gt;&gt;  [q , r]=deconv(c , b)</span><br><span class="line">q =</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span></span><br><span class="line">r =</span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="7、多项式的导数-polyder"><a href="#7、多项式的导数-polyder" class="headerlink" title="7、多项式的导数 (polyder)"></a>7、多项式的导数 (polyder)</h3><p>举例：求b(x)= x3＋4x2＋9x＋16的导数。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; b=[<span class="number">1</span>     <span class="number">4</span>     <span class="number">9</span>    <span class="number">16</span>];</span><br><span class="line">&gt;&gt; d=polyder(b)</span><br><span class="line">d =</span><br><span class="line">     <span class="number">3</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>结果为： 3x2＋8x＋9。另外两种形式为：</p>
<ul>
<li>p = polyder(P,Q)：求P*Q的导函数</li>
<li>[p,q] = polyder(P,Q)：求P/Q的导函数，导数分子存入p,分母存入q</li>
</ul>
<h3 id="8、多项式的估值-polyval"><a href="#8、多项式的估值-polyval" class="headerlink" title="8、多项式的估值(polyval)"></a>8、多项式的估值(polyval)</h3><p>举例：绘制p(x) = x3＋4x2－7x－10在[-1, 3]段上的曲线。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">-1</span>, <span class="number">3</span>);  <span class="comment">% choose 100 data points between -1and 3.</span></span><br><span class="line">p=[<span class="number">1</span>  <span class="number">4</span>  <span class="number">-7</span>  <span class="number">-10</span>]; </span><br><span class="line">v=polyval(p, x);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">plot</span>(x, v);</span><br><span class="line">title(<span class="string">'x^&#123;3&#125;+4x^&#123;2&#125;-7x-10'</span>);</span><br><span class="line">xlabel(<span class="string">'x'</span>)</span><br></pre></td></tr></table></figure>

<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" class>

<h3 id="9、函数的数值导数"><a href="#9、函数的数值导数" class="headerlink" title="9、函数的数值导数"></a>9、函数的数值导数</h3><img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" class>

<p>MATLAB中没有直接提供数值导数的函数，只有计算向前差分的函数<strong>diff</strong>，其调用格式为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">DX = diff(X) <span class="comment">%计算向量X的向前差分</span></span><br><span class="line">DX = diff(X，n) <span class="comment">%计算向量X的n阶向前差分</span></span><br></pre></td></tr></table></figure>

<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" class>

<h3 id="10、数值积分"><a href="#10、数值积分" class="headerlink" title="10、数值积分"></a>10、数值积分</h3><p>一元函数的数值积分<br>◼ 常用积分指令：<strong>quad</strong>和<strong>quadl</strong>。 ◼ 具体调用格式如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">q = quadl(fun,a,b)</span><br><span class="line">q = quadl(fun,a,b,tol)</span><br><span class="line">q = quadl(fun,a,b,tol,trace)</span><br><span class="line">[q,fcnt] = quadl(fun,a,b,...)</span><br></pre></td></tr></table></figure>

<p>➢ 输入量fun为被积函数的句柄。<br>➢ 输入量a, b分别是积分的下限、和上限，都必须是确定的数值;<br>➢ 前3个输入参数是调用积分指令所必须的，其他可以缺省;<br>➢ 输入量tol是一个标量，控制绝对误差;<br>➢ 输入量trace为非0值时，将随积分的进程逐点画出被积分函数;<br>➢ 输出参数fcnt返回函数的执行次数。<br>Note：quad的调用格式与quadl相同。</p>
<p><strong>案例</strong></p>
<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" class>

<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" class>

<h2 id="四、矩阵求逆与线性方程组求解"><a href="#四、矩阵求逆与线性方程组求解" class="headerlink" title="四、矩阵求逆与线性方程组求解"></a>四、矩阵求逆与线性方程组求解</h2><h3 id="1、矩阵的逆"><a href="#1、矩阵的逆" class="headerlink" title="1、矩阵的逆"></a>1、矩阵的逆</h3><p>对于一个方阵A，如果存在一个与其同阶的方阵B，使得：A·B=B·A=I  (I为单位矩阵）。</p>
<p>则称B为A的逆矩阵，当然，A也是B的逆矩阵。求方阵A的逆矩阵可调用函数inv(A)。</p>
<p>例5.18 求方阵A的逆矩阵，且验证。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>;<span class="number">5</span>,<span class="number">-4</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">B = inv(A);</span><br><span class="line">A*B</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">   <span class="number">1.0000</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">  <span class="number">-0.0000</span>    <span class="number">1.0000</span>         <span class="number">0</span></span><br><span class="line">  <span class="number">-0.0000</span>         <span class="number">0</span>    <span class="number">1.0000</span></span><br></pre></td></tr></table></figure>

<h3 id="2、用矩阵求逆方法求解线性方程组"><a href="#2、用矩阵求逆方法求解线性方程组" class="headerlink" title="2、用矩阵求逆方法求解线性方程组"></a>2、用矩阵求逆方法求解线性方程组</h3><img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" class>

<p><strong>例题：</strong></p>
<img src="/2020/03/20/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" class>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>;<span class="number">1</span>,<span class="number">8</span>,<span class="number">27</span>];</span><br><span class="line">b = [<span class="number">5</span>,<span class="number">-2</span>,<span class="number">6</span>]’;</span><br><span class="line">x = inv(A)*b   <span class="comment">%x = A\b</span></span><br><span class="line">x =</span><br><span class="line">  <span class="number">23.0000</span></span><br><span class="line"> <span class="number">-14.5000</span></span><br><span class="line">   <span class="number">3.6667</span></span><br></pre></td></tr></table></figure>

<p>也可以运用左除运算符求解。</p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_2(选择循环字符串)</title>
    <url>/2020/03/17/Python-2/</url>
    <content><![CDATA[<p>基于上篇博客介绍了一些很基本的Python语法，<strong>如数据类型</strong>，<strong>输入输出</strong>，<strong>运算符</strong>等等，此篇博客继续总结<strong>选择</strong>、<strong>循环</strong>等结构，和最重要的 <strong>字符串</strong> 类型介绍。</p>
<a id="more"></a>

<hr>
<h1 id="一、if-else选择"><a href="#一、if-else选择" class="headerlink" title="一、if-else选择"></a>一、if-else选择</h1><h2 id="1、if-else语法"><a href="#1、if-else语法" class="headerlink" title="1、if-else语法"></a>1、if-else语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	条件成立执行的代码<span class="number">1</span></span><br><span class="line">    条件成立执行的代码<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        此为嵌套</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    代码</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    代码</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    代码<span class="number">4</span></span><br><span class="line">代码<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>if条件成立，执行后面带缩进的代码，而代码5则不属于if-else的语句块，与条件成立与否无关。</p>
<p><strong>案例</strong>：猜拳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、出拳</span></span><br><span class="line"><span class="comment"># 玩家</span></span><br><span class="line">player = int(input(<span class="string">'请出拳(0--石头，1--剪刀，2--布):'</span>))</span><br><span class="line"><span class="comment">#电脑</span></span><br><span class="line">computer = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">print(computer)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、判断输赢</span></span><br><span class="line"><span class="comment">#获胜</span></span><br><span class="line"><span class="keyword">if</span>((player == <span class="number">0</span>) <span class="keyword">and</span> (computer == <span class="number">1</span>)) <span class="keyword">or</span> ((player == <span class="number">1</span>) <span class="keyword">and</span> (computer == <span class="number">2</span>)) <span class="keyword">or</span> ((player == <span class="number">2</span>) <span class="keyword">and</span> (computer == <span class="number">0</span>)):</span><br><span class="line">    print(<span class="string">'玩家获胜'</span>)</span><br><span class="line"><span class="comment">#平局</span></span><br><span class="line"><span class="keyword">elif</span> player == computer:</span><br><span class="line">    print(<span class="string">'平局'</span>)</span><br><span class="line"><span class="comment">#失败</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'失败'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2、三目运算符"><a href="#2、三目运算符" class="headerlink" title="2、三目运算符"></a>2、三目运算符</h2><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">条件成立执行的表达式 <span class="keyword">if</span> 条件 <span class="keyword">else</span> 条件不成立的表达式</span><br><span class="line">c = a <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>

<p><strong>案例：计算三角形面积</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = float(input(<span class="string">'a = '</span>))</span><br><span class="line">b = float(input(<span class="string">'b = '</span>))</span><br><span class="line">c = float(input(<span class="string">'c = '</span>))</span><br><span class="line"><span class="keyword">if</span> a + b &gt; c <span class="keyword">and</span> a + c &gt; b <span class="keyword">and</span> b + c &gt; a:</span><br><span class="line">    print(<span class="string">'周长: %f'</span> % (a + b + c))</span><br><span class="line">    p = (a + b + c) / <span class="number">2</span></span><br><span class="line">    area = (p * (p - a) * (p - b) * (p - c)) ** <span class="number">0.5</span></span><br><span class="line">    print(<span class="string">'面积: %f'</span> % (area))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不能构成三角形'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>说明：</strong> 上面使用的通过边长计算三角形面积的公式叫做<a href="https://zh.wikipedia.org/zh-hans/海伦公式" target="_blank" rel="noopener">海伦公式</a>。</p>
</blockquote>
<h1 id="二、循环"><a href="#二、循环" class="headerlink" title="二、循环"></a>二、循环</h1><p>包括while和for循环。</p>
<h2 id="1、while循环"><a href="#1、while循环" class="headerlink" title="1、while循环"></a>1、while循环</h2><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立执行的代码</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="2、for循环"><a href="#2、for循环" class="headerlink" title="2、for循环"></a>2、for循环</h2><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    重复执行的代码</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>例如：循环输出字符串中的每个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h2 id="3、while…else-for…else"><a href="#3、while…else-for…else" class="headerlink" title="3、while…else/for…else"></a>3、while…else/for…else</h2><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    循环正常结束执行的代码</span><br></pre></td></tr></table></figure>

<p>只有在循环正常结束时才会执行else里的内容，如果while里用break中止循环，则不会执行else里的语句。反之，continue可以执行else里的内容。</p>
<p>for…else语法类似。</p>
<p><strong>案例</strong>：求两个数的最大公约数和最小公倍数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; int(input(&#39;x &#x3D; &#39;))</span><br><span class="line">y &#x3D; int(input(&#39;y &#x3D; &#39;))</span><br><span class="line"># 如果x大于y就交换x和y的值</span><br><span class="line">if x &gt; y:</span><br><span class="line">    # 通过下面的操作将y的值赋给x, 将x的值赋给y</span><br><span class="line">    x, y &#x3D; y, x</span><br><span class="line"># 从两个数中较的数开始做递减的循环</span><br><span class="line">for factor in range(x, 0, -1):</span><br><span class="line">    if x % factor &#x3D;&#x3D; 0 and y % factor &#x3D;&#x3D; 0:</span><br><span class="line">        print(&#39;%d和%d的最大公约数是%d&#39; % (x, y, factor))</span><br><span class="line">        print(&#39;%d和%d的最小公倍数是%d&#39; % (x, y, x * y &#x2F;&#x2F; factor))</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>有三种方法，单引、双引和三引。 在三引号里回车换行会原样显示。</p>
<blockquote>
<p>注意：注释也有三引号的写法，完全一致。</p>
</blockquote>
<h2 id="2、下标"><a href="#2、下标" class="headerlink" title="2、下标"></a>2、下标</h2><p>在python中，可以用下标查询字符串中的相应字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'hello world'</span></span><br><span class="line">print(str[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：字符串不可通过下标修改</span></span><br><span class="line"><span class="comment"># str[1] = 'w' 报错</span></span><br><span class="line"><span class="comment"># str[:1] = 'Splat' 报错</span></span><br></pre></td></tr></table></figure>

<h2 id="3、切片"><a href="#3、切片" class="headerlink" title="3、切片"></a>3、切片</h2><p>切片是指对操作的对象截取其中一部分的操作。字符串、列表和元组都支持切片操作。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">序列[开始位置下标:结束位置下标:步长]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>不包含结束位置下标对应的数据，正负整数均可。</li>
<li>步长是选取间隔，正负整数均可，默认步长为1。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'01234567'</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>:<span class="number">1</span>])   <span class="comment">#234</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>:<span class="number">2</span>])   <span class="comment">#24</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment">#234</span></span><br><span class="line">print(str[:<span class="number">5</span>])      <span class="comment">#01234</span></span><br><span class="line">print(str[<span class="number">2</span>:])      <span class="comment">#234567</span></span><br><span class="line">print(str[:])       <span class="comment">#01234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#负数测试</span></span><br><span class="line">print(str[::<span class="number">-1</span>])    <span class="comment">#76543210 如果步长为负数，表示倒叙选取</span></span><br><span class="line">print(str[<span class="number">-4</span>:<span class="number">-1</span>])   <span class="comment">#456 表示从-4到-1位置输出，即倒数第四个到倒数第1个</span></span><br><span class="line"></span><br><span class="line">print(str[<span class="number">-4</span>:<span class="number">-1</span>:<span class="number">-1</span>])<span class="comment">#不能选取出数据：从-4开始到-1结束，选取方向为从左到右，但步长为-1，代表从右向左选取</span></span><br><span class="line"><span class="comment">#如果选取方向（下标开始到结束的方向）和 步长的方向冲突，则无法选取数据。</span></span><br></pre></td></tr></table></figure>

<h2 id="4、字符串的常用操作方法"><a href="#4、字符串的常用操作方法" class="headerlink" title="4、字符串的常用操作方法"></a>4、字符串的常用操作方法</h2><p>主要包括查找、修改和判断三大类。</p>
<h3 id="1）查找"><a href="#1）查找" class="headerlink" title="1）查找"></a>1）查找</h3><p>查找子串在字符串中的位置或者出现的次数。</p>
<ul>
<li><p>find()：检查某个子串是否包含在这个字符串中，如果存在返回这个子串开始的位置下标，否则则返回-1。</p>
<p><strong>语法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.find(子串,开始位置下标,结束位置下标)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：开始和结束位置下标可以省略，表示在整个字符串序列中查找</p>
</li>
<li><p>index()：和find()用法几乎一致。唯一不同：如果字串不存在，则系统报错。</p>
</li>
<li><p>count()：返回对应子串出现的次数</p>
<p><strong>语法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.count(子串,开始位置下标,结束位置下标)</span><br></pre></td></tr></table></figure>
</li>
<li><p>rfind()，rindex()：用法一致，查找顺序从右边开始。</p>
</li>
</ul>
<h3 id="2）修改"><a href="#2）修改" class="headerlink" title="2）修改"></a>2）修改</h3><ul>
<li><p>replace：替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.replace(旧子串,新子串,替换次数)</span><br></pre></td></tr></table></figure>

<p>原有字符串不会做出修改，函数返回修改后的结果。</p>
</li>
<li><p>split()：分割，返回一个列表，丢失分割字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.split(分割字符,num)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。</p>
</li>
<li><p>不写参数，默认以空格为分隔符，包括\n \t。</p>
</li>
</ul>
</li>
<li><p>join()：合并列表里的字符串数据为一个大字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符或子串.join(多字符串组成的序列)</span><br></pre></td></tr></table></figure>

<p><strong>举例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="string">'11'</span>,<span class="string">'22'</span>,<span class="string">'33'</span>,<span class="string">'44'</span>]</span><br><span class="line">print(<span class="string">'_'</span>.join(list)) 	<span class="comment">#结果 11_22_33_44</span></span><br></pre></td></tr></table></figure>

<p>以上三个函数重点掌握。</p>
</li>
<li><p><strong>转换</strong></p>
<p>capitalize()：讲字符串第一个字符转换成大写。</p>
<p>title()：将字符串每个单词首字母转换成大写。</p>
<p>lower()：将字符串中大写转小写。</p>
<p>upper()：小写转大写。</p>
</li>
<li><p>删除空白</p>
<p>lstrip()：删除字符串左侧空白字符。</p>
<p>rstrip()：删除字符串右侧空白字符。</p>
<p>strip()：删除字符串两侧空白字符。</p>
</li>
</ul>
<h3 id="3）判断"><a href="#3）判断" class="headerlink" title="3）判断"></a>3）判断</h3><p>判断真假，返回布尔的真假。</p>
<ul>
<li><p>startswith()：检查字符串是否以指定子串开头，是则返回True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.startswith(子串,开始位置下标,结束位置下标)</span><br></pre></td></tr></table></figure>
</li>
<li><p>endswith()：检查字符串是否以指定子串结尾，是则返回True。</p>
</li>
<li><p>其他函数：</p>
<ul>
<li>isalpha()：如果字符串至少有一个字符并且所有字符都是字母返回True。</li>
<li>isdigit()：如果字符串只包含数字则返回True。</li>
<li>isalnum()：如果字符串至少有一个字符并且所有字符串都是字母或数字。</li>
</ul>
</li>
<li><p>isspace()：如果字符串只包含空白。</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>可以使用<code>*</code>运算符来重复一个字符串的内容，可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串（成员运算）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hello '</span> * <span class="number">3</span></span><br><span class="line">print(s1) <span class="comment"># hello hello hello</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'ll'</span> <span class="keyword">in</span> s1) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'good'</span> <span class="keyword">in</span> s1) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'hello, world!'</span></span><br><span class="line">print(<span class="string">'字符串的长度是:'</span>, len(str1))</span><br><span class="line">print(<span class="string">'单词首字母大写: '</span>, str1.title())</span><br><span class="line">print(<span class="string">'字符串变大写: '</span>, str1.upper())</span><br><span class="line"><span class="comment"># str1 = str1.upper()</span></span><br><span class="line">print(<span class="string">'字符串是不是大写: '</span>, str1.isupper())</span><br><span class="line">print(<span class="string">'字符串是不是以hello开头: '</span>, str1.startswith(<span class="string">'hello'</span>))</span><br><span class="line">print(<span class="string">'字符串是不是以hello结尾: '</span>, str1.endswith(<span class="string">'hello'</span>))</span><br><span class="line">print(<span class="string">'字符串是不是以感叹号开头: '</span>, str1.startswith(<span class="string">'!'</span>))</span><br><span class="line">print(<span class="string">'字符串是不是一感叹号结尾: '</span>, str1.endswith(<span class="string">'!'</span>))</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串的长度是: <span class="number">13</span></span><br><span class="line">单词首字母大写:  Hello, World!</span><br><span class="line">字符串变大写:  HELLO, WORLD!</span><br><span class="line">字符串是不是大写:  <span class="literal">False</span></span><br><span class="line">字符串是不是以hello开头:  <span class="literal">True</span></span><br><span class="line">字符串是不是以hello结尾:  <span class="literal">False</span></span><br><span class="line">字符串是不是以感叹号开头:  <span class="literal">False</span></span><br><span class="line">字符串是不是一感叹号结尾:  <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="迅速去掉字符串的空格符、制表符和换行符"><a href="#迅速去掉字符串的空格符、制表符和换行符" class="headerlink" title="迅速去掉字符串的空格符、制表符和换行符"></a>迅速去掉字符串的空格符、制表符和换行符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aStr = <span class="string">'hello  wel\rcome \t   to   \t  zy \n  oYeah'</span></span><br><span class="line">print(<span class="string">''</span>.join(aStr.split()))</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>字符串的编码解码：用到方法：<code>encode()</code> 和 <code>decode()</code>。编码解码主要针对中文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'董奥250,a good man'</span></span><br><span class="line"></span><br><span class="line">a = str.encode() <span class="comment"># 函数可以写参数，utf-8 或 gbk，表示以相应的编码格式编码</span></span><br><span class="line"></span><br><span class="line">print(a) <span class="comment"># b'\xe8\x91\xa3\xe5\xa5\xa5250,a good man' 以b开头，表示字节流</span></span><br><span class="line"></span><br><span class="line">b = a.decode(<span class="string">'utf-8'</span>) <span class="comment"># 表示以相应的解码格式解码</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ul>
<li>str 使用 <code>encode()</code> 方法转换为 bytes</li>
<li>bytes 通过 <code>decode()</code> 方法转换为 str</li>
</ul>
<h1 id="四、字符串的format格式化"><a href="#四、字符串的format格式化" class="headerlink" title="四、字符串的format格式化"></a>四、字符串的format格式化</h1><h2 id="一、简单运用"><a href="#一、简单运用" class="headerlink" title="一、简单运用"></a>一、简单运用</h2><p>字符串类型格式化采用format()方法，基本使用格式是：</p>
<p>   <strong>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</strong></p>
<p>调用format()方法后会返回一个新的字符串，参数从0开始编号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;&#125;&#123;&#125;&#123;&#125;"</span>.format(<span class="string">"圆周率是"</span>,<span class="number">3.1415926</span>,<span class="string">"..."</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'圆周率是3.1415926...'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;"</span>.format(<span class="string">"无理数"</span>,<span class="number">3.1415926</span>,<span class="string">"..."</span>) <span class="comment"># 输出大括号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'圆周率&#123;3.1415926...&#125;是无理数'</span></span><br><span class="line"> </span><br><span class="line">s=<span class="string">"圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;"</span> <span class="comment">#大括号本身是字符串的一部分</span></span><br><span class="line"> </span><br><span class="line">s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;'</span>	 <span class="comment"># 格式化模板</span></span><br><span class="line"> </span><br><span class="line">s.format(<span class="string">"无理数"</span>,<span class="number">3.1415926</span>,<span class="string">"..."</span>)	 <span class="comment"># 当调用format()时解析大括号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'圆周率&#123;3.1415926...&#125;是无理数'</span></span><br></pre></td></tr></table></figure>

<p>二、格式控制信息 format()方法中 <strong>&lt;模板字符串&gt;</strong> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下：<br>     <code>{&lt;参数序号&gt;: &lt;格式控制标记&gt;}</code></p>
<ul>
<li><p><strong>&lt;参数序号&gt;</strong>：指定的位置，从0开始。</p>
</li>
<li><p><strong>&lt;格式控制标记&gt; **：用来控制参数显示时的格式。包括：</strong>&lt;填充&gt;,&lt;对齐&gt;,&lt;宽度&gt;,&lt;.精度&gt;,&lt;类型&gt;** 6 个字段，这些字段都是可选的，可以组合使用，逐一介绍如下。</p>
</li>
</ul>
<img src="/2020/03/17/Python-2/1.png" class>

<h2 id="lt-宽度-gt"><a href="#lt-宽度-gt" class="headerlink" title="&lt;宽度&gt;"></a>&lt;宽度&gt;</h2><p>指当前槽的设定输出字符宽度，如果该槽对应的format()参数长度比&lt;宽度&gt;设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则位数将被<strong>默认以空格字符补充</strong>。</p>
<h2 id="lt-对齐-gt"><a href="#lt-对齐-gt" class="headerlink" title="&lt;对齐&gt;"></a>&lt;对齐&gt;</h2><p>指参数在&lt;宽度&gt;内输出时的对齐方式，分别使用&lt;、&gt;和^三个符号表示左对齐、右对齐和居中对齐。</p>
<h2 id="lt-填充-gt"><a href="#lt-填充-gt" class="headerlink" title="&lt;填充&gt;"></a>&lt;填充&gt;</h2><p>指&lt;宽度&gt;内除了参数外的字符采用什么方式表示，默认采用空格，可以通过&lt;填充&gt;更换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"PYTHON"</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:30&#125;"</span>.format(s)</span><br><span class="line">Out[<span class="number">17</span>]: <span class="string">'PYTHON                        '</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:&gt;30&#125;"</span>.format(s)</span><br><span class="line">Out[<span class="number">18</span>]: <span class="string">'                        PYTHON'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:*^30&#125;"</span>.format(s)</span><br><span class="line">Out[<span class="number">19</span>]: <span class="string">'************PYTHON************'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:-^30&#125;"</span>.format(s)</span><br><span class="line">Out[<span class="number">20</span>]: <span class="string">'------------PYTHON------------'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:3&#125;"</span>.format(s)</span><br><span class="line">Out[<span class="number">21</span>]: <span class="string">'PYTHON'</span></span><br></pre></td></tr></table></figure>

<h2 id="逗号（，）"><a href="#逗号（，）" class="headerlink" title="逗号（，）"></a>逗号（，）</h2><p>&lt;格式控制标记&gt;中逗号（，）用于显示数字的千位分隔符，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:-^20,&#125;"</span>.format(<span class="number">1234567890</span>)</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">'---1,234,567,890----'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:-^20&#125;"</span>.format(<span class="number">1234567890</span>) <span class="comment"># 对比输出</span></span><br><span class="line">Out[<span class="number">25</span>]: <span class="string">'-----1234567890-----'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:-^20,&#125;"</span>.format(<span class="number">12345.67890</span>)</span><br><span class="line">Out[<span class="number">26</span>]: <span class="string">'----12,345.6789-----'</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-精度-gt"><a href="#lt-精度-gt" class="headerlink" title="&lt;.精度&gt;"></a>&lt;.精度&gt;</h2><p>表示两个含义，由小数点（.）开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:.2f&#125;"</span>.format(<span class="number">12345.67890</span>)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">'12345.68'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:H^20.3f&#125;"</span>.format(<span class="number">12345.67890</span>)</span><br><span class="line">Out[<span class="number">30</span>]: <span class="string">'HHHHH12345.679HHHHHH'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:.4&#125;"</span>.format(<span class="string">"PYTHON"</span>)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">'PYTH'</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-类型-gt"><a href="#lt-类型-gt" class="headerlink" title="&lt;类型&gt;"></a>&lt;类型&gt;</h2><p>表示输出整数和浮点数类型的格式规则。对于<strong>整数</strong>类型，输出格式包括6 种：</p>
<ul>
<li>b: 输出整数的二进制方式；</li>
<li>c: 输出整数对应的 Unicode 字符；</li>
<li>d: 输出整数的十进制方式；</li>
<li>o: 输出整数的八进制方式；</li>
<li>x: 输出整数的小写十六进制方式；</li>
<li>X: 输出整数的大写十六进制方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;"</span>.format(<span class="number">425</span>)</span><br><span class="line">Out[<span class="number">32</span>]: <span class="string">'110101001,Ʃ,425,651,1a9,1A9'</span></span><br></pre></td></tr></table></figure>

<p>对于<strong>浮点数</strong>类型，输出格式包括4 种：</p>
<ul>
<li>e: 输出浮点数对应的小写字母 e 的指数形式；</li>
<li>E: 输出浮点数对应的大写字母 E 的指数形式；</li>
<li>f: 输出浮点数的标准浮点形式；</li>
<li>%: 输出浮点数的百分形式。</li>
</ul>
<blockquote>
<p> 浮点数输出时尽量使用&lt;.精度&gt;表示小数部分的宽度，有助于更好控制输出格式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;"</span>.format(<span class="number">3.14</span>)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="string">'3.140000e+00,3.140000E+00,3.140000,314.000000%'</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"&#123;0:.2e&#125;,&#123;0:.2E&#125;,&#123;0:.2f&#125;,&#123;0:.2%&#125;"</span>.format(<span class="number">3.14</span>)</span><br><span class="line">Out[<span class="number">34</span>]: <span class="string">'3.14e+00,3.14E+00,3.14,314.00%'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB课程总结(一)</title>
    <url>/2020/03/13/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>MATLAB的第一次课堂总结，包括MATLAB中通用的命令、数组矩阵的相关运算，字符串的一些基本命令等。</p>
<a id="more"></a>

<h2 id="MATLAB注意事项"><a href="#MATLAB注意事项" class="headerlink" title="MATLAB注意事项"></a>MATLAB注意事项</h2><p>1、 MATLAB对字母的大小写是敏感的。</p>
<p>2、按照MATLAB的变量定义规则，将所有变量都定义为数组。标量被看作（1×1）的数组，向量认为是（1×n）或（m×1）的数组,矩阵认为是（m×n）的数组。</p>
<h2 id="常见的通用命令"><a href="#常见的通用命令" class="headerlink" title="常见的通用命令"></a>常见的通用命令</h2><p>1、<code>clc</code>清除清除窗口显示内容。</p>
<p>2、<code>who</code>、<code>whos</code>命令显示工作空间的变量，<code>clear</code>清除工作空间的变量。</p>
<p>3、<code>dir</code>命令显示当前工作目录的文件和子目录清单。</p>
<p>4、<code>cd</code>命令显示或设置当前工作目录。</p>
<p>5、<code>type</code>命令显示指定m文件的内容。</p>
<p>6、<code>help</code>或doc命令获取在线帮助。</p>
<ul>
<li>MATLAB提供的帮助信息有两类<ul>
<li>简单纯文本帮助信息<ul>
<li>help</li>
<li>lookfor(条件比较宽松)</li>
</ul>
</li>
<li>窗口式综合帮助信息（文字、公式、图形）<ul>
<li>doc</li>
<li>helpwin</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h2><p>1、<code>sin</code>命令</p>
<p>MATLAB中正弦函数sin就是常见的正弦函数。</p>
<p>它的参数值是以“弧度”为单位的。</p>
<p>pi也是Matalb的预定义变量。</p>
<p>pi=3.14159…</p>
<p>MATLAB对字母大小写是敏感的。</p>
<p>2、开方<code>sqrt(x)</code>，指数函数<code>exp(x)</code>。</p>
<p>3、数组的输入有两种方式：</p>
<ul>
<li>直接输入数组时，数组元素之间用空格或逗号分隔，数组行之间用分号分隔，整个数组放在方括号”[]”里。</li>
<li>也可以分行输入，用回车“Enter”区分行。</li>
</ul>
<p>4、指令的多行输入：在本行命令的末尾加上三个及以上的点<code>...</code>即可。</p>
<h2 id="数值表示、变量及表达式"><a href="#数值表示、变量及表达式" class="headerlink" title="数值表示、变量及表达式"></a>数值表示、变量及表达式</h2><p>1、MATLAB只采用十进制表示数值。</p>
<p>2、变量命名规则</p>
<ul>
<li>变量名函数名对字母大小写敏感</li>
<li>变量第一个字符必须为英文字母</li>
<li>变量可以包含英文字母、数字和下划线</li>
</ul>
<p>3、Matlab预定义的变量</p>
<table>
<thead>
<tr>
<th><strong>变量名</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ans</strong></td>
<td><strong>最近的计算结果的变量名</strong></td>
</tr>
<tr>
<td><strong>eps</strong></td>
<td><strong>MATLAB定义的正的极小值=2.2204e-16</strong></td>
</tr>
<tr>
<td><strong>pi</strong></td>
<td><strong>圆周率π</strong></td>
</tr>
<tr>
<td><strong>inf</strong></td>
<td><strong>∞值，无限大</strong></td>
</tr>
<tr>
<td><strong>i或j</strong></td>
<td><strong>虚数单元，sqrt(-1)</strong></td>
</tr>
<tr>
<td><strong>NaN</strong></td>
<td><strong>非数，0/0、∞/</strong> <strong>∞</strong></td>
</tr>
</tbody></table>
<p><strong>说明</strong>：</p>
<ul>
<li><p>每当MATLAB启动完成，这些变量就被产生。</p>
</li>
<li><p>MATLAB中，被0除不会引起程序中断，给出报警的同时用inf或NaN给出结果。</p>
</li>
<li><p>用户只能临时覆盖这些预定义变量的值，Clear或重启MATLAB可恢复其值。</p>
</li>
</ul>
<p>4、运算符和表达式</p>
<table>
<thead>
<tr>
<th><strong>运算</strong></th>
<th><strong>数学表达式</strong></th>
<th><strong>MATLAB运算符</strong></th>
<th><strong>MATLAB表达式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加</strong></td>
<td><strong>a+b</strong></td>
<td><strong>+</strong></td>
<td><strong>a+b</strong></td>
</tr>
<tr>
<td><strong>减</strong></td>
<td><strong>a-b</strong></td>
<td><strong>-</strong></td>
<td><strong>a-b</strong></td>
</tr>
<tr>
<td><strong>乘</strong></td>
<td><strong>axb</strong></td>
<td>*</td>
<td><strong>a*b</strong></td>
</tr>
<tr>
<td><strong>除</strong></td>
<td><strong>a/b或a\b</strong></td>
<td><strong>/或\</strong></td>
<td><strong>a/b或a\b</strong></td>
</tr>
<tr>
<td><strong>幂</strong></td>
<td><strong>a^b^</strong></td>
<td><strong>^</strong></td>
<td><strong>a^b</strong></td>
</tr>
</tbody></table>
<p><strong>说明</strong>：</p>
<ul>
<li><p>Matlab用“\”和”/”分别表示“左除”和“右除”。对标量而言，两者没有区别。对矩阵产生不同影响。</p>
</li>
<li><p>MATLAB表达式的书写规则与“手写方式”几乎完全相同。</p>
</li>
<li><p>表达式按与常规相同的优先级自左至右执行运算。</p>
</li>
<li><p>优先级：指数运算级别最高，乘除次之，加减最低。</p>
</li>
<li><p>括号改变运算的次序。</p>
</li>
</ul>
<p>5、复数及其运算</p>
<ul>
<li><p>MATLAB中复数的表达：z=a+b*i，其中a、b为实数。</p>
</li>
<li><p>MATLAB把复数作为一个整体，像计算实数一样计算复数。</p>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h3><ul>
<li><p>一维数组，也称为向量(vector) 。行向量(row vector)、列向量(column vector)。</p>
</li>
<li><p>二维数组(矩阵matrix)。</p>
</li>
<li><p>多维数组。</p>
</li>
</ul>
<p><strong>注意</strong>：有效矩阵：每行元素的个数必须相同，每列元素的个数也必须相同。</p>
<h3 id="2、创建一维数组"><a href="#2、创建一维数组" class="headerlink" title="2、创建一维数组"></a>2、创建一维数组</h3><p><strong>① 行向量的创建</strong></p>
<ol>
<li><p>第一种方法：使用方括号“[ ]”操作符</p>
<p>例如：创建数组(行向量)a=[1 3 pi 3+5i] </p>
<p><code>&gt;&gt;a=[1 3 pi 3+5*i]  %or a=[1, 3, pi, 3+5*i]</code> </p>
<p>结果：a= 1.0000      3.0000      3.1416       3.0000 + 5.0000i</p>
</li>
<li><p>第二种方法：使用冒号“:”操作符</p>
<p>利用冒号“:”操作符创建行向量的基本语法格式：</p>
<ul>
<li><p>x=Start:Increment:End</p>
</li>
<li><p>Start表示新向量x的第一个元素；</p>
</li>
<li><p>新向量x的最后一个元素不能大于End ；</p>
</li>
<li><p>Increment可正可负，若负，则必须Start&gt;End；若正，则必须Start&lt;End，否则创建的为空向量。</p>
</li>
<li><p>若Increment=1,则可简写为：x=Start:End。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;b=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">b=<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">&gt;&gt; c=<span class="number">1</span>:<span class="number">2</span>:<span class="number">10</span></span><br><span class="line">c=<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">&gt;&gt;d=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span></span><br><span class="line">d= <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第三种方法：利用函数linspace。</p>
<p><code>x= linspace(x1, x2, n)</code></p>
<ul>
<li>该函数生成一个由n个元素组成的行向量；</li>
<li>x1为其第一个元素；</li>
<li>x2为其最后一个元素；</li>
<li>x1、x2之间元素的间隔=(x2-x1)/(n-1)。</li>
<li>如果忽略参数n，则系统默认生成100个元素的行向量。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;<span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">x=<span class="number">1.0000</span>    <span class="number">1.2500</span>    <span class="number">1.5000</span>    <span class="number">1.7500</span>    <span class="number">2.0000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第四种方法：利用函数logspace</p>
<p><code>x= logspace(x1, x2, n)</code></p>
<ul>
<li>该函数生成一个由n个元素组成的行向量；</li>
<li>x1为其第一个元素，是以10为底的幂；</li>
<li>x2为其最后一个元素，是以10为底的幂；</li>
<li>n是向量中元素的个数；</li>
<li>如果忽略参数n，则系统默认生成50个元素的行向量</li>
</ul>
</li>
</ol>
<p><strong>② 列向量的创建</strong></p>
<ol>
<li><p>使用方括号“[ ]”操作符，使用分号“;”分割行。</p>
</li>
<li><p>使用冒号操作符，最后加上单引号<code>&#39;</code>，表示矩阵的转置。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;x=(<span class="number">1</span>:<span class="number">3</span>)'</span><br><span class="line">x= <span class="number">1</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3、创建数组变量"><a href="#3、创建数组变量" class="headerlink" title="3、创建数组变量"></a>3、创建数组变量</h3><p>创建变量的赋值语句的一般格式: <code>var=expression</code></p>
<ul>
<li><p>var为变量名</p>
</li>
<li><p>expression为MATLAB合法表达式</p>
<ul>
<li><p>可以是单独的常数值或数值数组；</p>
</li>
<li><p>也可以由常数值、其他变量（部分或全部）、数值数组和运算符（+、-等）构成。</p>
<p>例如：<code>a=[0 1+6]; b=[a 6 7]; c=[6 a 7]; d=[6 a 7 a];</code></p>
<img src="/2020/03/13/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class>
</li>
<li><p>一旦被创建，变量就被存储在工作空间，可以通过“Workspace”窗口或在“Command Window”执行“whos”命令察看。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4、创建数组变量"><a href="#4、创建数组变量" class="headerlink" title="4、创建数组变量"></a>4、创建数组变量</h3><ol>
<li><p>第一种方法：使用方括号“[ ]”操作符</p>
<p>使用规则</p>
<ul>
<li>数组元素必须在“[ ]”内键入；</li>
<li>行与行之间须用分号“;” 间隔，也可以在分行处用回车键间隔；</li>
<li>行内元素用空格或逗号“,”间隔。</li>
</ul>
<p>同时可由一维数组构成二维数组。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; b=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]; </span><br><span class="line">&gt;&gt;c=[a;b];</span><br><span class="line">&gt;&gt;d=[a b];</span><br><span class="line">c=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></span><br><span class="line">	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span></span><br><span class="line">d=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方法：函数方法</p>
<blockquote>
<p>函数ones(生成全1矩阵)、zeros (生成全0矩阵) 、eye（生成单位矩阵）、rand（以0~1均匀分布的矩阵）、randn（均值为0，方差为1的高斯分布矩阵）、magic（魔方矩阵，每行、列和对角线元素和相等）、reshape（重新排列矩阵）。</p>
<p>“help elmat”获得基本的矩阵生成和操作函数列表</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%创建全1的3x3数组。</span></span><br><span class="line">   &gt;&gt;<span class="built_in">ones</span>(<span class="number">3</span>)</span><br><span class="line">   <span class="comment">%创建全1的3x4数组。</span></span><br><span class="line">   &gt;&gt;<span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p><strong>reshape</strong>的使用演示：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">   &gt;&gt;a=<span class="number">-4</span>:<span class="number">4</span></span><br><span class="line">   a=</span><br><span class="line">   <span class="number">-4</span> <span class="number">-3</span> <span class="number">-2</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">   &gt;&gt;b=<span class="built_in">reshape</span>(a, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">b=</span><br><span class="line">   <span class="number">-4</span>  <span class="number">-1</span>  <span class="number">2</span></span><br><span class="line">   <span class="number">-3</span>   <span class="number">0</span>  <span class="number">3</span></span><br><span class="line">   <span class="number">-2</span>   <span class="number">1</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>该函数注意：</p>
<ul>
<li>数组元素的排列顺序，从上到下按列排列，先排第一列，然后第二列，…</li>
<li>要求数组的元素总数不变。</li>
</ul>
</li>
</ol>
<h3 id="5、数组元素的标识与寻访"><a href="#5、数组元素的标识与寻访" class="headerlink" title="5、数组元素的标识与寻访"></a>5、数组元素的标识与寻访</h3><ol>
<li><p>“全下标（index）”标识</p>
<p>经典数学教科书采用“全下标”标识法：每一维对应一个下标。</p>
<ul>
<li>如对于二维数组，用“行下标和列下标”标识数组的元素，a(2,3)就表示二维数组a的“第2行第3列”的元素。</li>
<li>对于一维数组，用一个下标即可，b(2)表示一维数组b的第2个元素，无论b是行向量还是列向量。</li>
</ul>
</li>
<li><p>“单下标”（linear index）标识</p>
<p>所谓“单下标”标识就是用一个下标来表明元素在数组的位置。</p>
<ul>
<li>对于二维数组， “单下标”编号：设想把二维数组的所有列，按先后顺序首尾相接排成“一维长列”，然后自上往下对元素位置执行编号。</li>
</ul>
</li>
</ol>
<p><strong>几种表示法</strong>：</p>
<ul>
<li>a(:,n)表示矩阵a所有的行和第n列，即提取矩阵a第n列元素；</li>
<li>a([m,n],[i,j])表示矩阵的第m行与第n行的第i列和第j列，即提取矩阵a第m行与第n行的第i列和第j列元素；</li>
<li>a(m:n,i:j)表示第m行到第n行的第i列到第j列，即提取第m行到第n行的第i列到第j列的所有元素</li>
<li>a(m:end,i)表示第m行到最末行的第i列，即提取第m行到最末行的第i列的元素</li>
</ul>
<h3 id="6、例子"><a href="#6、例子" class="headerlink" title="6、例子"></a>6、例子</h3><ol>
<li><p>单下标的使用</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a=<span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">&gt;&gt;a(:)=<span class="number">-4</span>:<span class="number">5</span></span><br><span class="line">a =</span><br><span class="line">    <span class="number">-4</span>    <span class="number">-2</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">4</span></span><br><span class="line">    <span class="number">-3</span>    <span class="number">-1</span>     <span class="number">1</span>     <span class="number">3</span>     <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>注意数组的排列顺序。</p>
</li>
<li><p>一维数组元素与子数组的寻访与赋值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a=<span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">a =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">3.2500</span>    <span class="number">5.5000</span>    <span class="number">7.7500</span>   <span class="number">10.0000</span></span><br><span class="line">&gt;&gt;a(<span class="number">3</span>)       <span class="comment">%寻访a的第3个元素</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">5.5000</span></span><br><span class="line">&gt;&gt;a([<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>])   <span class="comment">%寻访a的第1、2、5个元素组成的子数组</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">3.2500</span>   <span class="number">10.0000</span></span><br><span class="line">&gt;&gt;a(<span class="number">1</span>:<span class="number">3</span>)   <span class="comment">%寻访前3个元素组成的子数组</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">3.2500</span>    <span class="number">5.5000</span></span><br><span class="line">&gt;&gt;a(<span class="number">3</span>:<span class="number">-1</span>:<span class="number">1</span>)  <span class="comment">%由前3个元素倒序构成的子数组</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">5.5000</span>    <span class="number">3.2500</span>    <span class="number">1.0000</span></span><br><span class="line">&gt;&gt;a(<span class="number">3</span>:<span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">5.5000</span>    <span class="number">7.7500</span>   <span class="number">10.0000</span></span><br><span class="line">&gt;&gt;a(<span class="number">3</span>:<span class="keyword">end</span><span class="number">-1</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">5.5000</span>    <span class="number">7.7500</span></span><br><span class="line">&gt;&gt;a([<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>])  <span class="comment">% 数组元素可以被任意重复访问，构成长度大于原数组的新数组。</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">3.2500</span>    <span class="number">5.5000</span>   <span class="number">10.0000</span>   <span class="number">10.0000</span>    <span class="number">5.5000</span>    <span class="number">3.2500</span>    <span class="number">1.0000</span></span><br><span class="line">&gt;&gt;a(<span class="number">3</span>)=<span class="number">0</span>           <span class="comment">%修改数组a的第3元素值为0</span></span><br><span class="line">a =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">3.2500</span>    <span class="number">0</span>    <span class="number">7.7500</span>   <span class="number">10.0000</span></span><br><span class="line">&gt;&gt;a([<span class="number">2</span> <span class="number">5</span>])=[<span class="number">1</span> <span class="number">1</span>] <span class="comment">%修改多个数组元素的值</span></span><br><span class="line">a =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">1.0000</span>    <span class="number">0</span>    <span class="number">7.7500</span>   <span class="number">1.0000</span></span><br><span class="line">&gt;&gt;a([<span class="number">2</span> <span class="number">5</span>])=[] <span class="comment">%删除对应数组元素的值</span></span><br><span class="line">a =</span><br><span class="line">  <span class="number">1.0000</span>  <span class="number">0</span>    <span class="number">7.7500</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>可以修改指定数组元素的值</li>
<li>一次可以修改多个数组元素的值</li>
<li>要修改的数组元素的个数应与送入数组的元素个数相同</li>
<li>利用方括号（[]）删除矩阵的某行列</li>
</ul>
</li>
<li><p>二维数组元素与子数组的寻访与赋值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a_2=<span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">4</span>) <span class="comment">%创建2x4的全0数组</span></span><br><span class="line">a_2 =</span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">&gt;&gt;a_2(:)=<span class="number">1</span>:<span class="number">8</span>      <span class="comment">%注意元素的排列顺序</span></span><br><span class="line">a_2 =</span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>     <span class="number">5</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">4</span>     <span class="number">6</span>     <span class="number">8</span>            </span><br><span class="line">&gt;&gt;a_2([<span class="number">2</span> <span class="number">5</span> <span class="number">8</span>])    <span class="comment">%单下标方式寻访多个元素</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span></span><br><span class="line">&gt;&gt; a_2([<span class="number">2</span> <span class="number">5</span> <span class="number">8</span>]) =[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line">a_2 =</span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>    <span class="number">20</span>     <span class="number">7</span></span><br><span class="line">    <span class="number">10</span>     <span class="number">4</span>     <span class="number">6</span>    <span class="number">30</span></span><br><span class="line">&gt;&gt;a_2(:,[<span class="number">2</span> <span class="number">3</span>])=<span class="built_in">ones</span>(<span class="number">2</span>)  <span class="comment">%双下标方式寻访并修改</span></span><br><span class="line">a_2 =</span><br><span class="line">     <span class="number">1</span>      <span class="number">1</span>     <span class="number">1</span>    <span class="number">7</span></span><br><span class="line">    <span class="number">10</span>     <span class="number">1</span>     <span class="number">1</span>    <span class="number">30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>二维数组可以“单下标”方式或“全下标”方式访问、赋值；</li>
<li>“单下标”方式赋值时，等号两边涉及的元素个数必须相等；</li>
<li>“全下标”方式赋值时，等号右边数组的大小必须等于原数组中涉及元素构成的子数组的大小。</li>
</ul>
</li>
<li><p>size、length函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a=<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">6</span>)*<span class="number">6</span></span><br><span class="line">&gt;&gt;m=<span class="built_in">size</span>(a)</span><br><span class="line">&gt;&gt;len=<span class="built_in">length</span>(a)</span><br><span class="line">&gt;&gt;b=<span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">&gt;&gt;<span class="built_in">length</span>(b)</span><br><span class="line">&gt;&gt;c=b’</span><br><span class="line">&gt;&gt;<span class="built_in">length</span>(c)</span><br></pre></td></tr></table></figure>

<ul>
<li>size函数返回变量的大小，即变量数组的行列数。</li>
<li>length函数返回变量数组的最大维数。</li>
</ul>
</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h3><ul>
<li><p>Matlab 用「单引号」来界定一个字符串。</p>
</li>
<li><p>可以使用方括号“[ ]”直接连接多个字符串变量，得到一个新字符串变量。</p>
</li>
<li><p>如要输入的字符串中有单引号，则由两个连续的单引号来表示。</p>
</li>
<li><p>若要计算字符串变量的长度（即组成字符串的个数），可用 length 指令。</p>
</li>
<li><p>double 指令: 查看字符串变量的存储內容（即 ASCII 内码）</p>
</li>
<li><p>char 指令: 将 ASCII 內码转换为字符串形式 </p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">str1 = ‘I like MATLAB,’;	    <span class="comment">% 建立字串变量 str1</span></span><br><span class="line">str2 = <span class="string">' JavaScript, and Perl!'</span>;	    <span class="comment">% 建立字串变量str2</span></span><br><span class="line">str3 = [str1 str2]	        <span class="comment">% 直接连接str1及str2，以建立str3</span></span><br><span class="line">str3 =I like MATLAB, JavaScript, and Perl!</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'I''ve got a date!'</span>;</span><br><span class="line"><span class="built_in">length</span>(sentence)	<span class="comment">% 计算字字符串sentence的长度</span></span><br><span class="line"><span class="built_in">ans</span> =     <span class="number">16</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'I''ve got a date!'</span>;</span><br><span class="line">sentenceAscii = double(sentence)   <span class="comment">%查看 sentence 的 ASCII 码</span></span><br><span class="line">sentence2 = char(sentenceAscii)	     <span class="comment">% 将 ASCII 码恢复成字符串形式</span></span><br><span class="line">sentenceAscii =	<span class="number">73</span>   <span class="number">39</span>   <span class="number">118</span>   <span class="number">101</span>   <span class="number">32</span>   <span class="number">103</span>   <span class="number">111</span>   <span class="number">116</span>   <span class="number">32</span>   <span class="number">97</span>  <span class="number">32</span>   <span class="number">100</span>  <span class="number">97</span>   <span class="number">116</span>   <span class="number">101</span>    <span class="number">33</span> </span><br><span class="line">sentence2 =I've got a date!</span><br></pre></td></tr></table></figure>

<h3 id="2、字符串的判断"><a href="#2、字符串的判断" class="headerlink" title="2、字符串的判断"></a>2、字符串的判断</h3><ul>
<li><p>class 或 ischar 指令: 可以用来判断一个变量的类型或它是否为字符串变量。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">chinese = ‘今日事，今日毕<span class="string">';</span></span><br><span class="line"><span class="string">out1 = class(chinese)      % out1 的值是 “char”</span></span><br><span class="line"><span class="string">x = chinese+1;</span></span><br><span class="line"><span class="string">out2 = ischar(x)	           % out2 的值是 0，代表 x 不是字符串变量</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、一个字符数组变量存储多行字符串"><a href="#3、一个字符数组变量存储多行字符串" class="headerlink" title="3、一个字符数组变量存储多行字符串"></a>3、一个字符数组变量存储多行字符串</h3><h4 id="1、使用二维字符数组"><a href="#1、使用二维字符数组" class="headerlink" title="1、使用二维字符数组"></a><strong>1、使用二维字符数组</strong></h4><p><strong>注意</strong>：必须先确认每个字符串（即每一行）的长度一样，否则就必须在短字符串结尾补齐空格。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">departments = [‘ee  ’; ‘cs  ’; ‘econ’]	<span class="comment">%注意语句中空格字符的使用。</span></span><br><span class="line">departments =</span><br><span class="line">	ee  </span><br><span class="line">	cs   </span><br><span class="line">	econ</span><br></pre></td></tr></table></figure>

<h4 id="2、用char-指令存储多字符串"><a href="#2、用char-指令存储多字符串" class="headerlink" title="2、用char 指令存储多字符串"></a><strong>2、用char 指令存储多字符串</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">departments = char(‘ee’, ‘cs’, ‘econ’)      <span class="comment">% 注意空格及「,」的使用</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>从二维字符数组访问字符串时，切记要使用 deblank 指令来清除字符串尾部的空格字符。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">departments = char(<span class="string">'ee'</span>, <span class="string">'cs'</span>, <span class="string">'econ'</span>);</span><br><span class="line">dept1 = departments(<span class="number">1</span>,:);	<span class="comment">% (1,:)代表第一行的全部元素  </span></span><br><span class="line">dept2 = deblank(dept1);	            <span class="comment">% 使用 deblank 指令清除尾部的空格字符   </span></span><br><span class="line">len1 = <span class="built_in">length</span>(dept1)		<span class="comment">% 显示变量 dept1 的长度=4</span></span><br><span class="line">len2 = <span class="built_in">length</span>(dept2)		<span class="comment">% 显示变量 dept2 的长度=2</span></span><br></pre></td></tr></table></figure>

<h4 id="3、字符串比较"><a href="#3、字符串比较" class="headerlink" title="3、字符串比较"></a>3、字符串比较</h4><p>strcmp 指令: 用于比较字符串的內容的异同 。不相等返回0,相等返回1。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'today'</span>;  </span><br><span class="line">str2 = <span class="string">'tomorrow'</span>;  </span><br><span class="line">str3 = <span class="string">'today'</span>;  </span><br><span class="line">out1 = strcmp(str1, str2)	   <span class="comment">% 比较字符串 str1 和 str2 </span></span><br><span class="line">out1 = <span class="number">0</span>                       <span class="comment">%表示字符串 str1 和 str2不同</span></span><br><span class="line">out2 = strcmp(str1, str3)	   <span class="comment">% 比较字符串 str1 和 str3</span></span><br><span class="line">out2 = <span class="number">1</span>                       <span class="comment">%表示字符串 str1 和 str2相同</span></span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>在 MATLAB 的数据类型中，向量可视为一维数组，矩阵可视为二维数组，对于维数超过2的数组均可视为多维数组。</p>
<p>将两个二维（平面）数组叠在一起，就构成三维数组，第三维称为「页」(Page)。</p>
<img src="/2020/03/13/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class>

<p>三维数组，可对应至一个 X - Y - Z 三维立体坐标。</p>
<p>三维数组元素的寻址：可以(行、列、页)来确定。</p>
<img src="/2020/03/13/MATLAB%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class>

<p>数组 A 是三维数组，其中 A(：,：,1)代表第一页的二维数组，A(：,：,2)代表第二页的二维数组。</p>
<h3 id="多维数组的建立"><a href="#多维数组的建立" class="headerlink" title="多维数组的建立"></a>多维数组的建立</h3><p>建立一个简单的多维数组，可直接由 MATLAB 命令视窗内输入（使用“[ ]”操作符）</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A(:, :, <span class="number">1</span>) = [<span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">5</span>; <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">7</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span>];</span><br><span class="line">A(:, :, <span class="number">2</span>) = [<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span>; <span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span>; <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_1(输入输出运算符)</title>
    <url>/2020/03/12/Python-1/</url>
    <content><![CDATA[<p>老师突如其来的爬虫测试让人心里倍生无助感，最后虽说用Java勉强完成了测试，但也乱入进了python领域。算了，python现在这么火，早晚得入门，不如就现在吧。</p>
<a id="more"></a>

<p>主要介绍刚刚入门的一些基础的语法知识，至于前期的环境搭建和IDE的下载，网上教程很多且大多切实可用，这里不再赘述，下面开始介绍基本的，与其他编程语言不一样的语法基础。</p>
<hr>
<h1 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h1><ul>
<li><p>单行注释（用 ‘#’ ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释（三个双引号或单引号包围）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第一行注释</span></span><br><span class="line"><span class="string">第二行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一行注释</span></span><br><span class="line"><span class="string">第二行注释</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><p>定义变量，变量名自定义，满足标识符命名规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 值</span></span><br><span class="line">myData = <span class="string">'Tom'</span></span><br><span class="line">print(myData)</span><br></pre></td></tr></table></figure>

<h1 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h1><img src="/2020/03/12/Python-1/1.png" class>

<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">1</span> <span class="comment"># 整数型</span></span><br><span class="line">num2 = <span class="number">1.1</span> <span class="comment"># 浮点型</span></span><br><span class="line">str = <span class="string">'hello world'</span> <span class="comment"># 字符串型</span></span><br><span class="line">flag = <span class="literal">True</span> <span class="comment"># 布尔型</span></span><br><span class="line">lis = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] <span class="comment"># list列表</span></span><br><span class="line">tup = (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="comment"># tuple元组</span></span><br><span class="line">s = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125; <span class="comment"># set集合</span></span><br><span class="line">dic = &#123;<span class="string">'name'</span>:<span class="string">'Tom'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125; <span class="comment"># dict字典</span></span><br><span class="line"></span><br><span class="line">使用type()函数检查变量的类型</span><br></pre></td></tr></table></figure>

<h1 id="四、输出"><a href="#四、输出" class="headerlink" title="四、输出"></a>四、输出</h1><h2 id="1、格式化输出"><a href="#1、格式化输出" class="headerlink" title="1、格式化输出"></a>1、格式化输出</h2><table>
<thead>
<tr>
<th>转换说明符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>%d</strong>、%i</td>
<td>转换为带符号的十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>转换为带符号的八进制整数</td>
</tr>
<tr>
<td>%x、%X</td>
<td>转换为带符号的十六进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>转化为科学计数法表示的浮点数（e 小写）</td>
</tr>
<tr>
<td>%E</td>
<td>转化为科学计数法表示的浮点数（E 大写）</td>
</tr>
<tr>
<td><strong>%f</strong>、%F</td>
<td>转化为十进制浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>智能选择使用 %f 或 %e 格式</td>
</tr>
<tr>
<td>%G</td>
<td>智能选择使用 %F 或 %E 格式</td>
</tr>
<tr>
<td>%c</td>
<td>格式化字符及其 ASCII 码</td>
</tr>
<tr>
<td>%r</td>
<td>使用 repr() 函数将表达式转换为字符串</td>
</tr>
<tr>
<td><strong>%s</strong></td>
<td>使用 str() 函数将表达式转换为字符串</td>
</tr>
</tbody></table>
<p>%s，%d，%f较为常用。</p>
<p><strong>技巧</strong>：</p>
<ol>
<li><p>%03d：表示输出的整数显示3位数，不足以0不全，超出当前位数则原样输出。</p>
</li>
<li><p>%.2f：表示小数点后显示2位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">'Tom'</span></span><br><span class="line">weight = <span class="number">65.5</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'今年我的年龄是%03d岁'</span> % age) <span class="comment"># %03d 018</span></span><br><span class="line">print(<span class="string">'我的名字是%s'</span> % name)</span><br><span class="line">print(<span class="string">'我的体重是%.3f公斤'</span> % weight)<span class="comment"># %.3f 65.500</span></span><br><span class="line">print(<span class="string">'我叫%s,今年%d岁。'</span> % (name , age))<span class="comment"># 输出多个</span></span><br><span class="line">print(<span class="string">'我叫%s,今年%s岁。'</span> % (name , age)) <span class="comment"># %s可以输出整型，浮点型</span></span><br></pre></td></tr></table></figure>

<p>格式化字符串除了%s，还可以写为<code>f&#39;{表达式}&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">f'我的名字是<span class="subst">&#123;name&#125;</span>,今年<span class="subst">&#123;age&#125;</span>岁了'</span>) <span class="comment"># 结果：我的名字是Tom,今年18岁了</span></span><br></pre></td></tr></table></figure>

<p>f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。</p>
</li>
</ol>
<h2 id="2、转义字符"><a href="#2、转义字符" class="headerlink" title="2、转义字符"></a>2、转义字符</h2><ul>
<li><code>\n</code>：换行。</li>
<li><code>\t</code>：制表符，一个TAB键（4个空格）的举例。</li>
</ul>
<h2 id="3、结束符"><a href="#3、结束符" class="headerlink" title="3、结束符"></a>3、结束符</h2><p><code>print(&#39;输出的内容&#39;,end=&quot;\n&quot;)</code></p>
<blockquote>
<p>在Python中，print()，默认自带<code>end=&quot;\n&quot;</code>这个换行结束符，用户可按需求更改结束符（包括转义字符，或者自定义的字符串等等）。</p>
</blockquote>
<h1 id="五、输入"><a href="#五、输入" class="headerlink" title="五、输入"></a>五、输入</h1><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var = input(<span class="string">"提示信息"</span>)</span><br></pre></td></tr></table></figure>

<p>在Python中，<code>input</code>会把接收到的数据都当作字符串处理，并用变量接收。</p>
<h2 id="2、数据类型转换"><a href="#2、数据类型转换" class="headerlink" title="2、数据类型转换"></a>2、数据类型转换</h2><table>
<thead>
<tr>
<th>函 数</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将 x 转换成整数类型</td>
</tr>
<tr>
<td>float(x)</td>
<td>将 x 转换成浮点数类型</td>
</tr>
<tr>
<td>complex(real，[,imag])</td>
<td>创建一个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x)</td>
<td>将 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str)</td>
<td>计算在字符串中的有效 Python 表达式，并返回一个对象</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将整数 x 转换为一个字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符 x 转换为它对应的整数值</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数 x 转换为一个十六进制字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数 x 转换为一个八进制的字符串</td>
</tr>
</tbody></table>
<h1 id="六、运算符"><a href="#六、运算符" class="headerlink" title="六、运算符"></a>六、运算符</h1><h2 id="1、算数运算符"><a href="#1、算数运算符" class="headerlink" title="1、算数运算符"></a>1、算数运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>12.45 + 15</td>
<td>27.45</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>4.56 - 0.26</td>
<td>4.3</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>5 * 3.6</td>
<td>18.0</td>
</tr>
<tr>
<td>/</td>
<td>除法（和数学中的规则一样）</td>
<td>7 / 2</td>
<td>3.5</td>
</tr>
<tr>
<td>//</td>
<td>整除（只保留商的整数部分）</td>
<td>7 // 2</td>
<td>3</td>
</tr>
<tr>
<td>%</td>
<td>取余，即返回除法的余数</td>
<td>7 % 2</td>
<td>1</td>
</tr>
<tr>
<td>**</td>
<td>幂运算/次方运算，即返回 x 的 y 次方</td>
<td>2 ** 4</td>
<td>16，即 24</td>
</tr>
</tbody></table>
<h2 id="2、赋值运算符"><a href="#2、赋值运算符" class="headerlink" title="2、赋值运算符"></a>2、赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>说 明</th>
<th>用法举例</th>
<th>等价形式</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>最基本的赋值运算</td>
<td>x = y</td>
<td>x = y</td>
</tr>
<tr>
<td>+=</td>
<td>加赋值</td>
<td>x += y</td>
<td>x = x + y</td>
</tr>
<tr>
<td>-=</td>
<td>减赋值</td>
<td>x -= y</td>
<td>x = x - y</td>
</tr>
<tr>
<td>*=</td>
<td>乘赋值</td>
<td>x *= y</td>
<td>x = x * y</td>
</tr>
<tr>
<td>/=</td>
<td>除赋值</td>
<td>x /= y</td>
<td>x = x / y</td>
</tr>
<tr>
<td>%=</td>
<td>取余数赋值</td>
<td>x %= y</td>
<td>x = x % y</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值</td>
<td>x **= y</td>
<td>x = x ** y</td>
</tr>
<tr>
<td>//=</td>
<td>取整数赋值</td>
<td>x //= y</td>
<td>x = x // y</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与赋值</td>
<td>x &amp;= y</td>
<td>x = x &amp; y</td>
</tr>
<tr>
<td>|=</td>
<td>按位或赋值</td>
<td>x |= y</td>
<td>x = x | y</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或赋值</td>
<td>x ^= y</td>
<td>x = x ^ y</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移赋值</td>
<td>x &lt;&lt;= y</td>
<td>x = x &lt;&lt; y，这里的 y 指的是左移的位数</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移赋值</td>
<td>x &gt;&gt;= y</td>
<td>x = x &gt;&gt; y，这里的 y 指的是右移的位数</td>
</tr>
</tbody></table>
<h2 id="3、位运算符"><a href="#3、位运算符" class="headerlink" title="3、位运算符"></a>3、位运算符</h2><table>
<thead>
<tr>
<th>位运算符</th>
<th>说明</th>
<th>使用形式</th>
<th>举 例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>a &amp; b</td>
<td>4 &amp; 5</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td>4 | 5</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>a ^ b</td>
<td>4 ^ 5</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>~a</td>
<td>~4</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移</td>
<td>a &lt;&lt; b</td>
<td>4 &lt;&lt; 2，表示整数 4 按位左移 2 位</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移</td>
<td>a &gt;&gt; b</td>
<td>4 &gt;&gt; 2，表示整数 4 按位右移 2 位</td>
</tr>
</tbody></table>
<h2 id="4、比较运算符"><a href="#4、比较运算符" class="headerlink" title="4、比较运算符"></a>4、比较运算符</h2><table>
<thead>
<tr>
<th>比较运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于，如果<code>&gt;</code>前面的值大于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于，如果<code>&lt;</code>前面的值小于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>==</td>
<td>等于，如果<code>==</code>两边的值相等，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于（等价于数学中的 ≥），如果<code>&gt;=</code>前面的值大于或者等于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于（等价于数学中的 ≤），如果<code>&lt;=</code>前面的值小于或者等于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于（等价于数学中的 ≠），如果<code>!=</code>两边的值不相等，则返回 True，否则返回 False。</td>
</tr>
</tbody></table>
<h2 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h2><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>含义</th>
<th>基本格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>逻辑与运算，等价于数学中的“且”</td>
<td>a and b</td>
<td>当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。</td>
</tr>
<tr>
<td>or</td>
<td>逻辑或运算，等价于数学中的“或”</td>
<td>a or b</td>
<td>当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。</td>
</tr>
<tr>
<td>not</td>
<td>逻辑非运算，等价于数学中的“非”</td>
<td>not a</td>
<td>如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。</td>
</tr>
</tbody></table>
<h2 id="6、三目运算符"><a href="#6、三目运算符" class="headerlink" title="6、三目运算符"></a>6、三目运算符</h2><p>Python利用if else语句提供三目运算符的运算，形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exp1 <span class="keyword">if</span> contion <span class="keyword">else</span> exp2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。</p>
</blockquote>
<p>例如：<code>max = a if a&gt;b else b</code>，表示取a，b的最大值，并赋给max。</p>
<p><strong>三目运算符的嵌套</strong></p>
<p>Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if 和 else 的配对，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> c <span class="keyword">if</span> c&gt;d <span class="keyword">else</span> d</span><br></pre></td></tr></table></figure>

<p>应该理解为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> ( c <span class="keyword">if</span> c&gt;d <span class="keyword">else</span> d )</span><br></pre></td></tr></table></figure>

<h2 id="7、成员运算符"><a href="#7、成员运算符" class="headerlink" title="7、成员运算符"></a>7、成员运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">in</td>
<td align="left">如果在指定的<strong>序列</strong>中找到值返回 True，否则返回 False。</td>
<td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">如果在指定的<strong>序列</strong>中没有找到值返回 True，否则返回 False。</td>
<td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<h2 id="8、身份运算符"><a href="#8、身份运算符" class="headerlink" title="8、身份运算符"></a>8、身份运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is是判断两个标识符是不是引用自一个对象</td>
<td align="left">x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not是判断两个标识符是不是引用自不同对象</td>
<td align="left">x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识（二）</title>
    <url>/2020/03/04/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>继续之前的PHP基础，这次为第二次基础的总结，涉及各种数据类型的介绍等。</p>
<a id="more"></a>

<h2 id="一、整型"><a href="#一、整型" class="headerlink" title="一、整型"></a>一、整型</h2><p><strong>概念</strong>：数据是整数，但根据进制方式不同，有不同的数据格式。</p>
<ul>
<li>十进制：默认格式。</li>
<li>八进制：起始用0作为标识。</li>
<li>十六进制：起始用0x作为标记。</li>
<li>二进制起始使用0b作为标记。</li>
</ul>
<p>虽说有多种进制表示，但PHP<strong>默认</strong>最终输出都以十进制的标准输出。</p>
<p>如果想要保证原来的进制输出，就需要使用printf()函数，和C类似，但不会输出前面的进制标志。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$int1 = <span class="number">123</span>;</span><br><span class="line">$int2 = <span class="number">0123</span>;</span><br><span class="line">$int3 = <span class="number">0x123</span>;</span><br><span class="line">$int4 = <span class="number">0b101</span>;</span><br><span class="line">printf(<span class="string">'123的十进制是：%d,83的八进制是：%o,291的十六进制是：%x,5的二进制是：%b'</span>,$int1,$int2,$int3,$int4);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：整型最大的保存PHP_INT_SIZE,(即8个字节)，最大值为PHP_INT_MAX，最小值-PHP_INT_MAX-1</p>
<p><strong>附（类型转换函数）</strong></p>
<ul>
<li><p>十进制转二进制 decbin() 函数</p>
</li>
<li><p>十进制转八进制 decoct() 函数</p>
</li>
<li><p>十进制转十六进制 dechex() 函数</p>
</li>
<li><p>二进制转十六制进 bin2hex() 函数</p>
</li>
<li><p>二进制转十制进 bindec() 函数</p>
</li>
<li><p>八进制转十进制 octdec() 函数</p>
</li>
<li><p>十六进制转十进制 hexdec()函数</p>
</li>
<li><p><strong>任意进制转换 base_convert() 函数</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$hexadecimal = <span class="string">'A37334'</span>;</span><br><span class="line"><span class="keyword">echo</span> base_convert($hexadecimal, <span class="number">16</span>, <span class="number">2</span>);<span class="comment">//输出 101000110111001100110100</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二、浮点型"><a href="#二、浮点型" class="headerlink" title="二、浮点型"></a>二、浮点型</h2><p>PHP中浮点数的精度是13~14位，PHP7中浮点数的最大值表示：1.8e308</p>
<p>浮点数采用8个字节存储，存储原理为：符号位+54个数值位+9个指数位</p>
<p><strong>注意</strong>：0.3与8.1/2.7比较，计算器不会算出相等的结果。</p>
<h2 id="三、-布尔类型"><a href="#三、-布尔类型" class="headerlink" title="三、 布尔类型"></a>三、 布尔类型</h2><p><code>$res = true;</code></p>
<p><code>$res = FALSE</code>  不区分大小写</p>
<p>PHP中尽量不要直接输出bool类型的值。</p>
<h2 id="四、-字符串型"><a href="#四、-字符串型" class="headerlink" title="四、 字符串型"></a>四、 字符串型</h2><p><strong>定义方法</strong>：</p>
<ul>
<li><p>单引号<code>&#39;&#39;</code>包裹字符</p>
</li>
<li><p>双引号<code>&quot;&quot;</code>包裹字符</p>
</li>
<li><p>定界符包裹：使用PHP中的定界符&lt;&lt;&lt;标识符+标识符结尾形式包裹(多行字符串的一种形式)</p>
<ul>
<li><p>heredoc结构：双引号的一种多行字符串形式</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#EOT并非固定，自己取名即可</span></span><br><span class="line">$str = &lt;&lt;&lt;EOT </span><br><span class="line">	这里都是字符串</span><br><span class="line">EOT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nowdoc结构：单引号的一种多行字符串形式</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#EOT并非固定，自己取名即可</span></span><br><span class="line">$str = &lt;&lt;&lt;<span class="string">'EOT'</span> </span><br><span class="line">	这里都是字符串</span><br><span class="line">EOT;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li>单引号是简单的字符串，可以解析少量转义字符：单引号(\‘)，反斜杠(\\)。</li>
<li>双引号功能较多：<ul>
<li>里面能解释较多转义符：$符号:(\$)，双引号:(\“)，反斜杠:(\\)，回车换行符:(\r\n)，TAB符:(\t)</li>
<li>里面如果有PHP变量，也可以被解析</li>
</ul>
</li>
<li>定界符中heredoc与双引号效果一致，nowdoc与单引号效果一致，唯一区别：定界符会自动保留格式：即字符串内部有换行符等自动保留。</li>
</ol>
<p><strong>注意</strong>：</p>
<ol>
<li>双引号解析变量时，系统是有规矩匹配变量的。<ul>
<li>变量名不要与其他字符或者数字保留在一起：”$abc”系统会自动识别为$abc，而不是$a。<ul>
<li>解决方案1：让变量与后面的内容之间有空格，如”$a bc”，系统则会识别为$a，但是多了一个空格。</li>
<li>解决方案2：使用{}将变量独立包裹起来，如${a}bc，建议使用。</li>
</ul>
</li>
</ul>
</li>
<li>使用定界符定义多行字符串时的规矩：<ul>
<li>定界符内的所有内容（包括注释）都是字符串的内容。</li>
<li>定界符的起始符号之后，结束符号之后不能有任何信息（包括空格，注释）。</li>
<li>结束符必须顶格。</li>
</ul>
</li>
</ol>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><ul>
<li><p>一个英文字符，占一个字节。</p>
</li>
<li><p>一个中文gbk字符，占两个字节。</p>
</li>
<li><p>一个中文utf8字符，占三个字节。</p>
</li>
</ul>
<p>求php字符串的长度，有两个函数：</p>
<ul>
<li><p>strlen(字符串)：求该字符串的“字节数”，也就是占据的字节空间大小。</p>
</li>
<li><p>mb_strlen(字符串)：求该字符串的“字符”个数。</p>
<p>需要注意的是，该函数虽为系统函数，但不能直接调用。需要开启php.ini文件里的mbstring模块。</p>
<img src="/2020/03/04/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" class>

<p>即可。</p>
</li>
</ul>
<h2 id="五、数组类型"><a href="#五、数组类型" class="headerlink" title="五、数组类型"></a>五、数组类型</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>数组是多个元素的序列集合</p>
<ul>
<li>数组由元素组成</li>
<li>数组由下标key和Value组成（键值对）<ul>
<li>如果元素下标都是数字：索引数组</li>
<li>如果元素下标都是字符串：关联数组</li>
<li>既有数字又有字符串：混合数组</li>
</ul>
</li>
<li>数组元素访问通过下标实现</li>
<li>数组通常用来保存一组相关的数据，而不是随意搭配</li>
</ul>
<h3 id="2、使用步骤"><a href="#2、使用步骤" class="headerlink" title="2、使用步骤"></a>2、使用步骤</h3><h4 id="1）定义数组"><a href="#1）定义数组" class="headerlink" title="1）定义数组"></a>1）定义数组</h4><ul>
<li>空数组：值为array()或者[]</li>
<li>非空多元素数组：[‘张三’,’男’,30]</li>
<li>指定下标数组：[‘name’=&gt;’张三’,’gender’=&gt;’男’,’age’=&gt;30]</li>
</ul>
<h4 id="2）添加元素"><a href="#2）添加元素" class="headerlink" title="2）添加元素"></a>2）添加元素</h4><ul>
<li>使用保存数组的变量后加上[]，表示一个系统自动指定下标，然后等于某个值。</li>
<li>指定下标[index]，可以是字符串。</li>
</ul>
<h4 id="3）访问元素"><a href="#3）访问元素" class="headerlink" title="3）访问元素"></a><strong>3）访问元素</strong></h4><ul>
<li>指定元素下标</li>
<li>直接使用，表示访问整个数组，但不能用echo输出，数组结构复杂。</li>
</ul>
<h4 id="4）修改元素"><a href="#4）修改元素" class="headerlink" title="4）修改元素"></a><strong>4）修改元素</strong></h4><ul>
<li>通过下标修改即可。</li>
</ul>
<h4 id="5）删除元素"><a href="#5）删除元素" class="headerlink" title="5）删除元素"></a><strong>5）删除元素</strong></h4><ul>
<li>使用unset()，然后指定数组变量加上[1]，删除指定下标；或删除整个数组。</li>
</ul>
<h4 id="6）使用for循环语句遍历数组"><a href="#6）使用for循环语句遍历数组" class="headerlink" title="6）使用for循环语句遍历数组"></a>6）使用for循环语句遍历数组</h4><p>数组的指针：每一个数组内部，都有一个指针，正常情况下，指针指向数组的某个单元，起初默认位置是指向第一个单元。</p>
<p>php中，有如下函数，可以针对数组指针进行相应操作。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="number">18</span>,<span class="number">22</span>,<span class="number">12</span>);<span class="comment">//定义数组</span></span><br><span class="line"></span><br><span class="line">$re = current($arr);<span class="comment">//取得数组当前指针所在单元的值</span></span><br><span class="line">$re = key($arr);<span class="comment">//取得数组当前指针所在单元的键（下标）</span></span><br><span class="line">$re = next($arr);<span class="comment">//将数组的指针后移一位，并取得新位置的值</span></span><br><span class="line">$re = prev($arr);<span class="comment">//将数组的指针前移一位，并取得新位置的值</span></span><br><span class="line">$re = end($arr);<span class="comment">//将数组的指针移到最后一位，并取得新位置的值</span></span><br><span class="line">$re = reset($arr);<span class="comment">//将数组的指针移到最前一位，并取得新位置的值</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"a"</span>,<span class="number">2</span>=&gt;<span class="string">"b"</span>,<span class="string">"C"</span>,<span class="string">"x"</span>=&gt;<span class="string">"d"</span>,<span class="string">"e"</span>);</span><br><span class="line">$len = count($arr);</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i++)&#123;</span><br><span class="line">    $key = key($arr);</span><br><span class="line">    $value = current($arr);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$key ----- $value\n"</span>;</span><br><span class="line">    next($arr);<span class="comment">//指针后移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果（注意下标规则）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ----- a</span><br><span class="line"><span class="number">2</span> ----- b</span><br><span class="line"><span class="number">3</span> ----- C</span><br><span class="line">x ----- d</span><br><span class="line"><span class="number">4</span> ----- e</span><br></pre></td></tr></table></figure>

<h3 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h3><p>1、索引数组（纯数字下标）添加元素，默认以当前元素的最大下标开始自动加1.</p>
<p>2、索引数组通常都不会刻意指定下标（从0开始自增长）</p>
<p>3、PHP数组特点</p>
<ul>
<li>数组元素没有数量限制，数组不限定长度</li>
<li>数组可以动态增加元素</li>
<li>元素的值可以是任何数据类型</li>
</ul>
<h3 id="4、二维数组"><a href="#4、二维数组" class="headerlink" title="4、二维数组"></a>4、二维数组</h3><p><strong>概念</strong>：数组中的元素本身也是一个数组。</p>
<ul>
<li>二维数组的元素都是一个一维数组。</li>
<li>二维数组的第一维下标通常是索引，第二维是关联。</li>
</ul>
<p><strong>定义步骤</strong>：</p>
<p>1、定义一维数组，保存到变量。</p>
<p>2、定义一个新数组，将原来的数组保存到新数组元素中。</p>
<p>3、数组访问先通过一维下标找到对应的元素，然后通过二维下标找到更深的元素。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一维数组</span></span><br><span class="line">$p1 = <span class="keyword">array</span>(<span class="string">'name'</span> =&gt; <span class="string">'鸣人'</span>,<span class="string">'skill'</span> =&gt; <span class="string">'影分身'</span>);</span><br><span class="line">$p2 = <span class="keyword">array</span>(<span class="string">'name'</span> =&gt; <span class="string">'佐助'</span>,<span class="string">'skill'</span> =&gt; <span class="string">'千鸟'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义二维数组</span></span><br><span class="line">$p = <span class="keyword">array</span>($p1,$p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问元素：通常是访问二维元素</span></span><br><span class="line"><span class="comment">#获取第一元素的名字</span></span><br><span class="line"><span class="keyword">echo</span> $p[<span class="number">0</span>][<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#追加一个数组元素</span></span><br><span class="line">$p[] = <span class="keyword">array</span>(<span class="string">'name'</span> =&gt; <span class="string">'小樱'</span>,<span class="string">'skill'</span> =&gt; <span class="string">'治疗术'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="六、类型判定和转换"><a href="#六、类型判定和转换" class="headerlink" title="六、类型判定和转换"></a>六、类型判定和转换</h2><h3 id="1、类型判定"><a href="#1、类型判定" class="headerlink" title="1、类型判定"></a>1、类型判定</h3><p><strong>概念：</strong>即对存储数据的变量（本质是数据）进行类型确定。</p>
<p>PHP提供了一套类型判定的函数，以供使用：</p>
<ul>
<li>函数不需死记硬背，都是is_+数据类型 组成。<ul>
<li>is_int：判断整型</li>
<li>is_float：判断浮点型</li>
<li>is_bool：判断布尔型</li>
<li>is_string：判断字符串型</li>
<li>is_null：判断空型</li>
<li>is_array：判断数组型</li>
<li>is_resource：判断资源型</li>
<li>is_object：判断对象型</li>
</ul>
</li>
<li>函数在操作手册中都有，输入is_即可查看所有。</li>
</ul>
<p><strong>常用的类型判定：</strong></p>
<ul>
<li>is_numeric：判断数据是否是数值，包括数值型数组，<code>$str=&#39;100&#39;</code>,为true。</li>
<li>is_scalar：是否是标量（基础类型）数据。</li>
<li>类型代表：is_int，是否为整数。</li>
</ul>
<h3 id="2、类型转换"><a href="#2、类型转换" class="headerlink" title="2、类型转换"></a>2、类型转换</h3><p>概念：即将某种不符合的类型转换为目标类型。</p>
<ul>
<li>自动转换：系统自动转换，方便。</li>
<li>强制转换：通过代码强制转换成目标类型，效率高。</li>
</ul>
<h4 id="强制转换实现步骤："><a href="#强制转换实现步骤：" class="headerlink" title="强制转换实现步骤："></a>强制转换实现步骤：</h4><p>1）明确所需要类型</p>
<p>2）强制转换为所需类型</p>
<ul>
<li>不改变原来数据：在数据前使用（目标类型），如<code>(int)$a</code>。</li>
<li>改变原来数据：使用settype(变量,’目标类型’)，如<code>settype($a,&#39;bool&#39;)</code>，将变量a的类型转为bool类型。</li>
<li>强制转换的类型：资源和NULL类型不能强制转换。</li>
</ul>
<h4 id="常见的转换逻辑："><a href="#常见的转换逻辑：" class="headerlink" title="常见的转换逻辑："></a>常见的转换逻辑：</h4><p>1）字符串转为数值</p>
<ul>
<li>纯数字字符串—&gt;相应数值：’123.1’=&gt;123.1</li>
<li>数值开头但有字母—&gt;保留数字部分：’12a’=&gt;12</li>
<li>小数点开头—&gt;保留第一个小数点及之后的连续数字：’.1.1.a’=&gt;0.1</li>
<li>字母开头 —&gt;0：’a123’=&gt;0</li>
</ul>
<p>2）其他类型转为布尔：极少数转换为FALSE，基本都是TRUE。以下为FALSE的情况。</p>
<ul>
<li>整数0转为布尔</li>
<li>浮点数0.0转为布尔</li>
<li>空白字符串和字符串 ‘0’ 转为布尔</li>
<li>空数组array()转布尔：</li>
<li>空类型NULL转布尔</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本工作流程</title>
    <url>/2020/03/03/Typora%E7%BC%96%E8%BE%91%E5%99%A8%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E4%B9%A6%E5%86%99%E5%8D%B3%E4%B8%BA%E7%BE%8E%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="Typora编辑器————书写即为美学"><a href="#Typora编辑器————书写即为美学" class="headerlink" title="Typora编辑器————书写即为美学"></a>Typora编辑器————书写即为美学</h1><a id="more"></a>

<p> 发表于 2018-02-08 | <a href="https://baka943.coding.me/2018/02/08/2018-02-08-TyporaSimpleDoc/#comments" target="_blank" rel="noopener">0</a></p>
<p>我也是初学者，公认个人经验总结，不保证质量。</p>
<p>考虑到hexo渲染和Typora渲染差异很大，建议复制<a href="https://paste.ubuntu.com/26540980/" target="_blank" rel="noopener">此处</a>原始码，在本机上测试效果。</p>
<p>官方网站：<a href="https://www.typora.io/" target="_blank" rel="noopener">https</a> : <a href="https://www.typora.io/" target="_blank" rel="noopener">//www.typora.io/</a></p>
<p>支持平台：</p>
<ul>
<li>视窗</li>
<li>的Linux</li>
<li>OSX</li>
</ul>
<p>特点：</p>
<ul>
<li>完美支持Github的Markdown语法；</li>
<li>人性化的书写方式：<ul>
<li>表格的书写，挪动；</li>
<li>图片，超链接，网页表格复制；</li>
<li>目录生成；</li>
</ul>
</li>
<li>支持LeTex公式书写；</li>
<li>支持流程图，美人鱼等流程图图；</li>
<li>emoji，高亮，备注，上标，下标等书写；</li>
<li>生成网页，pdf，图片，甚至单词，LeTex等格式。</li>
</ul>
<h2 id="基本的带快捷键的Markdown书写演示"><a href="#基本的带快捷键的Markdown书写演示" class="headerlink" title="基本的带快捷键的Markdown书写演示"></a>基本的带快捷键的Markdown书写演示</h2><p><code>Ctrl 0</code>到<code>Ctrl 4</code>：普通文本，一级〜四级标题；</p>
<p><code>Ctrl B</code>：加粗，<strong>加粗测试</strong>；</p>
<p><code>Ctrl I</code>：斜体，<em>斜体测试</em>；</p>
<p><code>Ctrl U</code>：下划线，下划线测试；</p>
<p><code>Shift Alt 5</code>：删除线，<del>删除线测试</del>；</p>
<p><code>Shift Ctrl Tab键上面那个键</code>：行内代码块，<code>行内代码块测试</code>；</p>
<p><code>Ctrl K</code>：超链接，<a href="https://baka943.coding.me/2018/02/08/2018-02-08-TyporaSimpleDoc/www.baidu.com" target="_blank" rel="noopener">超链接测试</a>；还支持文章内锚点，请<code>Ctrl</code>点击此处：arrow_right：[第二节](<a href="https://baka943.coding.me/2018/02/08/2018-02-08-TyporaSimpleDoc/#基本的不带快捷键" target="_blank" rel="noopener">https://baka943.coding.me/2018/02/08/2018-02-08-TyporaSimpleDoc/#基本的不带快捷键</a> Markdown 书写演示)；</p>
<p><code>Ctrl T</code>：表格，支持拖拽移动，网页端表格复制转换：</p>
<table>
<thead>
<tr>
<th align="center">标题</th>
<th align="center">数据一<br>山东</th>
<th align="center">数据二</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表格测试</td>
<td align="center">943</td>
<td align="center">巴卡</td>
</tr>
</tbody></table>
<p><code>Ctrl Shift Q</code>：引用：</p>
<blockquote>
<p>我需要三件东西：爱情，友谊和图书。而这三者之间何其相通！</p>
<p>炽热的爱情可以充实图书的内容，图书又是人们最忠实的朋友。</p>
<p>-蒙田</p>
</blockquote>
<p><code>Shift Ctrl I</code>：图片：</p>
<p><a href="https://static.pexels.com/photos/461797/pexels-photo-461797.jpeg" target="_blank" rel="noopener"><img src="https://static.pexels.com/photos/461797/pexels-photo-461797.jpeg" alt="风景"></a></p>
<p><code>Shift Ctrl M</code>：公示块，快捷输入LeTex公式：<br>$$<br>Euler的身份：e ^ {i \ pi} + 1 = 0<br>$$</p>
<h2 id="基本的不带快捷键Markdown书写演示"><a href="#基本的不带快捷键Markdown书写演示" class="headerlink" title="基本的不带快捷键Markdown书写演示"></a>基本的不带快捷键Markdown书写演示</h2><p><strong>部分功能需要现在配置文件中开启才能使用</strong></p>
<p>代码块（我居然不能转义那个字符，就Tab键上面那个）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">！＃在&#x2F; usr &#x2F; bin中&#x2F; python3 </span><br><span class="line">进口 OS </span><br><span class="line">与开放（&#39;LIST.TXT&#39; ，&#39;W&#39; ）为 F：对于我在范围（10）：		f.writelines（STR（I））   	印刷（“成功写入数列&#39;）os.system（&#39;rm .&#x2F;List.txt&#39;）print（&#39;成功删除文件&#39;）</span><br></pre></td></tr></table></figure>

<p>无序，有序，任务列表：</p>
<ul>
<li>酒石酸菌</li>
<li>玄墨之蝶</li>
</ul>
<ol>
<li>的HTML</li>
<li>Python 3</li>
</ol>
<ul>
<li>1.12.2教程计划</li>
<li>Weblate翻译计划</li>
<li>所有The Mods 3实况计划</li>
</ul>
<p>参考链接：</p>
<p>通过培养试验研究了有机酸对铅，镉的毒害影响，结果表明柠檬酸对铅[^ 1]，酒石酸对镉有较明显的解毒作用[^ 2]。使用逐步提取法研究萝卜根叶内重金属存在的化学形态，有机酸处理并不影响各形态铅的优势顺序，但各形态铅的浓度或相对百分率发生了变化。</p>
<p>[^ 1]：陈苏。污染土壤中镉，铅的活化及植物有效研究[D]。中国科学院沉阳应用生态研究所，2007。<br>[^ 2]：陈英旭，林琦，陆芳等。关键词：有机酸对铅，镉植株危害的解毒作用研究 环境科学学报，2000，20（4）：467-472。</p>
<p>上标下标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上标：X ^ 2 ^ </span><br><span class="line">下标：H〜2〜O</span><br></pre></td></tr></table></figure>

<p>X ^ 2 ^，H〜2〜O</p>
<p>高亮：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本节课重点：&#x3D;&#x3D;第六，七章不考&#x3D;&#x3D;，第三章出题之处，&#x3D;&#x3D;平时分占30％&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>本节课重点：==第六，七章不考==，第三章出题之处，==平时分占30％==</p>
<p>注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;！-这一段不要显示出来-&gt;</span><br></pre></td></tr></table></figure>

<p>内联公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ e ^ &#123;i \ pi&#125; + 1 &#x3D; 0 $</span><br></pre></td></tr></table></figure>

<p>$ e ^ {i \ pi} + 1 = 0 $</p>
<p>分割线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我绝不会弃坑的！</p>
<hr>
<p>：arrow_up：上面的都是假话</p>
<p>emoji图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">：arrow_heading_down：：arrow_heading_up：：</span><br><span class="line">ab：：blue_heart：：jack_o_lantern </span><br><span class="line">：：ballot_box_with_check：：fork_and_knife：</span><br></pre></td></tr></table></figure>

<p>：arrow_heading_down：：arrow_heading_up：：<br>ab：：blue_heart：：jack_o_lantern<br>：：ballot_box_with_check：：fork_and_knife：</p>
<p>目录生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[目录]</span><br></pre></td></tr></table></figure>

<p>[目录]</p>
<h1 id="Markdown拓展功能"><a href="#Markdown拓展功能" class="headerlink" title="Markdown拓展功能"></a>Markdown拓展功能</h1><p>HTML原生支持，目前只支持img标签，可以自定义图片大小和缩放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src &#x3D;“ https:&#x2F;&#x2F;static.pexels.com&#x2F;photos&#x2F;461797&#x2F;pexels-photo-461797.jpeg width &#x3D;” 550px“ alt &#x3D;” test“&gt; &lt;&#x2F; img&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://static.pexels.com/photos/461797/pexels-photo-461797.jpeg" target="_blank" rel="noopener"><img src="https://static.pexels.com/photos/461797/pexels-photo-461797.jpeg" alt="测试"></a></p>
<p>LaTex公式支持，包括mhchem，AMSmath，BBox：</p>
<p>mhchem：<br>$$<br>\ ce {SO4 ^ 2- + Ba ^ 2 +-&gt; BaSO4 v}<br>$$<br>BBox：<br>$$<br>\ bbox [5px，border：2px纯红色] {AB ^ 2 + AC ^ 2 = BC ^ 2 }<br>$$</p>
<p>流程图支持，内置了流程图，序列，美人鱼引擎，支持多种多样的流程图，时序图，甘特图：</p>
<ul>
<li>流程图（流程图）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st &#x3D;&gt;开始：开始：&gt; http:&#x2F;&#x2F;www.google.com [空白] </span><br><span class="line">e &#x3D;&gt;结束：&gt; http:&#x2F;&#x2F;www.google.com </span><br><span class="line">op1 &#x3D;&gt;操作：“我的操作” </span><br><span class="line">子1 &#x3D;&gt;子例程：“我的子例程” </span><br><span class="line">条件&#x3D;&gt;条件：是</span><br><span class="line">或否？：&gt; http:&#x2F;&#x2F;www.google.com </span><br><span class="line">io &#x3D;&gt; inputoutput：抓住了一些东西...</span><br><span class="line"></span><br><span class="line">st-&gt; op1-&gt; cond </span><br><span class="line">cond（yes）-&gt; io-&gt; e </span><br><span class="line">cond（no）-&gt; sub1（right）-&gt; op1</span><br></pre></td></tr></table></figure>

<ul>
<li>流程图（美人鱼）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图TD; </span><br><span class="line">    开始-&gt;条件B; </span><br><span class="line">    条件A-&gt;条件C; </span><br><span class="line">    条件B-&gt;条件D; </span><br><span class="line">    条件C-&gt;条件D; </span><br><span class="line">    条件A-&gt;条件D; </span><br><span class="line">    开始-&gt;条件C; </span><br><span class="line">    开始-&gt;条件A; </span><br><span class="line">    条件D-&gt;结束;</span><br></pre></td></tr></table></figure>

<ul>
<li>时序图（美人鱼）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">    参与者Alice </span><br><span class="line">    参与者Bob </span><br><span class="line">    Alice-&gt;&gt; John：约翰你好，你好吗？</span><br><span class="line">    循环健康检查</span><br><span class="line">        John-&gt;&gt; John：对抗软骨垂体病</span><br><span class="line">    终结</span><br><span class="line">    注意John的权利：理性思想&lt;br&#x2F;&gt; ... </span><br><span class="line">    John-&gt;&gt; Alice：太好了！</span><br><span class="line">    John-&gt;&gt; Bob：你呢？</span><br><span class="line">    鲍勃（Bob）-&gt;&gt;约翰（John）：很好！</span><br></pre></td></tr></table></figure>

<ul>
<li>时序图（序列）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爱丽丝-&gt;&gt;约翰：约翰你好，你好吗？</span><br><span class="line">注意约翰的权利：理性思想</span><br><span class="line">约翰-&gt;&gt;爱丽丝：太好了！</span><br><span class="line">John-&gt;&gt; Bob：你呢？</span><br><span class="line">鲍勃（Bob）-&gt;&gt;约翰（John）：很好！</span><br></pre></td></tr></table></figure>

<ul>
<li>甘特图（美人鱼）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt </span><br><span class="line">        dateFormat YYYY-MM-DD </span><br><span class="line">        标题为人鱼</span><br><span class="line">        节A节添加GANTT图功能</span><br><span class="line">        已完成的任务：done，des1、2014-01-06、2014-01-08 </span><br><span class="line">        活动任务：active，des2、2014-01-09、3d </span><br><span class="line">        Future任务：DES3，DES2后，5D </span><br><span class="line">        未来TASK2：des4，DES3后，5D </span><br><span class="line">        部分关键任务</span><br><span class="line">        已完成任务的临界线：暴击，完成后，2014-01-06,24h </span><br><span class="line">        实现解析器和jison：暴击，完成，DES1后， 2d </span><br><span class="line">        为解析器：crit，active，3d创建测试</span><br><span class="line">        关键行：crit，5d中的未来任务</span><br><span class="line">        为渲染器：2d创建测试</span><br><span class="line">        添加到美人鱼：1d</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>其他美人鱼图（目前还有点问题，不建议使用）</li>
<li>类图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDiagram </span><br><span class="line">Class01 &lt;|-AveryLongClass：Cool </span><br><span class="line">Class03 *-Class04 </span><br><span class="line">Class05 o-- Class06 </span><br><span class="line">Class07 .. Class08 </span><br><span class="line">Class09-&gt; C2：我在哪里？</span><br><span class="line">Class09-* C3 </span><br><span class="line">Class09-|&gt; Class07 </span><br><span class="line">Class07：equals（）</span><br><span class="line">Class07：Object [] elementData </span><br><span class="line">Class01：size（）</span><br><span class="line">Class01：int </span><br><span class="line">chimp Class01：int gorilla </span><br><span class="line">Class08 &lt;-&gt; C2：酷标签</span><br></pre></td></tr></table></figure>

<ul>
<li>吉特</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitGraph：</span><br><span class="line">选项</span><br><span class="line">&#123; </span><br><span class="line">    “nodeSpacing”：100，</span><br><span class="line">    “nodeRadius”：10 </span><br><span class="line">&#125; </span><br><span class="line">端</span><br><span class="line">提交</span><br><span class="line">分支newbranch </span><br><span class="line">结帐newbranch </span><br><span class="line">提交</span><br><span class="line">提交</span><br><span class="line">结帐主</span><br><span class="line">提交</span><br><span class="line">提交</span><br><span class="line">合并newbranch</span><br></pre></td></tr></table></figure>

<h2 id="主题替换"><a href="#主题替换" class="headerlink" title="主题替换"></a>主题替换</h2><p>访问：<a href="http://theme.typora.io/" target="_blank" rel="noopener">http</a> : <a href="http://theme.typora.io/" target="_blank" rel="noopener">//theme.typora.io/</a></p>
<h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><ul>
<li>图片（非常适合手机阅读）</li>
<li>PDF格式</li>
<li>HTML（可选是否带样式表）</li>
<li>其他需要第三方库支持</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>We Are All Fighters</title>
    <url>/2020/03/03/We-Are-All-Fighters/</url>
    <content><![CDATA[<p>一个video。</p>
<a id="more"></a>

<hr>
<iframe src="//player.bilibili.com/player.html?aid=90376384&cid=154346256&page=1" width="100%" height="450" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
​          <p align="right"> <b>  ————To the battle we are fighting</b></p>]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>epidemic</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本工作流程</title>
    <url>/2020/03/02/Git%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Git基本工作流程："><a href="#Git基本工作流程：" class="headerlink" title="Git基本工作流程："></a>Git基本工作流程：</h2><a id="more"></a>

<h3 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h3><p>1、Git Repository（Git仓库）最终确定的文件保存到仓库，成为一个新的版本，并对他人可见<br>2、暂存区 暂存已经修改的文件最后统一提交到Git仓库中<br>3、工作区（Working Directory）添加、编辑、修改文件等动作</p>
<h3 id="一些需要记住的命令"><a href="#一些需要记住的命令" class="headerlink" title="一些需要记住的命令"></a>一些需要记住的命令</h3><ul>
<li>git status：确定文件当前所处Git工作区域；</li>
</ul>
<p>这里假设在工作区有文件 <code>HelloWorld.cpp</code></p>
<ol>
<li>工作区转入暂存区：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add HelloWorld.cpp；</span><br></pre></td></tr></table></figure>

<ol>
<li>暂存区转入Git 仓库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git commit –m &#39;提交描述&#39;</span><br></pre></td></tr></table></figure>

<ol>
<li>确定文件是否已在Git仓库中：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<ol>
<li>删除工作区文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm –f 文件名</span><br></pre></td></tr></table></figure>

<p>例如：<code>git rm –f a.txt</code></p>
<ol>
<li>修改文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi 文件名</span><br></pre></td></tr></table></figure>

<p>例如 <code>vi a.txt</code>进入vim修改文件（退出使用：<code>wq</code>）</p>
<blockquote>
<p>如果对vim操作理解有困难的还是建议看一下视频，视频讲了增删改查的相应操作，看一下vim操作指南，对vim操作有全面的认识</p>
</blockquote>
<h2 id="Git基础设置："><a href="#Git基础设置：" class="headerlink" title="Git基础设置："></a>Git基础设置：</h2><ol>
<li>设置用户名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config –-global user.name &#39;这里填写自己的用户名&#39;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置用户名邮箱</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config –-global user.email &#39;这里填写自己的用户名邮箱&#39;</span><br></pre></td></tr></table></figure>

<ol>
<li>查看设置</li>
</ol>
<blockquote>
<p>注意：该设置在GitHub仓库主页显示谁提交了该文件，注意这里的 - 数目为2！</p>
</blockquote>
<h2 id="初始化一个新的Git仓库："><a href="#初始化一个新的Git仓库：" class="headerlink" title="初始化一个新的Git仓库："></a>初始化一个新的Git仓库：</h2><ol>
<li>创建文件夹</li>
<li>在文件夹内初始化Git（创建Git 仓库）</li>
</ol>
<p>命令行进入当前目录，使用 <code>git init</code>命令，成功会显示<code>.git</code>文件</p>
<ol>
<li>向仓库中添加文件</li>
</ol>
<h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><p><strong>使用目的</strong>：备份、实现代码共享集中化管理</p>
<p><a href="https://github.com/yezhaodan/-Git/blob/master/images/git.png" target="_blank" rel="noopener"><img src="https://github.com/yezhaodan/-Git/raw/master/images/git.png" alt="git远程仓库"></a></p>
<p>如何将本地仓库同步到远程仓库中：</p>
<ol>
<li>将远程仓库（github对应的项目）复制到本地：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：仓库地址在clone or download按钮下取得</p>
</blockquote>
<ol>
<li>进行文件增删改查，并添加到Git仓库中</li>
<li>将本地仓库同步到远程仓库中 使用命令：<code>git push</code></li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器Ubuntu的搭建</title>
    <url>/2020/03/01/web%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>主要是总结这次搭建云服务器时的配置操作。</p>
<a id="more"></a>

<p>执行下列命令：</p>
<p>1、<code>sudo apt-get update</code></p>
<p>2、<code>apt-get install openssh-server</code></p>
<p>3、<code>apt-get install default-jre</code></p>
<p>4、<code>apt-get install default-jdk</code></p>
<p>5、<code>cd /usr/local</code>该目录下一般装一些自己的软件</p>
<p>6、<code>wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.tar.gz</code>   wget一般用于下载一些网络地址的资源（此处资源为Tomcat9）</p>
<p>7、<code>ll -s</code>  查看当前文件夹的内容    </p>
<img src="/2020/03/01/web%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" class>

<p>如图，蓝色代表文件夹，红色表示压缩包，浅蓝色代表快捷方式。</p>
<p>8、<code>tar -zxvf apache-tomcat-9.0.31.tar.gz</code> 进行解压缩</p>
<p>9、进入到apache的bin目录下，利用命令<code>./startup.sh</code> 启动。</p>
<p>10、<code>./shutdown.sh</code> 停止服务。</p>
<p>11、<code>cd ..   cd conf</code>进入conf目录，然后``vi server.xml<code>，使用</code>i` 命令进行编辑。</p>
<p>将端口改为80，保存退出。</p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSDN的markdown格式</title>
    <url>/2020/02/29/CSDN%E7%9A%84markdown%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>@<a href="CSDN的markdown格式">TOC</a></p>
<h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p>
<a id="more"></a>

<h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p>
<ol>
<li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li>
<li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li>
<li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li>
<li>全新的 <strong>KaTeX数学公式</strong> 语法；</li>
<li>增加了支持<strong>甘特图的mermaid语法<a href="[mermaid语法说明](https://mermaidjs.github.io/)">^1</a></strong> 功能；</li>
<li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li>
<li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li>
<li>增加了 <strong>检查列表</strong> 功能。</li>
</ol>
<h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a><strong>功能快捷键</strong></h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p>
<h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p>
<h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p>
<p><strong>加粗文本</strong> <strong>加粗文本</strong></p>
<p>==标记文本==</p>
<p><del>删除文本</del></p>
<blockquote>
<p>引用文本</p>
</blockquote>
<p>H<del>2</del>O is是液体。</p>
<p>2^10^ 运算结果是 1024.</p>
<h3 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h3><p>链接: <a href="https://mp.csdn.net" target="_blank" rel="noopener">link</a>.</p>
<p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p>
<p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p>
<p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p>
<p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p>
<p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p>
<h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/configure" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul>
<li>项目<ul>
<li>项目<ul>
<li>项目</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>项目1</li>
<li>项目2</li>
<li>项目3</li>
</ol>
<ul>
<li><input disabled type="checkbox"> 计划任务</li>
<li><input checked disabled type="checkbox"> 完成任务</li>
</ul>
<h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>| 项目 | Value |<br>| —- | —– |<br>| 电脑 | $1600 |<br>| 手机 | $12   |<br>| 导管 | $1    |</p>
<h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>|     第一列     |         第二列 | 第三列         |<br>| :————: | ————-: | :————- |<br>| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |</p>
<h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p>
<h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p>
<h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p>
<p>*[HTML]:   超文本标记语言</p>
<h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p>
<p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p>
<p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p>
<blockquote>
<p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li>
</ul>
<h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure>

<p>这将产生一个流程图。:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li>
</ul>
<h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li>
</ul>
<h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识（一）</title>
    <url>/2020/02/29/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>PHP的入门总结，主要是PHP的基础方面。非常基础，适合入门学习。</p>
<a id="more"></a>

<h2 id="一、PHP语法规则"><a href="#一、PHP语法规则" class="headerlink" title="一、PHP语法规则"></a>一、PHP语法规则</h2><h3 id="1、PHP标记"><a href="#1、PHP标记" class="headerlink" title="1、PHP标记"></a>1、PHP标记</h3><p>PHP标记是用来帮助PHP引擎识别PHP代码的，PHP标记分为两个部分。</p>
<ul>
<li>标记开始：&lt;?php</li>
<li>标记结束：?&gt;</li>
</ul>
<p>在两个标记中间添加php代码，如果该文件是php文件，则建议不写结束标记  ?&gt; 。</p>
<h3 id="2、PHP注释"><a href="#2、PHP注释" class="headerlink" title="2、PHP注释"></a>2、PHP注释</h3><p>行注释：#或//</p>
<p>块注释：/*   */</p>
<h3 id="3、语句结束符"><a href="#3、语句结束符" class="headerlink" title="3、语句结束符"></a>3、语句结束符</h3><p>每个语句以英文分号 ; 作为结束标志。</p>
<h2 id="二、PHP基础知识"><a href="#二、PHP基础知识" class="headerlink" title="二、PHP基础知识"></a>二、PHP基础知识</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p><strong>PHP变量</strong>：一种能够存储数据的符号，值可以改变。</p>
<ul>
<li>所有变量都是以<code>$</code>符号开始。</li>
<li>变量所保存的数据都可以随意改变。</li>
<li>变量必须先定义才能使用，否则报错。</li>
</ul>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">$num = <span class="number">10</span>;</span><br><span class="line"><span class="comment"># 修改变量</span></span><br><span class="line">$num = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment"># 打印变量</span></span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br><span class="line"><span class="comment">#检测变量是否设置，并且不是 NULL</span></span><br><span class="line"><span class="keyword">isset</span>($num);</span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">unset</span>($num);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>变量名区分大小写。</p>
</li>
<li><p>先定义再访问。</p>
</li>
<li><p>PHP是一种弱类型语音，可以存储任何数据。</p>
</li>
</ul>
<h3 id="2、预定义变量"><a href="#2、预定义变量" class="headerlink" title="2、预定义变量"></a>2、预定义变量</h3><p><strong>概念</strong>：PHP系统内部定义的变量，也是PHP系统自动收集的结果。</p>
<ul>
<li><p>预定义变量也是变量，符合变量规则</p>
</li>
<li><p>预定义变量都是数组</p>
</li>
<li><p>系统提供了九个预定义变量，每个变量都有自己特定的数据。</p>
<ul>
<li>$_GET：用户通过get方式提交的数据。</li>
<li>$_POST：用户通过post方式提交的数据。</li>
<li>$_REQUEST：用户通过get和post方式提交的数据。</li>
<li>$_SERVER：用户和服务器的基本信息数据（数据的名字不由开发者控制，系统定义好）</li>
<li>$_FILES：用户提交的文件数据，(文件上传 )。</li>
<li>$_SESSION： session数据。</li>
<li>$_COOKIE： cookie数据。</li>
<li>$GLOBALS：所有全局变量，也是唯一一个不是以下划线开始的预定义变量。</li>
<li>$_ENV：环境数据。</li>
</ul>
<p>举例：打印 $_SERVER 预定义变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预定义变量</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;<span class="comment">//&lt;pre&gt; HTML标签</span></span><br><span class="line">	print_r($_SERVER);<span class="comment">//打印的有一定规则</span></span><br></pre></td></tr></table></figure>

<p>可以查看该常量下的一些内容：</p>
<img src="/2020/02/29/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class>

<p>如果要获取预定义变量中某个键值，可以 <code>$变量名[&#39;键名&#39;]</code>，以$_SERVER为例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印$_SERVER的REMOTE_ADDR属性</span></span><br><span class="line">	<span class="keyword">echo</span> $_SERVER[<span class="string">'REMOTE_ADDR'</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>小结</strong>：</p>
<ol>
<li>预定义变量是PHP系统保存的一些常用变量，方便开发者使用</li>
<li>预定义变量都是数组，需要以数组方式使用</li>
</ol>
<h3 id="3、变量传值"><a href="#3、变量传值" class="headerlink" title="3、变量传值"></a>3、变量传值</h3><p>分为两种，值传递和引用传递（和C类似）。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#值传递</span></span><br><span class="line">$a = <span class="number">10</span>;</span><br><span class="line">$b = $a;	<span class="comment">//将$a的值10取出后赋给$b</span></span><br><span class="line"><span class="comment">#引用传递</span></span><br><span class="line">$c = <span class="number">5</span>;</span><br><span class="line">$d = &amp;$c;	<span class="comment">//将$c的值的内存地址取出，赋值给$d，也为5</span></span><br></pre></td></tr></table></figure>

<h3 id="4、常量"><a href="#4、常量" class="headerlink" title="4、常量"></a>4、常量</h3><p><strong>概念</strong>：一种能够存储数据的符号，值不可以改变。</p>
<p><strong>定义变量</strong></p>
<ul>
<li>使用函数：define(‘常量名’,常量值);</li>
<li>使用关键字：const 常量名 = 常量值；</li>
</ul>
<p><strong>访问常量</strong></p>
<ul>
<li>直接访问：常量名</li>
<li>使用函数：constant(“常量名”);</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义</span></span><br><span class="line">define(<span class="string">'VERSION'</span>,<span class="number">1.0</span>);</span><br><span class="line">define(<span class="string">'-_-'</span>,<span class="string">'smile'</span>);</span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">#访问</span></span><br><span class="line"><span class="keyword">echo</span> PI;</span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">'VERSION'</span>);</span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">'-_-'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong></p>
<p>PHP7以后允许定义数组常量（一次性定义多个常量），访问时使用数组下标访问。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MATH = <span class="keyword">array</span>(</span><br><span class="line">	<span class="string">'PI'</span> =&gt;<span class="number">3.14</span>,</span><br><span class="line">    <span class="string">'E'</span> =&gt;<span class="number">2.72</span></span><br><span class="line">);<span class="comment">//定义</span></span><br><span class="line"><span class="keyword">echo</span> MATH[<span class="string">'PI'</span>];<span class="comment">//访问</span></span><br></pre></td></tr></table></figure>

<h3 id="5、系统常量"><a href="#5、系统常量" class="headerlink" title="5、系统常量"></a>5、系统常量</h3><p><strong>概念</strong>：系统内部定义的常量，用户可以直接访问，也只能访问。</p>
<ul>
<li>固定系统常量：值是固定的</li>
<li>魔术常量：值可以改变（性质确定，可以改变指的是改值在不同的情况场景下又不同的值）</li>
</ul>
<p><strong>固定系统常量</strong></p>
<ul>
<li>PHP_VERSION：PHP版本号</li>
<li>PHP_INT_SIZE：PHP中整数所占用的字符数。</li>
<li>PHP_INT_MAX：PHP中整数能表示的最大值。</li>
</ul>
<p><strong>魔术常量</strong></p>
<p>以双下划线开始，双下划线结束</p>
<ul>
<li>__DIR__：当前运行文件所在的绝对路径。</li>
<li>__FILE__：当前运行文件的绝对路径。</li>
<li>__LINE__：当前代码所在的行号。</li>
<li>__FUCTION__：函数内部使用，表示当前函数的名字。</li>
<li>__CLASS__：类的内部方法里使用，表示当前类名。</li>
<li>__METHOD__：类内部方法里使用，表示当前方法的名字（带类名）。</li>
<li>__NAMESPACE__：当前所属的命名空间。</li>
</ul>
<h3 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h3><ul>
<li><p>基本数据类型：整型（int/integer），浮点型（float），布尔型（bool/boolean），字符串型（string）。</p>
</li>
<li><p>复合数据类型：数组型（array），对象型（object）。</p>
</li>
<li><p>特殊数据类型：资源型（resource，数据库资源/文件资源），空型（null）。</p>
</li>
</ul>
<p><strong>提示</strong>：可用var_dump()查看变量的详细情况</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>A little idea</title>
    <url>/2020/02/28/First-little-idea/</url>
    <content><![CDATA[<h2 id="2020-1-31"><a href="#2020-1-31" class="headerlink" title="2020.1.31"></a>2020.1.31</h2><a id="more"></a>

<p>转眼间2020已过去一个月的时间，这一个月显然并不平静，国外各种不和谐的事件发生，我们的篮球偶像科比逝世，当然，还有形势日趋严重的新型冠状病毒疫情。希望一切都能再回到正常的轨道上去吧。</p>
<blockquote>
<p>愿安好。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>最爱的BGM</title>
    <url>/2020/02/28/%E6%9C%80%E7%88%B1%E7%9A%84BGM/</url>
    <content><![CDATA[<p>44首BGM，请君欣赏。</p>
<a id="more"></a>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=3222803102&auto=1&height=430"></iframe>
[网易云歌单链接]: https://music.163.com/#/playlist?id=3222803102&amp;userid=42466756]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>Android_UI</title>
    <url>/2020/02/28/Android-UI/</url>
    <content><![CDATA[<p>Android UI的知识点总结，初入Android，做些总结。</p>
<a id="more"></a>

<p>现在学习主要是跟着视频教程边看边学，现将学习到的零星知识点总结如下：</p>
<p>Android 系统中的所有 UI 类都是建立在 View 和 ViewGroup 两个类的基础之上的，所有 View 的子类称为 Widget，所有 ViewGroup 的子类称为 Layout。其中 ViewGroup 是 View 的子类。</p>
<p>View 是所有 UI 组件的基类，基本上所有的高级 UI 组件都是继承 View 类实现的，如 TextView（文本框）、Button、List、EditText（编辑框）、Checkbox 等。一个 View 在屏幕占据一块矩形区域，负责渲染这块矩形区域，也可以处理这块矩形区域发生的事件，并可以设置该区域是否可见以及获取焦点等。</p>
<p>ViewGroup 是容纳这些组件的容器，其本身也是从 View 中派生出来的，它继承于 Android.view.View，功能就是装载和管理下一层的 View 对象或 ViewGroup 对象，也就是说它是一个容纳其他元素的容器，负责对添加进来的 View 和 ViewGroup 进行管理和布局。</p>
<p><strong>Android常用的UI组件：<a href="https://blog.csdn.net/m0_37597069/article/details/70196271" target="_blank" rel="noopener">参见链接</a></strong></p>
<p>首先有一些属性是通用的：</p>
<p>id=”@+id/name”创建一个id 引用时：”@id/name”</p>
<p>orientation  水平方向或垂直方向</p>
<p>margin：外边距</p>
<p>padding：内边距</p>
<p>gravity：位置管理</p>
<h3 id="一、布局管理"><a href="#一、布局管理" class="headerlink" title="一、布局管理"></a>一、布局管理</h3><p>Android SDK 定义了多种布局方式以方便用户设计 UI。各种布局方式均为 ViewGroup 类的子类。</p>
<img src="/2020/02/28/Android-UI/0.png" class>

<p>主要学习的是两种最常用的布局，是线性布局（LinearLayout）和相对布局（RelativeLayout）。</p>
<p><strong>1、线性布局（LinearLayout）</strong></p>
<p>LinearLayout 又称线性布局，该布局应该是 Android 视图设计中最经常使用的布局。该布局可以使放入其中的组件以水平方式或者垂直方式整齐排列，通过 android:orientation 属性指定具体的排列方式，通过 weight 属性设置每个组件在布局中所占的比重。</p>
<p>其中weight属性需要特别注意：weight代表的是权值，但此权值的分配是指剩余的空间（未被元素使用的空间按照权值比例分配），需要理解掌握。</p>
<p><strong>2、相对布局（RelativeLayout）</strong></p>
<p>RelativeLayout 又称相对布局。从名称上可以看出，这种布局方式是以一种让组件以相对于容器或者相对于容器中的另一个组件的相对位置进行放置的布局方式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:layout_above=”@id/xxx”</td>
<td>将控件置于给定 ID 控件之上</td>
</tr>
<tr>
<td>android:layout_below=”@id/xxx”</td>
<td>将控件置于给定 ID 控件之下</td>
</tr>
<tr>
<td>android:layout_toLeftOf=”@id/xxx”</td>
<td>将控件的右边缘和给定 ID 控件的左边缘对齐</td>
</tr>
<tr>
<td>android:layout_toRightOf=”@id/xxx”</td>
<td>将控件的左边缘和给定 ID 控件的右边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignBaseline=”@id/xxx”</td>
<td>将控件的 baseline 与给定 ID 的 baseline 对齐</td>
</tr>
<tr>
<td>android:layout_alignTop=”@id/xxx”</td>
<td>将控件的上边缘和给定 ID 控件的上边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignBottom=”@id/xxx”</td>
<td>将控件的底边缘和给定 ID 控件的底边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignLeft=”@id/xxx”</td>
<td>将控件的左边缘和给定 ID 控件的左边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignRight=”@id/xxx”</td>
<td>将控件的右边缘和给定 ID 控件的右边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignParentLeft=”true”</td>
<td>将控件的左边缘和父控件的左边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignParentTop=”true”</td>
<td>将控件的上边缘和父控件的上边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignParentRight=”true”</td>
<td>将控件的右边缘和父控件的右边缘对齐</td>
</tr>
<tr>
<td>android:layout_alignParentBottom=”true”</td>
<td>将控件的底边缘和父控件的底边缘对齐</td>
</tr>
<tr>
<td>android:layout_centerInParent=”true”</td>
<td>将控件置于父控件的中心位置</td>
</tr>
<tr>
<td>android:layout_centerHorizontal=”true”</td>
<td>将控件置于水平方向的中心位置</td>
</tr>
<tr>
<td>android:layout_centerVertical=”true”</td>
<td>将控件置于垂直方向的中心位置</td>
</tr>
</tbody></table>
<h3 id="二、TextView（文本框）"><a href="#二、TextView（文本框）" class="headerlink" title="二、TextView（文本框）"></a>二、TextView（文本框）</h3><p>设置文本框的最大行数（当然还有其他设置最大）：android:maxLines=”1”<br>设置文本显示方式：<br>end表示显示不完省略号：android:ellipsize=”end”<br>marquee表示显示不完播放：android:ellipsize=”marquee”<br>再加上这样几行可以循环播放<br>android:marqueeRepeatLimit=”marquee_forever”<br>android:focusable=”true”<br>android:focusableInTouchMode=”true”<br>添加图片，调整图片边距等<br>android:drawableRight=”@drawable/name”//表示在文本右边添加图片<br>android:drawablePadding=”5dp”</p>
<h3 id="三、Button（按钮）"><a href="#三、Button（按钮）" class="headerlink" title="三、Button（按钮）"></a>三、Button（按钮）</h3><p>按钮学习的重点在改变按钮的样式和添加点击事件。</p>
<p>改变样式主要是将按钮改为圆角，更加美观。</p>
<p>可在drawable目录下新建xml文件修改。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"#FF9900"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:radius</span>=<span class="string">"5dp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再在要设置的按钮添加背景属性，设置为此xml文件即可。</p>
<p>同样可以设置很多效果，比如未点击和点击的不同颜色区分。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#CC7A00"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FF9900"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再就是添加点击事件，为普通按钮添加单击事件监听器。两种方式：</p>
<p>1、匿名内部类作为单击事件监听器，这里添加内容为显示被点击的按钮内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按钮3的点击事件</span></span><br><span class="line">mBtn3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(ButtonActivity.<span class="keyword">this</span>,<span class="string">"btn3我被点击了"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2、通过onClick属性实现</p>
<p>① 在Activity中编写一个包含View类型参数的方法。　　public void myClick(View view){}</p>
<p>② 将android:onClick属性指定为 ① 内的方法名。　　　android:onClick=”myClick”</p>
<p><strong>扩展 ：ImageButton图片按钮</strong></p>
<p>通过src属性指定</p>
<h3 id="四、EditText（编辑框）"><a href="#四、EditText（编辑框）" class="headerlink" title="四、EditText（编辑框）"></a>四、EditText（编辑框）</h3><p><strong>属性</strong></p>
<p>android:hint=”请输入用户名”  ：输入框提示信息</p>
<p>android:inputType=”number”：规定输入格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:inputType=<span class="string">"none"</span><span class="comment">//输入普通字符</span></span><br><span class="line">android:inputType=<span class="string">"text"</span><span class="comment">//输入普通字符</span></span><br><span class="line">android:inputType=<span class="string">"textCapCharacters"</span><span class="comment">//输入普通字符</span></span><br><span class="line">android:inputType=<span class="string">"textCapWords"</span><span class="comment">//单词首字母大小</span></span><br><span class="line">android:inputType=<span class="string">"textCapSentences"</span><span class="comment">//仅第一个字母大小</span></span><br><span class="line">android:inputType=<span class="string">"textAutoCorrect"</span><span class="comment">//前两个自动完成</span></span><br><span class="line">android:inputType=<span class="string">"textAutoComplete"</span><span class="comment">//前两个自动完成</span></span><br><span class="line">android:inputType=<span class="string">"textMultiLine"</span><span class="comment">//多行输入</span></span><br><span class="line">android:inputType=<span class="string">"textImeMultiLine"</span><span class="comment">//输入法多行（不一定支持）</span></span><br><span class="line">android:inputType=<span class="string">"textNoSuggestions"</span><span class="comment">//不提示</span></span><br><span class="line">android:inputType=<span class="string">"textUri"</span><span class="comment">//URI格式</span></span><br><span class="line">android:inputType=<span class="string">"textEmailAddress"</span><span class="comment">//电子邮件地址格式</span></span><br><span class="line">android:inputType=<span class="string">"textEmailSubject"</span><span class="comment">//邮件主题格式</span></span><br><span class="line">android:inputType=<span class="string">"textShortMessage"</span><span class="comment">//短消息格式</span></span><br><span class="line">android:inputType=<span class="string">"textLongMessage"</span><span class="comment">//长消息格式</span></span><br><span class="line">android:inputType=<span class="string">"textPersonName"</span><span class="comment">//人名格式</span></span><br><span class="line">android:inputType=<span class="string">"textPostalAddress"</span><span class="comment">//邮政格式</span></span><br><span class="line">android:inputType=<span class="string">"textPassword"</span><span class="comment">//密码格式</span></span><br><span class="line">android:inputType=<span class="string">"textVisiblePassword"</span><span class="comment">//密码可见格式</span></span><br><span class="line">android:inputType=<span class="string">"textWebEditText"</span><span class="comment">//作为网页表单的文本格式</span></span><br><span class="line">android:inputType=<span class="string">"textFilter"</span><span class="comment">//文本筛选格式</span></span><br><span class="line">android:inputType=<span class="string">"textPhonetic"</span><span class="comment">//拼音输入格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数值类型</span></span><br><span class="line">android:inputType=<span class="string">"number"</span><span class="comment">//数字格式</span></span><br><span class="line">android:inputType=<span class="string">"numberSigned"</span><span class="comment">//有符号数字格式</span></span><br><span class="line">android:inputType=<span class="string">"numberDecimal"</span><span class="comment">//可以带小数点的浮点格式</span></span><br><span class="line">android:inputType=<span class="string">"phone"</span><span class="comment">//拨号键盘</span></span><br><span class="line">android:inputType=<span class="string">"datetime"</span><span class="comment">//日期+时间格式</span></span><br><span class="line">android:inputType=<span class="string">"date"</span><span class="comment">//日期键盘</span></span><br><span class="line">android:inputType=<span class="string">"time"</span><span class="comment">//时间键盘</span></span><br><span class="line">转自CSDN：原文链接：https:<span class="comment">//blog.csdn.net/zhangphil/article/details/79970667</span></span><br></pre></td></tr></table></figure>

<p>同样也可在编辑框里添加图片等操作，android:drawableLeft=”@drawable/name”  。（与android:drawableStart相同）</p>
<p>同理：android:drawableBottom,android:drawableRight(android:drawableEnd)</p>
<p>android:drawablePadding:内边距</p>
<p>android:lines：限制行数，超出时向上滚动。</p>
<p>getText():获取编辑框内容</p>
<h3 id="五、RadioButton（单选框）"><a href="#五、RadioButton（单选框）" class="headerlink" title="五、RadioButton（单选框）"></a>五、RadioButton（单选框）</h3><p>RadioGroup 为单项选择按钮组，其中可以包含多个 RadioButton，即单选按钮，它们共同为用户提供一种多选一的选择方式。在多个 RadioButton 被同一个 RadioGroup 包含的情况下，多个 RadioButton 之间自动形成互斥关系，仅有一个可以被选择。</p>
<p>基本格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">RadioButton</span>/&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">RadioButton</span>/&gt;</span></span><br><span class="line">　　.....</span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>RadioGroup中也有orientation属性，即选择水平或竖直方向排列RadioButton。</p>
<p>RadioButton中的属性：</p>
<p>按钮名称：android:text=”name”</p>
<p>表示被默认选中的选项：android:checked=”true”<br>设置按钮形状：android:button=”@null”（表示不设置）</p>
<p><strong>可以自定义按钮选中时的样式：</strong></p>
<p>同样在drawable目录下新建xml文件修改。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_checked</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#CC7A00"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_checked</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:width</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:color</span>=<span class="string">"#CC7A00"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中state_checked表示是否选中的状态</p>
<p> 效果：</p>
<img src="/2020/02/28/Android-UI/1.png" class>

<p>这种效果时通过背景实现不同的状态表示。</p>
<h4 id="添加选中事件获取选中的内容。"><a href="#添加选中事件获取选中的内容。" class="headerlink" title="添加选中事件获取选中的内容。"></a>添加选中事件获取选中的内容。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取单选按钮组RadioGroup mRg1，设置选中监听事件</span></span><br><span class="line">mRg1.setOnCheckedChangeListener(<span class="keyword">new</span> RadioGroup.OnCheckedChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(RadioGroup group, <span class="keyword">int</span> checkedId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据选中的checkedId值获取内容</span></span><br><span class="line">        RadioButton radioButton = group.findViewById(checkedId);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        Toast.makeText(RadioButtonActivity.<span class="keyword">this</span>,radioButton.getText(),Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="六、CheckBox（多选框）"><a href="#六、CheckBox（多选框）" class="headerlink" title="六、CheckBox（多选框）"></a>六、CheckBox（多选框）</h3><p>大致与单选相同，介绍另一种通过自定义改变按钮形状实现按钮样式。</p>
<p>这里将  android:button=”@drawable/bg_checkbox” 设置为自定义的。bg_checkbox同样新建的xml文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_checked</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/face"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_checked</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/selection"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="七、ImageView（图片视图）"><a href="#七、ImageView（图片视图）" class="headerlink" title="七、ImageView（图片视图）"></a>七、ImageView（图片视图）</h3><p><strong>1、介绍属性</strong></p>
<p>background为背景，src为内容。</p>
<p>scaleType：覆盖方式，常见属性值有：</p>
<p>　　fixXY：撑满控件，宽高比可能发生改变。</p>
<p>　　fitCenter：保持宽高比缩放，直至能够完全显示。</p>
<p>　　centerCrop：保持宽高比缩放，直至能够完全覆盖控件，剪裁显示。</p>
<p><strong>2、加载网络图片</strong></p>
<p>首先使用第三方的库，这里选择的是Github上的glide库</p>
<p> <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></p>
<img src="/2020/02/28/Android-UI/2.png" class>

<p>将其添加到Android Studio中的build.gradle目录下。</p>
<img src="/2020/02/28/Android-UI/3.png" class>

<p> 同步好后在activity的Java代码部分添加代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_image_view);</span><br><span class="line">    mIv2 = findViewById(R.id.iv_2);</span><br><span class="line">    <span class="comment">//加载一张网络图片</span></span><br><span class="line">    Glide.with(<span class="keyword">this</span>).load(<span class="string">"http://i1.sinaimg.cn/ent/d/2008-06-04/U105P28T3D2048907F326DT20080604225106.jpg"</span>).into(mIv2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要在AndroidManifest.xml中声明使用网络权限。</p>
<p>添加一行代码： <uses-permission android:name="android.permission.INTERNET"> 即可。</uses-permission></p>
<h3 id="八、日期选择器，时间选择器，计时器"><a href="#八、日期选择器，时间选择器，计时器" class="headerlink" title="八、日期选择器，时间选择器，计时器"></a>八、日期选择器，时间选择器，计时器</h3><h4 id="1、DatePicker（日期选择器）"><a href="#1、DatePicker（日期选择器）" class="headerlink" title="1、DatePicker（日期选择器）"></a>1、DatePicker（日期选择器）</h4><p>即可显示日期，可以添加事件接收选择的日期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year,month,day;</span><br><span class="line">DatePicker datePicker;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_date_pcker);</span><br><span class="line">    <span class="comment">//日期选择器的id为datepicker</span></span><br><span class="line">    datePicker = findViewById(R.id.datepicker);</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    year = calendar.get(calendar.YEAR);</span><br><span class="line">    month = calendar.get(calendar.MONTH);</span><br><span class="line">    day = calendar.get(calendar.DAY_OF_MONTH);</span><br><span class="line">    <span class="comment">//添加选择事件</span></span><br><span class="line">    datePicker.init(year, month, day, <span class="keyword">new</span> DatePicker.OnDateChangedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDateChanged</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>&#123;</span><br><span class="line">            DatePickerActivity.<span class="keyword">this</span>.year = year;</span><br><span class="line">            DatePickerActivity.<span class="keyword">this</span>.month = monthOfYear;</span><br><span class="line">            DatePickerActivity.<span class="keyword">this</span>.day = dayOfMonth;</span><br><span class="line">            show(year,month,day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">    String str = year+<span class="string">"年"</span>+(month+<span class="number">1</span>)+<span class="string">"月"</span>+day+<span class="string">"日"</span>;</span><br><span class="line">    Toast.makeText(DatePickerActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、TimePicker（时间选择器）"><a href="#2、TimePicker（时间选择器）" class="headerlink" title="2、TimePicker（时间选择器）"></a>2、TimePicker（时间选择器）</h4><p>显示时间，添加一个监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timepicker为时间选择器的id</span></span><br><span class="line">TimePicker tp = findViewById(R.id.timepicker);</span><br><span class="line">tp.setIs24HourView(<span class="keyword">true</span>);<span class="comment">//采用24小时支持</span></span><br><span class="line"><span class="comment">//时间改变的监听器</span></span><br><span class="line">tp.setOnTimeChangedListener(<span class="keyword">new</span> TimePicker.OnTimeChangedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeChanged</span><span class="params">(TimePicker view, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute)</span> </span>&#123;</span><br><span class="line">        String str = hourOfDay+<span class="string">"时"</span>+minute+<span class="string">"分"</span>;</span><br><span class="line">        Toast.makeText(TimePickerActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3、Chronometer（计时器）"><a href="#3、Chronometer（计时器）" class="headerlink" title="3、Chronometer（计时器）"></a>3、Chronometer（计时器）</h4><p>属性通常设置 android:format=”已用时间：%s” 表示用时分秒的格式计时。</p>
<p>并通常需要为计时器设定四个方法。</p>
<p>① setBase()：设置计时器的起始时间</p>
<p>② setFormat()：设置显示时间的格式</p>
<p>③ start()：指定开始计时</p>
<p>④ stop()：指定结束计时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chronometer ch ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_chronometer);</span><br><span class="line">    ch = findViewById(R.id.chromometer);</span><br><span class="line">    <span class="comment">//获取当前的系统时间</span></span><br><span class="line">    ch.setBase(SystemClock.elapsedRealtime());</span><br><span class="line">    <span class="comment">//设置时间格式</span></span><br><span class="line">    ch.setFormat(<span class="string">"%s"</span>);</span><br><span class="line">    <span class="comment">//开启计时器</span></span><br><span class="line">    ch.start();</span><br><span class="line">    <span class="comment">//添加监听器，计时器改变时触发</span></span><br><span class="line">    ch.setOnChronometerTickListener(<span class="keyword">new</span> Chronometer.OnChronometerTickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChronometerTick</span><span class="params">(Chronometer chronometer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(SystemClock.elapsedRealtime()-ch.getBase()&gt;=<span class="number">60000</span>)&#123;<span class="comment">//如果大于60s，停止计时</span></span><br><span class="line">                ch.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，第一部分总结。</p>
<hr>
<p>以下为第二部分总结。</p>
<h3 id="一、ProgressBar（进度条）"><a href="#一、ProgressBar（进度条）" class="headerlink" title="一、ProgressBar（进度条）"></a>一、ProgressBar（进度条）</h3><p>进度条有两种形式，圆形加载式和水平长条形状，可通过style属性设置（注意：前面没有android:）</p>
<p>列举几种：</p>
<p>　　?android:attr/progressBarStyleHorizontal　　　　细水平长度进度条</p>
<p>　　?android:attr/progressBarStyleSmall　　　　　　旋转画面的小圆形进度条</p>
<p>　　?android:attr/progressBarStyleLarge　　　　　　旋转画面的大圆形进度条</p>
<p>　　@android:style/Widget.ProgressBar.Horizontal　　粗水平长度进度条</p>
<p>　　@android:style/Widget.ProgressBar.Small　　　　旋转画面的小圆形进度条</p>
<p>　　@android:style/Widget.ProgressBar.Large　　　　旋转画面的大圆形进度条</p>
<p>android:max=”100” 　　　 　该属性设置进程的最大值<br>android:progress=”50”　　　表示初始的进程值</p>
<p><strong>实现动态进度条步骤：</strong></p>
<p>创建线程，判断耗时操作是否完成，若没有完成，调用进度条的setProgress()方法更新进度，然后循环操作，直到耗时操作完成，然后调用setVisibility()方法设置进度条不显示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--    style确定进度条样式，max指定进度条值，便于后台判断    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/progressbar"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@android:style/Widget.ProgressBar.Horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"60dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:max</span>=<span class="string">"100"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>后台Java代码：</p>
<p>private ProgressBar progressBar;<br>    private int mProgress=0;<br>    private Handler mhandler;//消息处理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_progress_bar);</span><br><span class="line">    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,</span><br><span class="line">            WindowManager.LayoutParams.FLAG_FULLSCREEN);<span class="comment">//设置全屏显示</span></span><br><span class="line">    progressBar = findViewById(R.id.progressbar);</span><br><span class="line">    mhandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//判断线程是否完成，未完成则更新进度，完成则隐藏(通过线程模拟耗时操作)</span></span><br><span class="line">            <span class="keyword">if</span>(msg.what==<span class="number">0x111</span>)</span><br><span class="line">                progressBar.setProgress(mProgress);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Toast.makeText(ProgressBarActivity.<span class="keyword">this</span>,<span class="string">"耗时操作已完成"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                progressBar.setVisibility(View.GONE);<span class="comment">//设置进度条不显示</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                mProgress = doWork();<span class="comment">//耗时操作</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                <span class="keyword">if</span>(mProgress&lt;<span class="number">100</span>)&#123;<span class="comment">//耗时操作未完成</span></span><br><span class="line">                    message.what=<span class="number">0x111</span>;<span class="comment">//自定义消息代码,表示未完成</span></span><br><span class="line">                    mhandler.sendMessage(message);<span class="comment">//发送消息，更新进度</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    message.what=<span class="number">0x110</span>;<span class="comment">//表示已完成</span></span><br><span class="line">                    mhandler.sendMessage(message);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;<span class="comment">//自定义doWork方法，模拟耗时</span></span><br><span class="line">            mProgress+=Math.random()*<span class="number">10</span>;<span class="comment">//利用随机数生成加载进度</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mProgress;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、SeekBar（拖动条）"><a href="#二、SeekBar（拖动条）" class="headerlink" title="二、SeekBar（拖动条）"></a>二、SeekBar（拖动条）</h3><p>是ProgressBar的子类，有些相同之处。</p>
<p>属性：</p>
<p>与ProgressBar一样，有 max,progress属性。</p>
<p>android:thumb=”@drawable/pwd”属性设置进度条的按钮形状。</p>
<p>使用时，需要添加可以获取进度条改变的事件监听器，来改变当前显示的内容。</p>
<p>seekseekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {<br>            @Override<br>            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {//进度改变所执行的方法<br>                Toast.makeText(SeekBarActivity.this,”进度改变：”+progress,Toast.LENGTH_SHORT).show();<br>            }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;<span class="comment">//开始触摸所执行的方法</span></span><br><span class="line">        Toast.makeText(SeekBarActivity.<span class="keyword">this</span>,<span class="string">"开始触摸"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(SeekBarActivity.<span class="keyword">this</span>,<span class="string">"停止触摸"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="三、RatingBar（星级评分条）"><a href="#三、RatingBar（星级评分条）" class="headerlink" title="三、RatingBar（星级评分条）"></a>三、RatingBar（星级评分条）</h3><p>属性：</p>
<p>android:numStars=”5” 代表有五颗星<br>android:rating=”4” 　　代表默认选择四颗<br>android:stepSize=”1”　选择的最小单位为一颗</p>
<p>android:isIndicator=”true” 代表不可改变</p>
<p><strong>注意：宽度不要设置为match_parent，否则会影响星星数量。</strong></p>
<p>package com.example.tiange_project;</p>
<p>import android.os.Bundle;<br>import android.view.View;<br>import android.widget.Button;<br>import android.widget.RatingBar;<br>import android.widget.Toast;</p>
<p>import androidx.appcompat.app.AppCompatActivity;</p>
<p>public class RatingBarActivity extends AppCompatActivity {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RatingBar ratingBar;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_rating_bar);</span><br><span class="line">    ratingBar = findViewById(R.id.ratingbar);</span><br><span class="line">    <span class="comment">//获取选中几颗星</span></span><br><span class="line">    String rating = String.valueOf(ratingBar.getRating());</span><br><span class="line">    Toast.makeText(RatingBarActivity.<span class="keyword">this</span>,<span class="string">"Rating:"</span>+rating,Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="comment">//获取改变的星星数量</span></span><br><span class="line">    String stepSize = String.valueOf(ratingBar.getStepSize());</span><br><span class="line">    Toast.makeText(RatingBarActivity.<span class="keyword">this</span>,<span class="string">"StepSize:"</span>+stepSize,Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="comment">//获取进度</span></span><br><span class="line">    String progress = String.valueOf(ratingBar.getProgress());</span><br><span class="line">    Toast.makeText(RatingBarActivity.<span class="keyword">this</span>,<span class="string">"Progress:"</span>+progress,Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、添加单击事件，提交按钮</span></span><br><span class="line">    Button button = findViewById(R.id.rating_button);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> rating = ratingBar.getRating();</span><br><span class="line">            Toast.makeText(RatingBarActivity.<span class="keyword">this</span>,<span class="string">"你得到了"</span>+rating+<span class="string">"颗星！"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h3 id="四、ImageSwitcher（图像切换器）"><a href="#四、ImageSwitcher（图像切换器）" class="headerlink" title="四、ImageSwitcher（图像切换器）"></a>四、ImageSwitcher（图像切换器）</h3><p>设置切换图片的淡入淡出效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tiange_project;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.animation.AnimationUtils;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageSwitcher;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.ViewSwitcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageSwitcherActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ImageSwitcher imageSwitcher;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_image_switcher);</span><br><span class="line">    imageSwitcher = findViewById(R.id.imageswitcher);</span><br><span class="line">    <span class="comment">//设置淡出动画</span></span><br><span class="line">    imageSwitcher.setOutAnimation(AnimationUtils.loadAnimation(ImageSwitcherActivity.<span class="keyword">this</span>,android.R.anim.fade_out));</span><br><span class="line">    <span class="comment">//设置进入动画</span></span><br><span class="line">    imageSwitcher.setInAnimation(AnimationUtils.loadAnimation(ImageSwitcherActivity.<span class="keyword">this</span>,android.R.anim.fade_in));</span><br><span class="line"></span><br><span class="line">    imageSwitcher.setFactory(<span class="keyword">new</span> ViewSwitcher.ViewFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">makeView</span><span class="params">()</span> </span>&#123;<span class="comment">//为图像切换器指定视图工厂</span></span><br><span class="line">            ImageView imageView = <span class="keyword">new</span> ImageView(ImageSwitcherActivity.<span class="keyword">this</span>);</span><br><span class="line">            imageView.setImageResource(R.drawable.image01);</span><br><span class="line">            <span class="keyword">return</span> imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    imageSwitcher.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            ((ImageSwitcher)v).setImageResource(R.drawable.image02);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h3 id="五、GrideView（网格视图）"><a href="#五、GrideView（网格视图）" class="headerlink" title="五、GrideView（网格视图）"></a>五、GrideView（网格视图）</h3><p>属性：</p>
<p>android:numColumns=”3” 设定列数为3</p>
<p>适配器(Adapter)：连接后端数据与前端显示的接口，数据和UI组件的重要纽带。</p>
<img src="/2020/02/28/Android-UI/4.png" class>


<p> 通过适配器adapter实现数据源显示到GrideView上。</p>
<p>Android提供了四个适配器实现类，分别是</p>
<p>① ArrayAdapter：数组适配器。</p>
<p>② SimpleAdapter：简单适配器，功能强大。</p>
<p>③ SimpleCursorAdapter:简单数据库适配器。</p>
<p>④ BaseAdapter：对各个列表项进行限制。</p>
<p><strong>为GrideView添加适配器</strong></p>
<p>在Java代码中添加适配器，但在使用其时，一般先创捷一个布局文件cell.xml（在其内部添加ImageView组件，显示视图）。我们可在其中任意自定义资源文件，以显示不同的效果。</p>
<p>package com.example.tiange_project;</p>
<p>import android.os.Bundle;<br>import android.widget.GridView;<br>import android.widget.SimpleAdapter;</p>
<p>import androidx.appcompat.app.AppCompatActivity;</p>
<p>import java.util.ArrayList;<br>import java.util.HashMap;<br>import java.util.List;<br>import java.util.Map;</p>
<p>public class GrideViewActivity extends AppCompatActivity {<br>    //创建int数组，记录资源id<br>    private int[] picture = new int[]{R.drawable.img01,R.drawable.img02,R.drawable.img03,<br>                                      R.drawable.img04,R.drawable.img05,R.drawable.img06,<br>                                      R.drawable.img07,R.drawable.img08,R.drawable.img09};</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_gride_view);</span><br><span class="line">    GridView gridView = findViewById(R.id.grideview);</span><br><span class="line">    <span class="comment">//存储图片资源</span></span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; listitem = <span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;picture.length;i++)&#123;<span class="comment">//通过for循环添加对象</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">"image"</span>,picture[i]);</span><br><span class="line">        listitem.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立适配器对象</span></span><br><span class="line">    SimpleAdapter simpleAdapter = <span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>,listitem,R.layout.cell,<span class="keyword">new</span> String[]&#123;<span class="string">"image"</span>&#125;,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.id.image&#125;);</span><br><span class="line">    <span class="comment">//设置适配器</span></span><br><span class="line">    gridView.setAdapter(simpleAdapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h3 id="六、Spinner（下拉列表）"><a href="#六、Spinner（下拉列表）" class="headerlink" title="六、Spinner（下拉列表）"></a>六、Spinner（下拉列表）</h3><p>属性：</p>
<p>entries=“” 是一个数组资源，表示下拉列表的内容选项。数据存储在values下自己新建的arrays目录。</p>
<img src="/2020/02/28/Android-UI/5.png" class>


<p> 在其中编写代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  使用item添加各个数组元素  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">"ctype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>电影<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>图书<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>游戏<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即可正常显示出下拉列表。</p>
<h4 id="也可通过适配器设置下拉选项。"><a href="#也可通过适配器设置下拉选项。" class="headerlink" title="也可通过适配器设置下拉选项。"></a>也可通过适配器设置下拉选项。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tiange_project;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter;</span><br><span class="line"><span class="keyword">import</span> android.widget.Spinner;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinnerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_spinner);</span><br><span class="line">        String[] ctype = <span class="keyword">new</span> String[]&#123;<span class="string">"全部"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line">        <span class="comment">//数组适配器</span></span><br><span class="line">        ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_spinner_item,ctype);</span><br><span class="line">        <span class="comment">//为适配器设置下拉的选择样式</span></span><br><span class="line">        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);</span><br><span class="line">        Spinner spinner = findViewById(R.id.spinner);</span><br><span class="line">        spinner.setAdapter(adapter);</span><br><span class="line">        <span class="comment">//获取选择的选项</span></span><br><span class="line">        String str = spinner.getSelectedItem().toString();</span><br><span class="line">        Toast.makeText(SpinnerActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、ListView（列表视图）"><a href="#七、ListView（列表视图）" class="headerlink" title="七、ListView（列表视图）"></a>七、ListView（列表视图）</h3><p>和下拉列表基本一致。</p>
<h3 id="八、滚动视图"><a href="#八、滚动视图" class="headerlink" title="八、滚动视图"></a>八、滚动视图</h3><p><strong>分为 ScrollView（垂直滚动） 和 HorizontalScrollView（水平滚动）</strong></p>
<p>要注意的是，其中只能包含一个组件，若要包含多个，则需要用布局管理器将其包含起来。</p>
<h3 id="九、选项卡"><a href="#九、选项卡" class="headerlink" title="九、选项卡"></a>九、选项卡</h3><p>在Android中，没有固定的组件实现，一般通过以下四个步骤实现。</p>
<p>1、在布局文件中添加TabHost、TabWidget和TabContent组件</p>
<p>2、编写各标签页的xmi布局文件，即各个选项的显示页面。</p>
<p>3、获取并初始化TabHost组件</p>
<p>4、将TabHost添加到标签页中</p>
<p><strong>实例</strong></p>
<p>1、先创建固定格式的布局文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TabHost</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".TabActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@android:id/tabhost"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TabWidget</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@android:id/tabs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">TabWidget</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@android:id/tabcontent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TabHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、编写后台Java代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tiange_project;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.widget.TabHost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TabActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_tab);</span><br><span class="line">        <span class="comment">//初始化TabHost组件</span></span><br><span class="line">        TabHost tabHost = findViewById(android.R.id.tabhost);</span><br><span class="line">        tabHost.setup();<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">        LayoutInflater inflater = LayoutInflater.from(<span class="keyword">this</span>);<span class="comment">//用这个对象加载两个标签页的布局文件</span></span><br><span class="line">        inflater.inflate(R.layout.tab1,tabHost.getTabContentView());<span class="comment">//1</span></span><br><span class="line">        inflater.inflate(R.layout.tab2,tabHost.getTabContentView());<span class="comment">//2</span></span><br><span class="line">        <span class="comment">//添加标签页</span></span><br><span class="line">        tabHost.addTab(tabHost.newTabSpec(<span class="string">"tab1"</span>).setIndicator(<span class="string">"精选表情"</span>).setContent(R.id.left));</span><br><span class="line">        tabHost.addTab(tabHost.newTabSpec(<span class="string">"tab2"</span>).setIndicator(<span class="string">"投稿表情"</span>).setContent(R.id.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，tab1和tab2都是自定义的xml布局文件，表示标签页显示的内容。</p>
<p>即可完成。</p>
<p>到此，基本的UI组件学习已经完成，当然每个组件都只是刚刚入门，想要精通还有很长一段路要走。</p>
<p>继续加油吧！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建总结(一)</title>
    <url>/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第三次尝试搭建Hexo博客"><a href="#第三次尝试搭建Hexo博客" class="headerlink" title="第三次尝试搭建Hexo博客"></a>第三次尝试搭建Hexo博客</h2><p>干掉 干掉！</p>
<p>多尝试几次，大不了干掉重来！</p>
<a id="more"></a>

<hr>
<p>这篇文章就作为搭建博客时出现的问题及解决方法的总结，整个搭建过程并不尽人意。多多总结，少走弯路。</p>
<h3 id="1、hexo-d命令时-的ERROR-Deployer-not-found-git错误提示"><a href="#1、hexo-d命令时-的ERROR-Deployer-not-found-git错误提示" class="headerlink" title="1、hexo d命令时 的ERROR Deployer not found: git错误提示"></a>1、hexo d命令时 的<code>ERROR Deployer not found: git</code>错误提示</h3><p>解决方法，执行命令 <code>cnpm install --save hexo-deployer-git</code>即可解决。</p>
<h3 id="2、hexo-d命令提交时取消弹出的输入GitHub账号密码框"><a href="#2、hexo-d命令提交时取消弹出的输入GitHub账号密码框" class="headerlink" title="2、hexo d命令提交时取消弹出的输入GitHub账号密码框"></a>2、hexo d命令提交时取消弹出的输入GitHub账号密码框</h3><p>GitHub不允许随意的提交，所以需要账号密码来确认操作。我们提交代码之前一定是需要某种授权的，而 GitHub 上一般都是基于 SSH 授权的。 </p>
<p><strong>那么什么是 SSH 呢？</strong> 简单点说，SSH是一种网络协议，用于计算机之间的加密登录。目前 </p>
<p>是每一台 Linux 电脑的标准配置。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权， </p>
<p>所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。</p>
<p>首先在博客根目录下输入ssh确定安装了ssh，出现如下则代表安装成功。</p>
<img src="/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class>

<p>紧接着输入ssh-keygen -t rsa 命令，敲击回车。</p>
<img src="/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class>

<p>然后就会生成两个文件 id_rsa 和 id_rsa.pub ，而 id_rsa 是密钥，id_rsa.pub 就是公钥。</p>
<p>然后找到 C:\Users\Administrator\.ssh 路径下的id_rsa.pub文件记事本打开，并将其中内容复制，添加到GitHub上即可。</p>
<h3 id="3、图片加载不出来"><a href="#3、图片加载不出来" class="headerlink" title="3、图片加载不出来"></a>3、图片加载不出来</h3><p>参考博客 <a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>
<p>需要注意的是，博客中引用图片通过命令  完成。例如 即可完成图片显示。</p>
<h3 id="4、将该站点配置到百度站点收录管理中"><a href="#4、将该站点配置到百度站点收录管理中" class="headerlink" title="4、将该站点配置到百度站点收录管理中"></a>4、将该站点配置到百度站点收录管理中</h3><p>需要将Hexo博客双线部署以实现百度收录。我们的博客部署在GitHub上百度是不能收录的，双线部署，可以选择码云等国内站点。</p>
<p>首先在码云上已经部署好，并且配置了Page的静态网站。</p>
<p>在百度上管理码云上该网站的地址域名，选择验证时用第二种方式HTML标签认证成功。</p>
<img src="/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class>

<ul>
<li><p>首先第一步，在next主题配置文件中添加下面这句，值就输入你content的值即可，配置里面可能没这个字段添加即可。</p>
<img src="/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class>
</li>
<li><p>第二步，我是在该路径下的head文件添加了百度的代码。</p>
<img src="/2020/02/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/5.png" class>
</li>
<li><p>然后Hexo生成发布博客即可。</p>
</li>
</ul>
<p>百度的收录需要一定的时间，现在百度的收录方式有所调整，注重高质量的网站，否则就算现在收录成功，以后的一段时间里也会收回。所以要保证网站内容的高质量化，只有一起努力，才能把自己的博客网站做到更好。</p>
<h3 id="5、搜索功能"><a href="#5、搜索功能" class="headerlink" title="5、搜索功能"></a>5、搜索功能</h3><p>参考博客：<a href="https://www.jianshu.com/p/202c9e789c8f" target="_blank" rel="noopener">https://www.jianshu.com/p/202c9e789c8f</a></p>
<h3 id="6、置顶文章功能"><a href="#6、置顶文章功能" class="headerlink" title="6、置顶文章功能"></a>6、置顶文章功能</h3><p>参考博客：<a href="https://blog.csdn.net/Aoman_Hao/article/details/103219750" target="_blank" rel="noopener">https://blog.csdn.net/Aoman_Hao/article/details/103219750</a></p>
<p>其中的复制粘贴操作经过实践可用。唯一有差别的是最后的代码没有找到 <code>&lt;span class=&quot;post-time&quot;&gt;</code>，只是把目标代码放在其中一个span里。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>experience</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
